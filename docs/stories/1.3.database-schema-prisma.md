# Story 1.3: Database Schema & Prisma Setup

---

## Status

**Draft**

---

## Story

**As a** developer,
**I want** Prisma ORM configured with PostgreSQL database schema for users and events,
**so that** I have type-safe database access with migration support.

---

## Acceptance Criteria

1. Prisma 5.9.1 installed and initialized
2. Schema defined for `users` table: id (UUID), firstName, lastName, dateOfBirth, timezone, createdAt, updatedAt
3. Schema defined for `events` table: id (UUID), userId (FK), eventType, targetTimestampUTC, targetTimestampLocal, targetTimezone, status (enum: PENDING, PROCESSING, COMPLETED, FAILED), version (for optimistic locking), idempotencyKey, executedAt, failureReason, createdAt, updatedAt
4. Index created on (target_timestamp_utc, status) for efficient scheduler queries
5. Prisma migration created and successfully applied to local database
6. Prisma Client generated with full TypeScript types
7. Database can be reset and reseeded for testing purposes

---

## Tasks / Subtasks

- [ ] **Task 1: Install and initialize Prisma** (AC: 1)
  - [ ] Install Prisma 5.9.1 as dev dependency: `npm install -D prisma@5.9.1`
  - [ ] Install @prisma/client 5.9.1: `npm install @prisma/client@5.9.1`
  - [ ] Initialize Prisma: `npx prisma init`
  - [ ] Verify prisma/ directory created with schema.prisma file
  - [ ] Configure DATABASE_URL in .env to point to local PostgreSQL

- [ ] **Task 2: Define users table schema in schema.prisma** (AC: 2)
  - [ ] Set datasource provider to postgresql
  - [ ] Set generator client to prisma-client-js
  - [ ] Define User model with id (String @id @default(uuid()) @db.Uuid)
  - [ ] Add firstName (String @map("first_name") @db.VarChar(100))
  - [ ] Add lastName (String @map("last_name") @db.VarChar(100))
  - [ ] Add dateOfBirth (DateTime @map("date_of_birth") @db.Date)
  - [ ] Add timezone (String @db.VarChar(100))
  - [ ] Add createdAt (DateTime @default(now()) @map("created_at") @db.Timestamptz)
  - [ ] Add updatedAt (DateTime @updatedAt @map("updated_at") @db.Timestamptz)
  - [ ] Add @@map("users") to map to users table

- [ ] **Task 3: Define events table schema in schema.prisma** (AC: 3, 4)
  - [ ] Define Event model with id (String @id @default(uuid()) @db.Uuid)
  - [ ] Add userId (String @map("user_id") @db.Uuid) with relation to User
  - [ ] Add eventType (String @default("BIRTHDAY") @map("event_type") @db.VarChar(50))
  - [ ] Add status enum: PENDING, PROCESSING, COMPLETED, FAILED
  - [ ] Add targetTimestampUTC (DateTime @map("target_timestamp_utc") @db.Timestamptz)
  - [ ] Add targetTimestampLocal (DateTime @map("target_timestamp_local") @db.Timestamptz)
  - [ ] Add targetTimezone (String @map("target_timezone") @db.VarChar(100))
  - [ ] Add executedAt (DateTime? @map("executed_at") @db.Timestamptz)
  - [ ] Add failureReason (String? @map("failure_reason") @db.Text)
  - [ ] Add retryCount (Int @default(0) @map("retry_count"))
  - [ ] Add version (Int @default(1))
  - [ ] Add idempotencyKey (String @unique @map("idempotency_key") @db.VarChar(255))
  - [ ] Add deliveryPayload (Json @map("delivery_payload") @db.JsonB)
  - [ ] Add createdAt (DateTime @default(now()) @map("created_at") @db.Timestamptz)
  - [ ] Add updatedAt (DateTime @updatedAt @map("updated_at") @db.Timestamptz)
  - [ ] Add @@map("events") to map to events table
  - [ ] Add relation to User (user field with @relation)

- [ ] **Task 4: Add indexes to events table** (AC: 4)
  - [ ] Add @@index([userId], map: "idx_events_user_id")
  - [ ] Add @@index([status], map: "idx_events_status")
  - [ ] Add @@index([targetTimestampUTC], map: "idx_events_target_timestamp_utc")
  - [ ] Add @@index([targetTimestampUTC, status], map: "idx_events_scheduler_query")
  - [ ] Add @@index([userId, status], map: "idx_events_user_pending")

- [ ] **Task 5: Create and apply initial migration** (AC: 5)
  - [ ] Ensure Docker environment is running: `docker-compose up -d`
  - [ ] Create migration: `npx prisma migrate dev --name init`
  - [ ] Verify migration SQL file created in prisma/migrations/
  - [ ] Verify migration applied successfully to database
  - [ ] Check database for users and events tables using psql or database client

- [ ] **Task 6: Generate Prisma Client with TypeScript types** (AC: 6)
  - [ ] Run `npx prisma generate` to generate client
  - [ ] Verify node_modules/.prisma/client directory created
  - [ ] Verify TypeScript types generated for User and Event models
  - [ ] Test importing PrismaClient in TypeScript file
  - [ ] Verify no TypeScript errors with strict mode

- [ ] **Task 7: Create database seeding script** (AC: 7)
  - [ ] Create prisma/seed.ts file
  - [ ] Import PrismaClient and ts-node for TypeScript execution
  - [ ] Create sample users with valid data (firstName, lastName, dateOfBirth, timezone)
  - [ ] Create sample events for the users
  - [ ] Add "prisma": { "seed": "ts-node prisma/seed.ts" } to package.json
  - [ ] Test seeding: `npx prisma db seed`
  - [ ] Verify data inserted into database

- [ ] **Task 8: Create database reset script** (AC: 7)
  - [ ] Create scripts/db-reset.sh script
  - [ ] Script should run: `npx prisma migrate reset --force`
  - [ ] Make script executable: `chmod +x scripts/db-reset.sh`
  - [ ] Add npm script: `"db:reset": "prisma migrate reset"`
  - [ ] Test reset script and verify database is cleared and reseeded

- [ ] **Task 9: Update package.json with Prisma scripts** (AC: 5, 6, 7)
  - [ ] Add "prisma:generate": "prisma generate"
  - [ ] Add "prisma:migrate": "prisma migrate dev"
  - [ ] Add "prisma:studio": "prisma studio" (database GUI)
  - [ ] Add "db:seed": "prisma db seed"
  - [ ] Add "db:reset": "prisma migrate reset"

- [ ] **Task 10: Update README with Prisma setup instructions** (AC: 1, 5, 6, 7)
  - [ ] Add "Database Schema & Migrations" section
  - [ ] Document how to run migrations: `npm run prisma:migrate`
  - [ ] Document how to generate client: `npm run prisma:generate`
  - [ ] Document how to seed database: `npm run db:seed`
  - [ ] Document how to reset database: `npm run db:reset`
  - [ ] Document how to view database: `npm run prisma:studio`

---

## Dev Notes

### Previous Story Insights

**Source:** [docs/stories/1.2.docker-environment.md](1.2.docker-environment.md)

- Docker environment with PostgreSQL 16.1 is running and accessible on localhost:5432
- Database name: `bday_db`, user: `bday_user`, password: `local_dev_password`
- PostgreSQL uuid-ossp extension already installed via init.sql
- DATABASE_URL already configured in .env file
- LocalStack configured for AWS service simulation (SQS, EventBridge, SNS)

### Prisma Configuration

**Source:** [docs/architecture/tech-stack.md#technology-stack-table](../architecture/tech-stack.md)

**Required Version:**
- **Prisma**: 5.9.1 (ORM)
- **@prisma/client**: 5.9.1 (Generated client library)

**Why Prisma:**
- Better TypeScript integration than TypeORM
- Cleaner API and migration management
- Supports PostgreSQL advanced features (FOR UPDATE SKIP LOCKED)
- Type-safe database access with auto-generated types

**Installation Commands:**
```bash
npm install -D prisma@5.9.1
npm install @prisma/client@5.9.1
npx prisma init
```

### Database Schema Details

**Source:** [docs/architecture/database-schema.md](../architecture/database-schema.md)

**Users Table:**
```prisma
model User {
  id           String   @id @default(uuid()) @db.Uuid
  firstName    String   @map("first_name") @db.VarChar(100)
  lastName     String   @map("last_name") @db.VarChar(100)
  dateOfBirth  DateTime @map("date_of_birth") @db.Date
  timezone     String   @db.VarChar(100)
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz
  events       Event[]

  @@map("users")
}
```

**Events Table:**
```prisma
model Event {
  id                   String      @id @default(uuid()) @db.Uuid
  userId               String      @map("user_id") @db.Uuid
  eventType            String      @default("BIRTHDAY") @map("event_type") @db.VarChar(50)
  status               EventStatus
  targetTimestampUTC   DateTime    @map("target_timestamp_utc") @db.Timestamptz
  targetTimestampLocal DateTime    @map("target_timestamp_local") @db.Timestamptz
  targetTimezone       String      @map("target_timezone") @db.VarChar(100)
  executedAt           DateTime?   @map("executed_at") @db.Timestamptz
  failureReason        String?     @map("failure_reason") @db.Text
  retryCount           Int         @default(0) @map("retry_count")
  version              Int         @default(1)
  idempotencyKey       String      @unique @map("idempotency_key") @db.VarChar(255)
  deliveryPayload      Json        @map("delivery_payload") @db.JsonB
  createdAt            DateTime    @default(now()) @map("created_at") @db.Timestamptz
  updatedAt            DateTime    @updatedAt @map("updated_at") @db.Timestamptz
  user                 User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "idx_events_user_id")
  @@index([status], map: "idx_events_status")
  @@index([targetTimestampUTC], map: "idx_events_target_timestamp_utc")
  @@index([targetTimestampUTC, status], map: "idx_events_scheduler_query")
  @@index([userId, status], map: "idx_events_user_pending")
  @@map("events")
}

enum EventStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}
```

**Key Schema Features:**
- **UUID Primary Keys**: Using `uuid_generate_v4()` function (already installed in Story 1.2)
- **Snake Case Mapping**: Prisma camelCase fields map to PostgreSQL snake_case columns via `@map()`
- **Timestamptz**: All timestamps use PostgreSQL TIMESTAMPTZ for timezone awareness
- **JSONB**: `deliveryPayload` uses JSONB for efficient JSON storage and querying
- **Cascade Delete**: Events are deleted when user is deleted via `onDelete: Cascade`
- **Optimistic Locking**: `version` field for concurrency control
- **Idempotency Key**: Unique constraint for preventing duplicate event deliveries

**Critical Indexes:**
- `idx_events_scheduler_query`: Composite index on (targetTimestampUTC, status) - **most critical for scheduler performance**
- `idx_events_user_pending`: Composite index on (userId, status) - for finding user's pending events during updates
- Individual indexes on userId, status, targetTimestampUTC for various queries

### Data Models

**Source:** [docs/architecture/data-models.md](../architecture/data-models.md)

**User Entity:**
- `id`: UUID primary key
- `firstName`: Required, 1-100 characters
- `lastName`: Required, 1-100 characters
- `dateOfBirth`: Valid date in the past (YYYY-MM-DD format)
- `timezone`: Valid IANA timezone identifier (e.g., "America/New_York")
- `createdAt`: Timestamp (UTC)
- `updatedAt`: Timestamp (UTC)

**Business Invariants for User:**
- First name and last name cannot be empty
- Date of birth must be in the past
- Timezone must be valid IANA timezone

**Event Entity:**
- `id`: UUID primary key
- `userId`: Foreign key to User
- `eventType`: "BIRTHDAY" (hardcoded for Phase 1, extensible for Phase 2+)
- `status`: PENDING | PROCESSING | COMPLETED | FAILED
- `targetTimestampUTC`: When event should execute (UTC)
- `targetTimestampLocal`: When event should execute (local time, for display)
- `targetTimezone`: Timezone used for calculation
- `executedAt`: Actual execution timestamp (null until executed)
- `failureReason`: Error message if status is FAILED
- `retryCount`: Number of execution attempts (0-3)
- `version`: Optimistic locking version
- `idempotencyKey`: Unique key for external API idempotency
- `deliveryPayload`: JSON payload to deliver
- `createdAt`: Timestamp (UTC)
- `updatedAt`: Timestamp (UTC)

**Business Invariants for Event:**
- Status transitions: PENDING → PROCESSING → (COMPLETED | FAILED)
- Cannot transition from COMPLETED/FAILED back to PENDING
- Retry count cannot exceed 3
- Version must increment on every update

### Project Structure

**Source:** [docs/architecture/source-tree.md](../architecture/source-tree.md#project-structure)

**Prisma Files Location:**
```
bday/
├── prisma/
│   ├── schema.prisma                   # Prisma schema definition
│   ├── migrations/                     # Database migration files
│   │   └── 20250118_init/
│   │       └── migration.sql
│   └── seed.ts                         # Database seeding script
```

**Expected File Structure After Story Completion:**
- `prisma/schema.prisma` - Complete schema with User, Event models, and indexes
- `prisma/migrations/YYYYMMDD_init/migration.sql` - Initial migration SQL
- `prisma/seed.ts` - TypeScript seed script with sample data
- `scripts/db-reset.sh` - Shell script for database reset
- `node_modules/.prisma/client/` - Auto-generated Prisma Client
- `package.json` - Updated with Prisma scripts

### Database Connection

**Source:** [docs/stories/1.2.docker-environment.md](1.2.docker-environment.md)

**DATABASE_URL Format:**
```
postgresql://bday_user:local_dev_password@localhost:5432/bday_db
```

This is already configured in `.env` file from Story 1.2.

**Connection Notes:**
- PostgreSQL 16.1 running in Docker
- Port: 5432
- Database: bday_db
- User: bday_user
- Password: local_dev_password (local development only)

### Coding Standards

**Source:** [docs/architecture/coding-standards.md](../architecture/coding-standards.md)

**TypeScript Standards:**
- TypeScript 5.3.3 with strict mode enabled
- No `any` types allowed
- Explicit typing for all function signatures
- Use async/await for asynchronous operations

**File Naming:**
- Schema file: `schema.prisma`
- Seed script: `seed.ts`
- Migration naming: Prisma auto-generates with timestamp

**Prisma Best Practices:**
- Use `@map()` directive to map camelCase to snake_case
- Use `@@map()` directive to map model names to table names
- Use `@db` directives for PostgreSQL-specific types (Uuid, Timestamptz, JsonB, VarChar, Text, Date)
- Define enums for status fields
- Use relations with `@relation` directive and `onDelete: Cascade`

### Testing

**Source:** [docs/architecture/test-strategy.md](../architecture/test-strategy.md)

**Testing Requirements for This Story:**

**No Unit/Integration Tests Required for This Story** - This is infrastructure setup

**Manual Testing Required:**
1. Verify Prisma schema compiles without errors
2. Verify migration creates tables correctly
3. Verify Prisma Client generates without TypeScript errors
4. Verify seed script populates database
5. Verify database reset script works

**Manual Testing Commands:**
```bash
# Test Prisma schema validation
npx prisma validate

# Test migration creation and application
npx prisma migrate dev --name init

# Test Prisma Client generation
npx prisma generate

# Test database seeding
npx prisma db seed

# Test database reset
npx prisma migrate reset

# View database in GUI
npx prisma studio
```

**Future Testing (Story 1.7):**
- Integration tests will use Testcontainers 10.5.0 with real PostgreSQL
- Repository implementations will be tested with Prisma Client
- Tests will verify schema constraints, indexes, and cascading deletes

### Environment Configuration

**Source:** [docs/architecture/tech-stack.md](../architecture/tech-stack.md)

**dotenv**: 16.4.1 for local environment variables

The `.env` file already contains DATABASE_URL from Story 1.2:
```
DATABASE_URL=postgresql://bday_user:local_dev_password@localhost:5432/bday_db
```

### Migration Strategy

**Source:** [docs/architecture/database-schema.md](../architecture/database-schema.md)

**Local Development Migrations:**
- Use `npx prisma migrate dev` for local development
- Creates migration files in `prisma/migrations/`
- Auto-applies migration to database
- Auto-generates Prisma Client
- Interactive prompts for migration naming

**Seeding Strategy:**
- Use `prisma/seed.ts` with TypeScript
- Configure in package.json: `"prisma": { "seed": "ts-node prisma/seed.ts" }`
- Seed runs automatically after `migrate reset` and `migrate dev` (first time)

### Key Implementation Notes

1. **UUID Extension Already Installed**: The `uuid-ossp` extension was installed in Story 1.2 via `docker/postgres/init.sql`, so Prisma's `@default(uuid())` will work immediately.

2. **Schema Mapping**: Use `@map()` for all field names and `@@map()` for table names to maintain PostgreSQL snake_case convention while using TypeScript camelCase.

3. **Enum Definition**: Define `EventStatus` enum in Prisma schema (not PostgreSQL enum) for better Prisma Client type safety.

4. **Timestamp Types**: Use `@db.Timestamptz` for all DateTime fields to ensure timezone-aware timestamps.

5. **JSONB Usage**: Use `Json` type with `@db.JsonB` for `deliveryPayload` to leverage PostgreSQL's efficient JSON storage.

6. **Index Naming**: Use `map:` parameter for all indexes to match naming convention from architecture (e.g., `idx_events_scheduler_query`).

7. **Cascade Delete**: Configure `onDelete: Cascade` on the Event → User relation to automatically delete events when user is deleted.

8. **Seed Script**: Use TypeScript (ts-node) for seed script to maintain type safety and consistency with application code.

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story creation from Epic 1 | Scrum Master Agent (Bob) |
| 2025-10-20 | 1.1 | Removed CI/CD references for local-only development | Scrum Master Agent (Bob) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

### Debug Log References

### Completion Notes

### File List

**Created:**
**Modified:**
**Deleted:**

---

## QA Results

*This section will be populated by the QA agent after implementation review.*
