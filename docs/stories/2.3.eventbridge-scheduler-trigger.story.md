# Story 2.3: EventBridge Scheduler Trigger

---

## Status

Approved

---

## Story

**As a** developer,
**I want** EventBridge to trigger the scheduler Lambda every minute,
**so that** the system continuously polls for ready events.

---

## Acceptance Criteria

1. EventBridge rule configured in LocalStack to trigger every 1 minute
2. Lambda handler created in `src/adapters/primary/lambda/schedulerHandler.ts`
3. Handler wraps ClaimReadyEventsUseCase with dependency injection
4. Handler logs start/end of each execution with timestamp
5. Handler catches and logs errors without crashing
6. Handler reports metrics: events found, events claimed, errors
7. LocalStack configuration tested with manual EventBridge trigger
8. Documentation added for running scheduler locally

---

## Tasks / Subtasks

- [ ] **Task 1: Create Scheduler Lambda Handler** (AC: 2, 3)
  - [ ] Create `src/adapters/primary/lambda/schedulerHandler.ts`
  - [ ] Import `ClaimReadyEventsUseCase` from `src/modules/event-scheduling/application/use-cases/`
  - [ ] Import `PrismaEventRepository` from `src/modules/event-scheduling/adapters/persistence/`
  - [ ] Import `SQSAdapter` from `src/adapters/secondary/messaging/` (for sending claimed events)
  - [ ] Import Pino logger from `src/shared/logger.ts`
  - [ ] Define Lambda handler function signature: `handler(event: ScheduledEvent): Promise<void>`
  - [ ] Implement dependency injection:
    - Create PrismaClient instance (singleton)
    - Create PrismaEventRepository with PrismaClient
    - Create SQSAdapter with AWS SDK SQSClient and queue URL from env var
    - Create ClaimReadyEventsUseCase with repository dependency
  - [ ] Implement handler logic:
    - Log execution start with timestamp and EventBridge rule name
    - Call `claimReadyEventsUseCase.execute()` to claim ready events
    - For each claimed event, send to SQS queue using SQSAdapter
    - Log execution end with metrics (events claimed, events sent to queue, duration)
  - [ ] Add JSDoc explaining handler purpose and dependencies
  - [ ] Reference: [Source: architecture/source-tree.md#Lambda-Handlers]

- [ ] **Task 2: Add Error Handling and Logging** (AC: 4, 5, 6)
  - [ ] Wrap handler logic in try-catch block
  - [ ] Log start of execution with structured context:
    - EventBridge rule name (from event.resources)
    - Execution time (event.time)
    - Request ID (from Lambda context)
  - [ ] Log end of execution with metrics:
    - Number of events claimed
    - Number of events sent to SQS
    - Execution duration (milliseconds)
  - [ ] Catch all errors and log with structured context:
    - Error message
    - Stack trace
    - Request ID
  - [ ] Return success even if errors occur (prevent Lambda retries for EventBridge triggers)
  - [ ] Use Pino logger exclusively (no console.log)
  - [ ] Reference: [Source: architecture/coding-standards.md#Logging-Requirements]

- [ ] **Task 3: Configure EventBridge Rule in LocalStack** (AC: 1, 7)
  - [ ] Verify EventBridge rule exists in `docker/localstack/init-aws.sh` (already created in previous story)
  - [ ] Rule configuration: `rate(1 minute)` cron expression
  - [ ] Rule name: `event-scheduler-rule` (generic, event-type agnostic)
  - [ ] Add Lambda target to existing EventBridge rule:
    - Update init-aws.sh to add Lambda function as target
    - Use `awslocal events put-targets --rule event-scheduler-rule --targets ...`
  - [ ] Test rule and Lambda integration:
    - Start LocalStack via Docker Compose
    - Verify rule exists: `awslocal events list-rules`
    - Verify Lambda target: `awslocal events list-targets-by-rule --rule event-scheduler-rule`
    - Manually trigger Lambda via EventBridge test event
  - [ ] Verify Lambda receives EventBridge event payload
  - [ ] Reference: [Source: architecture/tech-stack.md#EventBridge]

- [ ] **Task 4: Add Environment Configuration** (AC: 2)
  - [ ] Update `.env.example` with required environment variables:
    - `SQS_QUEUE_URL` (already exists from Story 2.2)
    - `AWS_ENDPOINT_URL` (already exists from Story 2.2)
    - `DATABASE_URL` (already exists from Story 1.7)
  - [ ] Verify all dependencies use environment variables (no hardcoded values)
  - [ ] Document environment variable purpose in comments

- [ ] **Task 5: Create Lambda Deployment Configuration** (AC: 2, 7)
  - [ ] Create Lambda function configuration for LocalStack
  - [ ] Update `docker/localstack/init-aws.sh` to create Lambda function:
    - Function name: `event-scheduler` (generic, handles all event types)
    - Runtime: `nodejs20.x`
    - Handler: `dist/adapters/primary/lambda/schedulerHandler.handler`
    - Timeout: 60 seconds (allow time for claiming + sending to queue)
    - Memory: 512 MB
    - Environment variables: DATABASE_URL, SQS_QUEUE_URL, AWS_ENDPOINT_URL
  - [ ] Package handler code for Lambda deployment (use esbuild or zip)
  - [ ] Test Lambda function in LocalStack:
    - Deploy function
    - Invoke manually: `awslocal lambda invoke --function-name event-scheduler output.json`
    - Verify logs in CloudWatch (LocalStack)
  - [ ] Reference: [Source: architecture/tech-stack.md#Lambda]

- [ ] **Task 6: Write Unit Tests for Scheduler Handler** (AC: 3, 4, 5, 6)
  - [ ] Create `src/adapters/primary/lambda/schedulerHandler.test.ts`
  - [ ] Mock dependencies: ClaimReadyEventsUseCase, SQSAdapter, PrismaClient, Logger
  - [ ] Test: should claim events and send to SQS queue
    - Arrange: Mock use case to return 3 claimed events
    - Arrange: Mock SQSAdapter to return successful message IDs
    - Act: Call handler with EventBridge event payload
    - Assert: ClaimReadyEventsUseCase.execute() called once
    - Assert: SQSAdapter.sendMessage() called 3 times (once per event)
    - Assert: Logger logs start, end, and metrics
  - [ ] Test: should handle no events ready
    - Arrange: Mock use case to return empty array
    - Act: Call handler
    - Assert: SQSAdapter not called
    - Assert: Logger logs "0 events claimed"
  - [ ] Test: should log errors and not crash
    - Arrange: Mock use case to throw error
    - Act: Call handler
    - Assert: Logger.error() called with error details
    - Assert: Handler completes without throwing (returns void)
  - [ ] Test: should log execution metrics
    - Assert: Logger logs duration, events claimed, events sent to queue
  - [ ] Follow AAA pattern (Arrange, Act, Assert)
  - [ ] Achieve 100% code coverage for scheduler handler
  - [ ] Reference: [Source: architecture/test-strategy.md#Unit-Tests]

- [ ] **Task 7: Write Integration Tests for Scheduler Handler** (AC: 7)
  - [ ] Create `src/adapters/primary/lambda/schedulerHandler.integration.test.ts`
  - [ ] Use real PrismaClient with Testcontainers PostgreSQL
  - [ ] Use real SQSAdapter connected to LocalStack SQS
  - [ ] Setup: Create test database with pending events (targetTimestampUTC in past)
  - [ ] Test: should claim events and send to LocalStack SQS queue
    - Arrange: Create 5 pending events in database (due now)
    - Act: Call handler
    - Assert: Events in database have status PROCESSING
    - Assert: 5 messages in SQS queue (verify using ReceiveMessage)
    - Assert: Each SQS message contains correct eventId, eventType, idempotencyKey
  - [ ] Test: should not send future events to queue
    - Arrange: Create 2 pending events (targetTimestampUTC in future)
    - Act: Call handler
    - Assert: Events still have status PENDING
    - Assert: 0 messages in SQS queue
  - [ ] Teardown: Clean up database and purge SQS queue
  - [ ] Reference: [Source: architecture/test-strategy.md#Integration-Tests]

- [ ] **Task 8: Add Local Development Documentation** (AC: 8)
  - [ ] Create or update `docs/local-development.md`
  - [ ] Document how to run scheduler locally:
    - Start Docker Compose (PostgreSQL + LocalStack)
    - Deploy Lambda to LocalStack
    - Manually trigger scheduler: `awslocal lambda invoke --function-name bday-scheduler output.json`
    - View logs: `awslocal logs tail /aws/lambda/bday-scheduler --follow`
  - [ ] Document how to test EventBridge trigger:
    - Create test EventBridge event JSON
    - Put event to EventBridge: `awslocal events put-events --entries file://test-event.json`
    - Verify Lambda invocation in logs
  - [ ] Document how to verify events in SQS queue:
    - `awslocal sqs receive-message --queue-url <queue-url> --max-number-of-messages 10`
  - [ ] Add troubleshooting section for common issues

---

## Dev Notes

### Previous Story Insights

**From Story 2.1 (ClaimReadyEventsUseCase):**
- `ClaimReadyEventsUseCase` class available at `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.ts`
- Use case has single method: `execute(): Promise<Event[]>`
- Use case returns array of claimed Event entities (status changed to PROCESSING)
- Use case uses Pino logger for structured logging
- Use case depends on `IEventRepository` (injected via constructor)
- Implementation uses `FOR UPDATE SKIP LOCKED` for atomic claiming
- Limits to 100 events per execution to prevent overwhelming system
- All tests passing (unit + integration)

**From Story 2.2 (SQS Queue Integration):**
- `SQSAdapter` class available at `src/adapters/secondary/messaging/SQSAdapter.ts`
- Implements `ISQSClient` port interface
- Has method: `sendMessage(payload: SQSMessagePayload): Promise<string>`
- Validates payloads against `SQSMessagePayloadSchema` from `src/shared/validation/schemas.ts`
- Configured for LocalStack SQS (endpoint: `http://localhost:4566`)
- Queue URL available in environment variable: `SQS_QUEUE_URL`
- Returns SQS MessageId on success
- Throws `InfrastructureError` on SQS failures
- All tests passing (unit + integration)

**From Story 1.11c (Structured Logging):**
- Pino logger available at `src/shared/logger.ts`
- Use `logger.info()`, `logger.error()`, `logger.warn()` for structured logging
- All logs must include structured context fields (eventId, duration, error, etc.)
- Never use `console.log` or `console.error` (ESLint enforces this)
- Log errors with full error object and stack trace

### Architecture Context

**Lambda Handlers:**

Lambda handlers are **primary adapters** (inbound/driving adapters) that receive events from AWS services (EventBridge, SQS, API Gateway) and invoke application use cases.

**Location:**
```
src/adapters/primary/lambda/
├── schedulerHandler.ts         # NEW - This story (EventBridge → Scheduler)
├── schedulerHandler.test.ts    # NEW - This story (Unit tests)
├── schedulerHandler.integration.test.ts # NEW - This story (Integration tests)
├── api-handler.ts              # Future - API Gateway → Fastify
└── worker-handler.ts           # Future - SQS → Executor
```

[Source: architecture/source-tree.md#Lambda-Handlers]

**Handler Responsibilities:**

1. **Parse incoming events** (EventBridge, SQS, API Gateway)
2. **Instantiate dependencies** (repositories, adapters, use cases)
3. **Invoke use cases** with proper dependency injection
4. **Transform results** into AWS-expected response formats
5. **Log execution** (start, end, metrics, errors)
6. **Handle errors gracefully** (log and return, don't crash)

[Source: architecture/design-patterns.md#Hexagonal-Architecture]

**Dependency Injection Pattern:**

Lambda handlers are responsible for wiring up dependencies:

```typescript
// Example DI in Lambda handler
import { PrismaClient } from '@prisma/client';
import { PrismaEventRepository } from '../../../modules/event-scheduling/adapters/persistence/PrismaEventRepository';
import { ClaimReadyEventsUseCase } from '../../../modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase';
import { SQSAdapter } from '../../secondary/messaging/SQSAdapter';
import { SQSClient } from '@aws-sdk/client-sqs';
import { logger } from '../../../shared/logger';

// Singleton Prisma client (reused across Lambda invocations)
let prismaClient: PrismaClient | null = null;

function getPrismaClient(): PrismaClient {
  if (!prismaClient) {
    prismaClient = new PrismaClient();
  }
  return prismaClient;
}

export async function handler(event: ScheduledEvent): Promise<void> {
  const prisma = getPrismaClient();

  // Repository adapter (secondary/outbound)
  const eventRepository = new PrismaEventRepository(prisma);

  // SQS adapter (secondary/outbound)
  const sqsClient = new SQSClient({
    region: 'us-east-1',
    endpoint: process.env.AWS_ENDPOINT_URL || 'http://localhost:4566',
    credentials: { accessKeyId: 'test', secretAccessKey: 'test' }
  });
  const sqsAdapter = new SQSAdapter(sqsClient, process.env.SQS_QUEUE_URL!);

  // Use case (application layer)
  const claimReadyEventsUseCase = new ClaimReadyEventsUseCase(eventRepository);

  // Execute use case and send events to queue
  const claimedEvents = await claimReadyEventsUseCase.execute();

  for (const event of claimedEvents) {
    const payload = {
      eventId: event.id,
      eventType: event.eventType,
      idempotencyKey: event.idempotencyKey.value,
      metadata: {
        userId: event.userId,
        targetTimestampUTC: event.targetTimestampUTC.toISO(),
        deliveryPayload: event.deliveryPayload
      }
    };

    await sqsAdapter.sendMessage(payload);
  }
}
```

[Source: architecture/design-patterns.md#Dependency-Injection]

### EventBridge Scheduled Events

**Event Payload Structure:**

EventBridge sends a `ScheduledEvent` payload to Lambda when triggered by a cron rule:

```typescript
interface ScheduledEvent {
  version: string;                // "0"
  id: string;                     // Unique event ID
  'detail-type': string;          // "Scheduled Event"
  source: string;                 // "aws.events"
  account: string;                // AWS account ID
  time: string;                   // ISO 8601 timestamp
  region: string;                 // "us-east-1"
  resources: string[];            // [EventBridge rule ARN]
  detail: Record<string, unknown>; // Empty object for scheduled events
}
```

**Cron Expression:**

EventBridge supports two types of scheduling expressions:

1. **Rate expressions:** `rate(1 minute)`, `rate(5 minutes)`, `rate(1 hour)`
2. **Cron expressions:** `cron(0/1 * * * ? *)` (every minute)

For this story, use **`rate(1 minute)`** for simplicity.

[Source: architecture/tech-stack.md#EventBridge]

**LocalStack EventBridge Configuration:**

EventBridge rule already exists in LocalStack init script (created in earlier story). Task is to add Lambda function as target:

```bash
#!/bin/bash
# docker/localstack/init-aws.sh

# EventBridge rule already exists (created in earlier story)
# Rule name: event-scheduler-rule (generic, event-type agnostic)
# Schedule: rate(1 minute)

# Add Lambda function as target for EventBridge rule
awslocal events put-targets \
  --rule event-scheduler-rule \
  --targets "Id"="1","Arn"="arn:aws:lambda:us-east-1:000000000000:function:event-scheduler"
```

[Source: architecture/tech-stack.md#LocalStack]

### File Locations

**Handler File:**
```
src/adapters/primary/lambda/schedulerHandler.ts
```

**Test Files:**
```
src/adapters/primary/lambda/schedulerHandler.test.ts              # Unit tests
src/adapters/primary/lambda/schedulerHandler.integration.test.ts  # Integration tests
```

**LocalStack Configuration:**
```
docker/localstack/init-aws.sh    # Add EventBridge rule + Lambda function
```

**Documentation:**
```
docs/local-development.md        # Add scheduler testing instructions
```

[Source: architecture/source-tree.md#Lambda-Handlers]

### Lambda Configuration

**Function Configuration:**

| Setting | Value | Reason |
|---------|-------|--------|
| Function Name | `event-scheduler` | Generic name (handles all event types: birthday, anniversary, reminder, etc.) |
| Runtime | `nodejs20.x` | Node.js 20 LTS (matches local development) |
| Handler | `dist/adapters/primary/lambda/schedulerHandler.handler` | Compiled TypeScript output |
| Timeout | 60 seconds | Allow time for claiming events + sending to SQS |
| Memory | 512 MB | Sufficient for database + SQS operations |
| Environment | DATABASE_URL, SQS_QUEUE_URL, AWS_ENDPOINT_URL | Required for Prisma + SQS |

[Source: architecture/tech-stack.md#Lambda]

**Lambda Deployment (LocalStack):**

```bash
#!/bin/bash
# docker/localstack/init-aws.sh

# Create Lambda function (event-type agnostic scheduler)
awslocal lambda create-function \
  --function-name event-scheduler \
  --runtime nodejs20.x \
  --handler dist/adapters/primary/lambda/schedulerHandler.handler \
  --zip-file fileb://lambda-package.zip \
  --role arn:aws:iam::000000000000:role/lambda-role \
  --timeout 60 \
  --memory-size 512 \
  --environment Variables="{DATABASE_URL=$DATABASE_URL,SQS_QUEUE_URL=$SQS_QUEUE_URL,AWS_ENDPOINT_URL=http://localhost:4566}"
```

**Packaging Lambda Code:**

Lambda requires deployment package (zip file) containing:
- Compiled JavaScript (from TypeScript)
- node_modules (dependencies)

Use `esbuild` to bundle TypeScript into single JavaScript file (recommended for Lambda):

```bash
# Build Lambda package
npx esbuild src/adapters/primary/lambda/schedulerHandler.ts \
  --bundle \
  --platform=node \
  --target=node20 \
  --outfile=dist/schedulerHandler.js \
  --external:@prisma/client \
  --external:pg-native
```

[Source: architecture/tech-stack.md#Lambda-Bundler]

### Import Rules for Lambda Handlers

Lambda handlers are **primary adapters** (inbound layer) and can import:

- ✅ **Application use cases** (e.g., `ClaimReadyEventsUseCase`)
- ✅ **Secondary adapters** (e.g., `PrismaEventRepository`, `SQSAdapter`)
- ✅ **Port interfaces** (e.g., `IEventRepository`, `ISQSClient`)
- ✅ **Shared utilities** (logger, config)
- ✅ **External frameworks** (AWS SDK, Prisma Client)
- ❌ **Cannot import:** Domain entities directly (use through use cases)

[Source: architecture/source-tree.md#Import-Rules]

### Error Handling Strategy

**Lambda Error Handling for EventBridge Triggers:**

EventBridge triggers are **asynchronous** and don't retry automatically like SQS. Handler should:

1. **Catch all errors** (don't let Lambda crash)
2. **Log errors with full context** (error message, stack, request ID)
3. **Return success** (don't throw, prevent Lambda retry loop)
4. **Let next scheduled execution handle missed events** (scheduler is idempotent)

```typescript
export async function handler(event: ScheduledEvent): Promise<void> {
  try {
    // ... execute use case logic
    logger.info({ msg: 'Scheduler execution completed', eventsClaimed: claimedEvents.length });
  } catch (error) {
    logger.error({
      msg: 'Scheduler execution failed',
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      eventBridgeRuleName: event.resources[0]
    });

    // DO NOT rethrow - let next scheduled execution handle it
    // EventBridge will invoke again in 1 minute
  }
}
```

**Why not rethrow errors?**

- EventBridge doesn't have built-in retry logic
- Rethrowing errors causes Lambda to retry (3 times by default)
- Retries happen immediately, wasting Lambda invocations
- Scheduler runs every minute anyway, so next execution will catch missed events

[Source: architecture/error-handling.md#Lambda-Error-Handling]

### Coding Standards

**TypeScript Requirements:**
- Strict mode enabled (no `any` types)
- Explicit accessibility modifiers (`public`, `private`, `protected`)
- Use async/await (no callbacks or raw promises)
- Explicit return types for all functions

**Logging Requirements:**
- Use Pino logger exclusively (`src/shared/logger.ts`)
- Structure logs with context fields (eventId, duration, error, requestId)
- Log levels: ERROR (failures), INFO (success/metrics), DEBUG (detailed flow)
- Never use `console.log` or `console.error` (ESLint will fail)

**Error Handling:**
- Never swallow errors silently
- Always log and handle errors explicitly
- Use custom error classes: `ValidationError`, `InfrastructureError`
- Catch AWS-specific errors and rethrow as application-level errors

**Dependency Injection:**
- Inject all dependencies via constructor (repositories, adapters, logger)
- Use interface types for dependencies (IEventRepository, ISQSClient)
- Enable easy testing with mock implementations

[Source: architecture/coding-standards.md#Core-Standards]

### Testing

**Unit Test Requirements:**

- **Test file location:** `src/adapters/primary/lambda/schedulerHandler.test.ts`
- **Testing framework:** Jest
- **Mocking:** Mock all dependencies (ClaimReadyEventsUseCase, SQSAdapter, PrismaClient, Logger)
- **Pattern:** AAA (Arrange, Act, Assert)
- **Coverage goal:** 100% code coverage for scheduler handler
- **Test scenarios:**
  - Happy path: events claimed → sent to SQS → metrics logged
  - No events ready: empty array → no SQS calls → log "0 events claimed"
  - Use case error: error logged → handler completes without throwing
  - SQS error: error logged → handler completes without throwing
  - Logging: verify logger.info and logger.error called with correct context

**Integration Test Requirements:**

- **Test file location:** `src/adapters/primary/lambda/schedulerHandler.integration.test.ts`
- **Infrastructure:** Real PostgreSQL (Testcontainers) + Real LocalStack SQS
- **Setup:** Create test database with pending events (targetTimestampUTC in past)
- **Test scenarios:**
  - End-to-end: pending events → claimed → sent to SQS → verify in queue
  - Future events: events with targetTimestampUTC in future → not claimed → not sent to queue
  - Concurrent executions: verify atomic claiming prevents duplicates
- **Cleanup:** Clean up database and purge SQS queue after tests

**Test Naming Convention:**
- File: `{ClassName}.test.ts` or `{ClassName}.integration.test.ts`
- Describe: Use function/handler names
- It: Descriptive test names explaining behavior
  - Good: "should claim events and send to SQS queue"
  - Bad: "test scheduler" or "should work"

[Source: architecture/test-strategy.md#Unit-Tests, architecture/test-strategy.md#Integration-Tests]

### Expected Handler Implementation Skeleton

```typescript
// src/adapters/primary/lambda/schedulerHandler.ts
import { PrismaClient } from '@prisma/client';
import { PrismaEventRepository } from '../../../modules/event-scheduling/adapters/persistence/PrismaEventRepository';
import { ClaimReadyEventsUseCase } from '../../../modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase';
import { SQSAdapter } from '../../secondary/messaging/SQSAdapter';
import { SQSClient } from '@aws-sdk/client-sqs';
import { logger } from '../../../shared/logger';
import { SQSMessagePayload } from '../../../shared/validation/schemas';

/**
 * AWS EventBridge scheduled event payload structure.
 *
 * EventBridge sends this payload when triggered by a cron rule.
 */
interface ScheduledEvent {
  version: string;
  id: string;
  'detail-type': string;
  source: string;
  account: string;
  time: string;
  region: string;
  resources: string[];
  detail: Record<string, unknown>;
}

// Singleton Prisma client (reused across Lambda warm starts)
let prismaClient: PrismaClient | null = null;

function getPrismaClient(): PrismaClient {
  if (!prismaClient) {
    prismaClient = new PrismaClient();
  }
  return prismaClient;
}

/**
 * Scheduler Lambda handler invoked by EventBridge every minute.
 *
 * This handler:
 * 1. Claims ready events from the database (status PENDING, targetTimestampUTC <= now)
 * 2. Sends each claimed event to SQS queue for asynchronous execution
 * 3. Logs metrics (events claimed, events sent to queue, duration)
 * 4. Handles errors gracefully (logs and continues, doesn't crash)
 *
 * @param event - EventBridge scheduled event payload
 * @returns Promise<void> - Always completes successfully (errors logged, not thrown)
 *
 * @see ClaimReadyEventsUseCase for atomic event claiming logic
 * @see SQSAdapter for SQS message sending logic
 * @see docs/stories/2.3.eventbridge-scheduler-trigger.story.md
 */
export async function handler(event: ScheduledEvent): Promise<void> {
  const startTime = Date.now();

  logger.info({
    msg: 'Scheduler Lambda execution started',
    eventBridgeRuleName: event.resources[0],
    eventTime: event.time
  });

  try {
    // Dependency injection
    const prisma = getPrismaClient();
    const eventRepository = new PrismaEventRepository(prisma);
    const claimReadyEventsUseCase = new ClaimReadyEventsUseCase(eventRepository);

    const sqsClient = new SQSClient({
      region: 'us-east-1',
      endpoint: process.env.AWS_ENDPOINT_URL || 'http://localhost:4566',
      credentials: { accessKeyId: 'test', secretAccessKey: 'test' }
    });
    const sqsAdapter = new SQSAdapter(sqsClient, process.env.SQS_QUEUE_URL!);

    // Claim ready events
    const claimedEvents = await claimReadyEventsUseCase.execute();

    // Send claimed events to SQS queue
    let sentCount = 0;
    for (const event of claimedEvents) {
      const payload: SQSMessagePayload = {
        eventId: event.id,
        eventType: event.eventType,
        idempotencyKey: event.idempotencyKey.value,
        metadata: {
          userId: event.userId,
          targetTimestampUTC: event.targetTimestampUTC.toISO(),
          deliveryPayload: event.deliveryPayload
        }
      };

      await sqsAdapter.sendMessage(payload);
      sentCount++;
    }

    const duration = Date.now() - startTime;

    logger.info({
      msg: 'Scheduler Lambda execution completed',
      eventsClaimed: claimedEvents.length,
      eventsSentToQueue: sentCount,
      durationMs: duration
    });
  } catch (error) {
    logger.error({
      msg: 'Scheduler Lambda execution failed',
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      eventBridgeRuleName: event.resources[0]
    });

    // DO NOT rethrow - EventBridge will invoke again in 1 minute
    // Next execution will catch any missed events
  }
}
```

### Dependencies

**Required Imports:**
- `@prisma/client` - Prisma ORM for database access
- `@aws-sdk/client-sqs` - AWS SDK for SQS operations
- `PrismaEventRepository` from `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository`
- `ClaimReadyEventsUseCase` from `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase`
- `SQSAdapter` from `src/adapters/secondary/messaging/SQSAdapter`
- `logger` from `src/shared/logger` (Pino logger singleton)
- `SQSMessagePayload` from `src/shared/validation/schemas` (Zod-derived type)

**Environment Variables:**
- `DATABASE_URL` - PostgreSQL connection string (from Story 1.7)
- `SQS_QUEUE_URL` - SQS queue URL (from Story 2.2)
- `AWS_ENDPOINT_URL` - LocalStack endpoint (from Story 2.2)

**No New Ports Needed:**
- This story does NOT require new port interfaces
- Uses existing `IEventRepository` (Story 1.7) and `ISQSClient` (Story 2.2)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Created story for EventBridge Scheduler Trigger | Bob (Scrum Master) |
| 2025-10-24 | 1.1 | Architecture validation: Updated EventBridge rule name to match existing LocalStack configuration (bday-scheduler-rule) | Bob (Scrum Master) |
| 2025-10-24 | 2.0 | **BREAKING**: Renamed all resources to be event-type agnostic (handles birthday, anniversary, reminder, etc.): `bday-scheduler-rule` → `event-scheduler-rule`, `bday-events-queue` → `events-queue`, `bday-scheduler` Lambda → `event-scheduler`. Updated LocalStack init script, .env.example, and all story references. | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used

(To be filled by Dev Agent)

### Debug Log References

(To be filled by Dev Agent)

### Completion Notes

(To be filled by Dev Agent)

### File List

(To be filled by Dev Agent)

---

## QA Results

(To be filled by QA Agent)
