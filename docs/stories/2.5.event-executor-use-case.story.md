# Story 2.5: Event Executor Use Case

---

## Status

Approved

---

## Story

**As a** developer,
**I want** an event executor use case that delivers messages and updates status,
**so that** events transition through the complete lifecycle.

---

## Acceptance Criteria

1. ExecuteEventUseCase created in `src/application/use-cases/ExecuteEventUseCase.ts`
2. Use case retrieves event from repository by ID
3. Use case validates event status is `PROCESSING` before execution
4. Use case calls WebhookClient to deliver message
5. Use case updates event status to `COMPLETED` on success with executedAt timestamp
6. Use case updates event status to `FAILED` on permanent failure with failureReason
7. Use case leaves event in `PROCESSING` on transient failure (SQS will retry)
8. Unit tests verify all status transition scenarios

---

## Tasks / Subtasks

- [ ] **Task 1: Create ExecuteEventUseCase** (AC: 1, 2, 3, 4, 5, 6, 7)
  - [ ] Create `src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.ts`
  - [ ] Define constructor accepting `IEventRepository` and `IWebhookClient` dependencies
  - [ ] Create `execute(eventId: string): Promise<void>` method
  - [ ] Implement event retrieval using `eventRepository.findById(eventId)`
  - [ ] Handle event not found scenario (log warning, return early - SQS will retry)
  - [ ] Validate event status is `PROCESSING` (throw error if not, log and return)
  - [ ] Extract webhook payload from `event.deliveryPayload`
  - [ ] Call `webhookClient.deliver(payload, event.idempotencyKey.toString())`
  - [ ] On success: call `event.markCompleted(DateTime.now())` and `eventRepository.update(event)`
  - [ ] On PermanentDeliveryError: call `event.markFailed(error.message)` and `eventRepository.update(event)`
  - [ ] On InfrastructureError: log error, DO NOT update event (leave in PROCESSING for SQS retry)
  - [ ] Add comprehensive JSDoc documentation explaining retry behavior
  - [ ] Reference architecture docs for error handling patterns

- [ ] **Task 2: Write Unit Tests** (AC: 8)
  - [ ] Create `src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.test.ts`
  - [ ] Mock `IEventRepository` and `IWebhookClient` dependencies
  - [ ] Test: successful execution updates event to COMPLETED
  - [ ] Test: permanent failure (PermanentDeliveryError) updates event to FAILED
  - [ ] Test: transient failure (InfrastructureError) leaves event in PROCESSING
  - [ ] Test: event not found logs warning and returns without error
  - [ ] Test: event status not PROCESSING logs error and returns without updating
  - [ ] Test: webhook delivery includes correct payload and idempotency key
  - [ ] Test: executedAt timestamp is set on successful completion
  - [ ] Test: failureReason is set on permanent failure
  - [ ] Follow AAA pattern (Arrange, Act, Assert)
  - [ ] Ensure 100% code coverage for ExecuteEventUseCase (critical path)

---

## Dev Notes

### Previous Story Insights

From **Story 2.4 (Webhook Delivery Adapter)**:
- WebhookAdapter already implements retry logic (3 attempts with exponential backoff: 1s, 2s, 4s)
- Error classification: 4xx → `PermanentDeliveryError` (no retry), 5xx → `InfrastructureError` (with retry)
- X-Idempotency-Key header automatically included in all webhook requests
- WebhookAdapter already validates payload and response using Zod schemas
- IWebhookClient port interface defined: `deliver(payload: WebhookPayload, idempotencyKey: string): Promise<WebhookResponse>`
- PermanentDeliveryError domain error class already created in `src/domain/errors/PermanentDeliveryError.ts`
- Comprehensive logging with Pino already implemented in WebhookAdapter

**Key Lessons:**
- Use IWebhookClient port interface (not concrete WebhookAdapter) for dependency injection
- Trust WebhookAdapter's built-in retry logic - don't retry at use case level
- InfrastructureError means retries exhausted - log and leave event in PROCESSING for SQS to retry
- PermanentDeliveryError means no point retrying - immediately mark event as FAILED

### Architecture Context

#### File Location

**Use Case:**
```
src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.ts
src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.test.ts
```

[Source: architecture/source-tree.md]

#### Use Case Pattern

**Purpose:** Application layer orchestrates business logic by coordinating domain entities, repositories, and external services.

**Structure:**
```typescript
export class ExecuteEventUseCase {
  public constructor(
    private readonly eventRepository: IEventRepository,
    private readonly webhookClient: IWebhookClient
  ) {}

  public async execute(eventId: string): Promise<void> {
    // 1. Retrieve event
    // 2. Validate state
    // 3. Deliver webhook
    // 4. Update event status
  }
}
```

**Key Principles:**
- Use case depends on PORT INTERFACES (IEventRepository, IWebhookClient), NOT concrete implementations
- Use case orchestrates domain entities (Event) and infrastructure services
- Use case handles error classification and determines next steps
- Use case should be thin - delegate to domain entities for business logic

[Source: architecture/design-patterns.md#Hexagonal-Architecture]

#### Event Entity State Machine

**Valid Transitions:**
- PENDING → PROCESSING (scheduler claims event)
- PROCESSING → COMPLETED (executor succeeds)
- PROCESSING → FAILED (executor encounters permanent failure)

**Domain Methods Available:**
- `event.markCompleted(executedAt: DateTime): Event` - Returns new Event in COMPLETED state
- `event.markFailed(reason: string): Event` - Returns new Event in FAILED state

**IMPORTANT:** Event entity is IMMUTABLE. All state change methods return NEW Event instances. Use case must call `eventRepository.update(newEvent)` to persist changes.

[Source: architecture/data-models.md#Event, src/modules/event-scheduling/domain/entities/Event.ts]

#### Error Handling Strategy

**Error Classification:**

| Error Type | Source | Action | Update Event? |
|------------|--------|--------|---------------|
| PermanentDeliveryError | WebhookAdapter (4xx) | Mark event FAILED | Yes |
| InfrastructureError | WebhookAdapter (5xx, timeout) | Log error, return | No (SQS retries) |
| Event not found | EventRepository | Log warning, return | No |
| Invalid event status | Use case validation | Log error, return | No |

**Critical Rule:** ONLY update event to FAILED on PermanentDeliveryError. For InfrastructureError (transient failures), leave event in PROCESSING state so SQS can retry the entire execution.

**Retry Layers:**
1. **WebhookAdapter Level:** 3 retries with exponential backoff (1s, 2s, 4s) - ALREADY IMPLEMENTED
2. **SQS Level:** Visibility timeout allows message to be retried by worker lambda - IMPLEMENTED IN STORY 2.6
3. **Use Case Level:** DO NOT RETRY - trust the layers above

[Source: architecture/error-handling.md#External-API-Errors, architecture/error-handling.md#Error-Handling-Patterns]

#### Idempotency Key Usage

**Format:** `evt-{eventId}-{timestamp}` (generated when event is created)

**Storage:** `event.idempotencyKey` (IdempotencyKey value object)

**Usage in ExecuteEventUseCase:**
```typescript
const response = await this.webhookClient.deliver(
  payload,
  event.idempotencyKey.toString() // Convert value object to string
);
```

**Why Important:** If SQS retries the execution (due to InfrastructureError), the external webhook endpoint receives the SAME idempotency key and can deduplicate the request.

[Source: architecture/data-models.md#IdempotencyKey, docs/stories/2.4.webhook-delivery-adapter.story.md#AC8-9]

#### Logging Standards

**Logger:** Pino 8.17.2 (singleton instance from `src/shared/logger.ts`)

**Required Log Fields:**
- `msg` - Human-readable message
- `eventId` - Event ID for tracing
- `idempotencyKey` - For request correlation
- `status` - Event status after execution
- `error` - Error message (for failures)
- `stack` - Stack trace (for failures)
- `durationMs` - Execution duration

**Log Levels:**
- ERROR: Permanent failures, unexpected errors
- WARN: Event not found, invalid status
- INFO: Successful execution

**Example:**
```typescript
import { logger } from '../../../../shared/logger';

logger.info({
  msg: 'Event execution started',
  eventId: event.id,
  idempotencyKey: event.idempotencyKey.toString(),
  status: event.status
});

logger.error({
  msg: 'Event execution failed permanently',
  eventId: event.id,
  idempotencyKey: event.idempotencyKey.toString(),
  error: error.message,
  stack: error.stack,
  statusCode: error.statusCode // if PermanentDeliveryError
});
```

[Source: architecture/error-handling.md#Logging-Standards, architecture/coding-standards.md#Critical-Rules]

#### Repository Pattern

**IEventRepository Methods Used:**
- `findById(eventId: string): Promise<Event | null>` - Retrieve event
- `update(event: Event): Promise<Event>` - Persist status changes

**IMPORTANT:** IEventRepository.update() uses optimistic locking via `version` field. If concurrent update detected, it throws OptimisticLockError. Use case should catch and log this error (rare in practice since events are claimed exclusively).

[Source: architecture/port-interfaces.md, src/modules/event-scheduling/application/ports/IEventRepository.ts]

#### Webhook Payload Structure

**Schema:** `WebhookPayloadSchema` (defined in `src/shared/validation/schemas.ts`)

```typescript
export const WebhookPayloadSchema = z.object({
  message: z.string().min(1, 'Message is required'),
});
export type WebhookPayload = z.infer<typeof WebhookPayloadSchema>;
```

**Event Payload Storage:** `event.deliveryPayload` (type: `Record<string, unknown>`)

**Usage:**
```typescript
const payload: WebhookPayload = WebhookPayloadSchema.parse(event.deliveryPayload);
```

[Source: src/shared/validation/schemas.ts#L214-216, docs/stories/2.4.webhook-delivery-adapter.story.md#AC1]

#### Dependencies and Imports

**Required Imports:**
```typescript
import { DateTime } from 'luxon';
import { Event } from '../../domain/entities/Event';
import { IEventRepository } from '../ports/IEventRepository';
import { IWebhookClient } from '../ports/IWebhookClient';
import { WebhookPayload, WebhookPayloadSchema } from '../../../../shared/validation/schemas';
import { PermanentDeliveryError } from '../../../../domain/errors/PermanentDeliveryError';
import { InfrastructureError } from '../../../../domain/errors/InfrastructureError';
import { logger } from '../../../../shared/logger';
```

[Source: architecture/source-tree.md#Import-Rules]

#### TypeScript Standards

**Required:**
- Explicit accessibility modifiers (`public`, `private`, `protected`)
- Explicit return types for all methods
- No `any` types (use `unknown` if type unknown)
- Async/await (no callbacks or raw promises)
- Proper error handling with try/catch

**Example:**
```typescript
export class ExecuteEventUseCase {
  public constructor(
    private readonly eventRepository: IEventRepository,
    private readonly webhookClient: IWebhookClient
  ) {}

  public async execute(eventId: string): Promise<void> {
    // Implementation
  }
}
```

[Source: architecture/coding-standards.md#Core-Standards]

### Testing

#### Test Location
`src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.test.ts`

[Source: architecture/test-strategy.md#Unit-Tests]

#### Testing Framework
- **Framework:** Jest 29.7.0
- **Mocking:** Jest built-in mocks (no additional library)
- **Pattern:** AAA (Arrange, Act, Assert)

[Source: architecture/test-strategy.md#Unit-Tests]

#### Coverage Requirements
- **ExecuteEventUseCase:** 100% coverage required (critical path)
- **Overall:** ≥80% coverage for application layer

[Source: architecture/test-strategy.md#Coverage-Goals]

#### Test Scenarios Required

**Success Scenarios:**
1. Event execution succeeds → event marked COMPLETED with executedAt timestamp
2. Webhook delivery returns success response → event status updated correctly

**Failure Scenarios:**
3. Permanent failure (4xx) → event marked FAILED with failureReason, NO SQS retry
4. Transient failure (5xx) → event LEFT IN PROCESSING, SQS will retry
5. Timeout/network error → event LEFT IN PROCESSING, SQS will retry

**Edge Cases:**
6. Event not found → log warning, return without error
7. Event status not PROCESSING → log error, return without updating
8. Invalid event payload → Zod validation error handled correctly

**Validation:**
9. Webhook payload includes correct message from event.deliveryPayload
10. Idempotency key passed to webhookClient matches event.idempotencyKey
11. executedAt timestamp is DateTime.now() on completion
12. failureReason contains error message on permanent failure

[Source: architecture/test-strategy.md#AI-Agent-Requirements, architecture/coding-standards.md#Test-Requirements]

#### Mocking Strategy

**Mock IEventRepository:**
```typescript
const mockEventRepository: jest.Mocked<IEventRepository> = {
  findById: jest.fn(),
  update: jest.fn(),
  create: jest.fn(),
  findByUserId: jest.fn(),
  claimReadyEvents: jest.fn(),
  deleteByUserId: jest.fn(),
};
```

**Mock IWebhookClient:**
```typescript
const mockWebhookClient: jest.Mocked<IWebhookClient> = {
  deliver: jest.fn(),
};
```

**Mock Event Entity:**
```typescript
const mockEvent = new Event({
  id: '123e4567-e89b-12d3-a456-426614174000',
  userId: '660e8400-e29b-41d4-a716-446655440001',
  eventType: 'BIRTHDAY',
  status: EventStatus.PROCESSING,
  targetTimestampUTC: DateTime.now(),
  targetTimestampLocal: DateTime.now(),
  targetTimezone: 'America/New_York',
  executedAt: null,
  failureReason: null,
  retryCount: 0,
  version: 1,
  idempotencyKey: IdempotencyKey.generate('user-id', DateTime.now()),
  deliveryPayload: { message: 'Hey, John Doe it\'s your birthday' },
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
});
```

[Source: architecture/test-strategy.md#Use-Case-Test-Example]

#### Test Naming Convention

Use descriptive names explaining behavior:
- `should mark event as COMPLETED when webhook delivery succeeds`
- `should mark event as FAILED when webhook returns 4xx permanent error`
- `should leave event in PROCESSING when webhook returns 5xx transient error`
- `should log warning and return when event not found`
- `should log error and return when event status is not PROCESSING`

[Source: architecture/test-strategy.md#Test-Naming-Conventions]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Created story for Event Executor Use Case | Bob (Scrum Master) |

---

## Dev Agent Record

*(This section will be populated by the development agent during implementation)*

---

## QA Results

*(This section will be populated by the QA agent after testing)*
