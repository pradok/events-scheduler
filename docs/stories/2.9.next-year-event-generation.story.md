# Story 2.9: Next Year Event Generation

---

## Status

Approved

---

## Story

**As a** developer,
**I want** automatic generation of next year's birthday event after current year completes,
**so that** users continue receiving birthday messages annually.

---

## Acceptance Criteria

1. ExecuteEventUseCase checks if current year's birthday was executed
2. After marking event COMPLETED, use case generates next year's event
3. Next year event has targetTimestamp calculated for next birthday at 9:00 AM local time
4. Next year event handles leap year edge case (Feb 29 → Mar 1 in non-leap years)
5. Next year event created in same transaction as status update (both succeed or both fail)
6. Only COMPLETED events trigger next year generation (not FAILED events)
7. Unit tests verify next year event creation with correct timestamps
8. Integration tests verify annual event chain works across multiple years

---

## Tasks / Subtasks

- [ ] **Task 1: Add User Retrieval Capability to ExecuteEventUseCase** (AC: 1, 2, 3, 4)
  - [ ] Add `IUserRepository` as a constructor dependency in `ExecuteEventUseCase`
  - [ ] After marking event COMPLETED, retrieve user by `event.userId`
  - [ ] Handle case where user is deleted (log warning, skip next year event generation)
  - [ ] Reference: [Source: docs/architecture/port-interfaces.md#IUserRepository]
  - [ ] Reference: [Source: docs/architecture/error-handling.md#User-Facing-Error-Format]

- [ ] **Task 2: Generate Next Year Event Using BirthdayEventHandler** (AC: 2, 3, 4)
  - [ ] Add `BirthdayEventHandler` as a constructor dependency in `ExecuteEventUseCase`
  - [ ] Add `TimezoneService` as a constructor dependency in `ExecuteEventUseCase`
  - [ ] Convert User entity to `UserInfo` interface (primitives) for BirthdayEventHandler
  - [ ] Call `BirthdayEventHandler.calculateNextOccurrence(userInfo)` to get next birthday at 9:00 AM local time
  - [ ] Verify leap year handling (Feb 29 → Feb 28 in non-leap years) is already implemented in BirthdayEventHandler
  - [ ] Call `BirthdayEventHandler.formatMessage(userInfo)` to generate message payload
  - [ ] Call `TimezoneService.convertToUTC()` to convert next birthday to UTC for storage
  - [ ] Reference: [Source: src/modules/event-scheduling/domain/services/event-handlers/BirthdayEventHandler.ts]
  - [ ] Reference: [Source: docs/architecture/data-models.md#Event]

- [ ] **Task 3: Create Next Year Event Entity** (AC: 2, 3, 4)
  - [ ] Create new `Event` entity with:
    - `userId`: Same as completed event
    - `eventType`: 'BIRTHDAY' (same as completed event)
    - `status`: EventStatus.PENDING
    - `targetTimestampUTC`: Next birthday at 9:00 AM (UTC)
    - `targetTimestampLocal`: Next birthday at 9:00 AM (local time)
    - `targetTimezone`: User's current timezone (user.timezone.toString())
    - `idempotencyKey`: Generate using `IdempotencyKey.generate(userId, targetTimestampUTC)`
    - `deliveryPayload`: Formatted birthday message from BirthdayEventHandler
    - `retryCount`: 0
    - `version`: 1
  - [ ] Verify all required fields are populated
  - [ ] Reference: [Source: docs/architecture/data-models.md#Event]
  - [ ] Reference: [Source: docs/architecture/data-models.md#IdempotencyKey]

- [ ] **Task 4: Wrap Status Update and Event Creation in Transaction** (AC: 5)
  - [ ] Modify `ExecuteEventUseCase.execute()` to use transaction wrapper
  - [ ] Within transaction:
    1. Update completed event status to COMPLETED
    2. Create next year event
  - [ ] Transaction ensures both succeed or both fail atomically
  - [ ] Handle transaction rollback on any error (log error, rethrow)
  - [ ] Reference: [Source: docs/architecture/error-handling.md#Transaction-Strategy]
  - [ ] Reference: Prisma transaction API: `prisma.$transaction(async (tx) => { ... })`

- [ ] **Task 5: Add Conditional Logic for COMPLETED Events Only** (AC: 6)
  - [ ] Only generate next year event if current event is being marked COMPLETED
  - [ ] Do NOT generate next year event if current event is being marked FAILED
  - [ ] Rationale: Failed deliveries should not trigger automatic annual events (may indicate invalid user data)
  - [ ] Log decision in both cases (completed → generate, failed → skip)
  - [ ] Reference: [Source: docs/architecture/error-handling.md#Business-Logic-Errors]

- [ ] **Task 6: Unit Tests for Next Year Event Generation** (AC: 7)
  - [ ] Test scenario 1: Successful event completion generates next year event
    - Mock user with birthday March 15
    - Execute event on March 15, 2025
    - Verify next year event created with targetTimestamp March 15, 2026 at 9:00 AM
  - [ ] Test scenario 2: Leap year birthday handling (Feb 29 → Feb 28)
    - Mock user with birthday Feb 29
    - Execute event in leap year (2024)
    - Verify next year event created with Feb 28, 2025 (non-leap year)
  - [ ] Test scenario 3: Failed event does NOT generate next year event
    - Mark event as FAILED
    - Verify no next year event created
  - [ ] Test scenario 4: User deleted before next year generation
    - Mock `userRepository.findById()` returns null
    - Verify no error thrown, no next year event created
  - [ ] Test scenario 5: Transaction rollback on event creation failure
    - Mock `eventRepository.create()` throws error
    - Verify transaction rolled back, original event remains PROCESSING
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#Unit-Tests]

- [ ] **Task 7: Integration Tests for Annual Event Chain** (AC: 8)
  - [ ] Test scenario 1: Multi-year event chain
    - Create user with birthday tomorrow
    - Execute event (year 1) → verify next year event created
    - Execute next year event (year 2) → verify year 3 event created
    - Verify event chain continues for 3 years
  - [ ] Test scenario 2: Timezone changes between years
    - Create user with timezone America/New_York
    - Execute year 1 event
    - Change user timezone to Europe/London
    - Verify year 2 event uses NEW timezone (Europe/London)
  - [ ] Test scenario 3: Transaction atomicity with real database
    - Use Testcontainers PostgreSQL
    - Simulate transaction failure during event creation
    - Verify original event remains in PROCESSING state (rollback succeeded)
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#Integration-Tests]

---

## Dev Notes

### Previous Story Insights

**From Story 2.8 (Event State Machine Enforcement):**
- ExecuteEventUseCase already handles state transitions correctly (PROCESSING → COMPLETED, PROCESSING → FAILED)
- Optimistic locking is properly implemented in repository layer
- Error handling distinguishes between permanent and transient failures
- Dev agent should follow similar verification pattern: check existing implementation, add next year generation logic

**From Story 2.5 (Event Executor Use Case):**
- ExecuteEventUseCase.ts location: `src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.ts`
- Current implementation marks events COMPLETED after successful webhook delivery
- Uses port interfaces (IEventRepository, IWebhookClient) for clean architecture
- This story extends ExecuteEventUseCase by adding next year event generation

### Architecture Context

#### Event Lifecycle and Annual Recurrence

**Annual Event Pattern:**

```
2025 Birthday Event (created when user signs up)
    ↓ PENDING
    ↓ PROCESSING (claimed by scheduler)
    ↓ COMPLETED (webhook delivered successfully)
    ↓ Triggers: Create 2026 Birthday Event

2026 Birthday Event (auto-created after 2025 completes)
    ↓ PENDING
    ↓ PROCESSING
    ↓ COMPLETED
    ↓ Triggers: Create 2027 Birthday Event

... (infinite chain)
```

**Design Decision: When to Generate Next Year Event**

Next year event generation happens AFTER webhook delivery succeeds:

1. Event enters PROCESSING state (claimed by scheduler)
2. Webhook delivered successfully
3. Mark event COMPLETED ← **Generate next year event HERE**
4. Transaction commits (both status update AND next year event creation)

**Why NOT generate next year event when marking FAILED:**

- Failed events may indicate invalid user data (bad webhook URL, deleted user, etc.)
- Automatic annual recurrence should only continue for successful deliveries
- Admins can manually create events for failed cases after investigation

[Source: Epic 2, Story 2.9 Requirements]

#### Birthday Calculation (BirthdayEventHandler)

**Location:** `src/modules/event-scheduling/domain/services/event-handlers/BirthdayEventHandler.ts`

**Strategy Pattern Implementation (Story 1.5):**

BirthdayEventHandler implements the IEventHandler interface and provides birthday-specific domain logic:

1. **calculateNextOccurrence(userInfo, referenceDate):**
   - Calculates next birthday at 9:00 AM local time
   - Handles leap years (Feb 29 → Feb 28 in non-leap years)
   - Returns `DateTime` in user's timezone

2. **formatMessage(userInfo):**
   - Generates birthday message: `"Hey, {firstName} {lastName} it's your birthday"`

**Example Usage in ExecuteEventUseCase:**

```typescript
// After marking event COMPLETED
const user = await userRepository.findById(event.userId);
if (!user) {
  logger.warn({ msg: 'User not found, skipping next year event', userId: event.userId });
  return;
}

// Convert User entity to UserInfo interface
const userInfo: UserInfo = {
  firstName: user.firstName,
  lastName: user.lastName,
  dateOfBirth: user.dateOfBirth.toString(), // ISO format YYYY-MM-DD
  timezone: user.timezone.toString()        // IANA format
};

// Calculate next birthday at 9:00 AM local time
const nextBirthdayLocal = birthdayEventHandler.calculateNextOccurrence(userInfo);

// Convert to UTC for storage
const nextBirthdayUTC = timezoneService.convertToUTC(nextBirthdayLocal, user.timezone);

// Format message
const message = birthdayEventHandler.formatMessage(userInfo);
```

**Leap Year Handling (Already Implemented):**

BirthdayEventHandler.ts handles Feb 29 birthdays automatically:

- **Leap year → Leap year:** Feb 29, 2024 → Feb 29, 2028
- **Leap year → Non-leap year:** Feb 29, 2024 → **Feb 28, 2025** (per Epic requirements)
- **Non-leap year → Leap year:** Feb 28, 2025 → Feb 29, 2028 (if original birthday was Feb 29)

**IMPORTANT:** The dev agent should NOT reimplement leap year logic. BirthdayEventHandler already handles this correctly.

[Source: src/modules/event-scheduling/domain/services/event-handlers/BirthdayEventHandler.ts:89-103]
[Source: docs/architecture/design-patterns.md#Strategy-Pattern]

#### Idempotency Key Generation

**Location:** `src/modules/event-scheduling/domain/value-objects/IdempotencyKey.ts`

**Generation Algorithm:**

```typescript
IdempotencyKey.generate(userId: string, targetTimestampUTC: DateTime): IdempotencyKey
```

**Format:** `event-{16_character_sha256_hash}`

**Deterministic Behavior:** Same inputs always produce the same key.

**Why Deterministic Keys are Critical for Annual Events:**

- 2025 event: `event-a1b2c3d4e5f6g7h8` (userId + "2025-03-15T14:00:00Z" + "BIRTHDAY")
- 2026 event: `event-x9y8z7w6v5u4t3s2` (userId + "2026-03-15T14:00:00Z" + "BIRTHDAY")
- Different timestamps → Different keys → No collision

Even if next year event generation runs twice due to retry, the database unique constraint on `idempotency_key` prevents duplicate events.

[Source: docs/architecture/data-models.md#IdempotencyKey]

#### Transaction Management

**Prisma Transaction API:**

```typescript
return await this.eventRepository.transaction(async (tx) => {
  // Step 1: Update current event to COMPLETED
  await tx.update(completedEvent);

  // Step 2: Create next year event
  await tx.create(nextYearEvent);

  // Both succeed or both fail atomically
});
```

**Why Transaction is Required (AC 5):**

- **Scenario 1:** Status update succeeds, event creation fails → Original event marked COMPLETED but no next year event (broken annual chain)
- **Scenario 2:** Event creation succeeds, status update fails → Two PROCESSING events for same user (invalid state)

**With Transaction:** Both operations succeed or both fail (rollback). System remains in consistent state.

**Error Handling in Transaction:**

- Any error during transaction → Automatic rollback → Original event remains PROCESSING
- SQS will retry entire execution (including next year event generation)
- Idempotency key prevents duplicate next year events on retry

[Source: docs/architecture/error-handling.md#Transaction-Strategy]

#### Repository Interfaces

**IUserRepository:**

**Location:** `src/modules/user/application/ports/IUserRepository.ts`

**Methods Used in This Story:**

```typescript
findById(userId: string): Promise<User | null>
```

**Purpose:** Retrieve user data (birthday, timezone) to calculate next year event timestamp.

**Implementation:** `src/modules/user/adapters/persistence/PrismaUserRepository.ts`

[Source: docs/architecture/port-interfaces.md#IUserRepository]

**IEventRepository:**

**Location:** `src/modules/event-scheduling/application/ports/IEventRepository.ts`

**Methods Used in This Story:**

```typescript
create(event: Event): Promise<Event>
update(event: Event): Promise<Event>
```

**Transaction Support:**

The repository implementation must support transactions for atomic updates:

```typescript
interface IEventRepository {
  transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T>;
}
```

**Implementation:** `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.ts`

[Source: docs/architecture/port-interfaces.md#IEventRepository]

#### File Locations

**Files to Modify:**

- `src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.ts` - Add next year event generation logic
- `src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.test.ts` - Add unit tests

**Files to Reference (Do NOT modify):**

- `src/modules/event-scheduling/domain/services/event-handlers/BirthdayEventHandler.ts` - Birthday calculation logic
- `src/modules/event-scheduling/domain/services/TimezoneService.ts` - Timezone conversion
- `src/modules/event-scheduling/domain/value-objects/IdempotencyKey.ts` - Key generation
- `src/modules/event-scheduling/domain/entities/Event.ts` - Event entity constructor
- `src/modules/user/application/ports/IUserRepository.ts` - User repository interface

**Integration Test Location:**

- `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.integration.test.ts` - Add annual event chain tests

[Source: docs/architecture/source-tree.md#Bounded-Contexts]

#### TimezoneService Usage

**Location:** `src/modules/event-scheduling/domain/services/TimezoneService.ts`

**Method:**

```typescript
convertToUTC(localDateTime: DateTime, timezone: Timezone): DateTime
```

**Purpose:** Convert local timestamp (9:00 AM in user's timezone) to UTC for database storage.

**Example:**

```typescript
const nextBirthdayLocal = DateTime.fromObject(
  { year: 2026, month: 3, day: 15, hour: 9, minute: 0 },
  { zone: 'America/New_York' }
);

const nextBirthdayUTC = timezoneService.convertToUTC(nextBirthdayLocal, user.timezone);
// Result: 2026-03-15T14:00:00.000Z (UTC, 5 hours ahead of NY)
```

[Source: docs/architecture/data-models.md#Event]

#### Error Handling

**User Not Found Scenario:**

If user is deleted after event execution but before next year generation:

```typescript
const user = await userRepository.findById(event.userId);
if (!user) {
  logger.warn({
    msg: 'User deleted, skipping next year event generation',
    userId: event.userId,
    eventId: event.id
  });
  return; // Exit gracefully, do not throw error
}
```

**Rationale:** This is not an error condition. User deletion is a valid business operation. Simply skip next year event generation and log for audit trail.

**Transaction Failure Scenario:**

If next year event creation fails (database error, constraint violation):

```typescript
try {
  await eventRepository.transaction(async (tx) => {
    await tx.update(completedEvent);
    await tx.create(nextYearEvent);
  });
} catch (error) {
  logger.error({
    msg: 'Transaction failed during next year event generation',
    eventId: event.id,
    userId: event.userId,
    error: error.message
  });
  throw error; // Rethrow to trigger SQS retry
}
```

**Rationale:** Transaction failure is a transient infrastructure error. SQS should retry the entire execution (including next year event generation). Transaction rollback ensures original event remains in PROCESSING state.

[Source: docs/architecture/error-handling.md#External-API-Errors]

### Testing

#### Test Framework

- **Framework:** Jest 29.7.0
- **Pattern:** AAA (Arrange, Act, Assert)
- **Coverage:** ≥80% for application use cases

[Source: docs/architecture/test-strategy.md#Unit-Tests]

#### Unit Test Location

Tests colocated with source file:

- `src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.test.ts`

#### Integration Test Location

Tests in persistence adapter folder:

- `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.integration.test.ts`

#### Test Data Builders

Use existing test builders for fluent test data creation:

- `UserBuilder` - Create test users with sensible defaults
- `EventBuilder` - Create test events with sensible defaults

[Source: docs/architecture/design-patterns.md#Builder-Pattern]
[Source: docs/architecture/test-strategy.md#Test-Data-Management]

#### Key Test Scenarios

**Unit Tests:**

1. Successful event completion generates next year event
2. Leap year birthday handling (Feb 29 → Feb 28)
3. Failed event does NOT generate next year event
4. User deleted before next year generation (graceful handling)
5. Transaction rollback on event creation failure

**Integration Tests:**

1. Multi-year event chain (3 consecutive years)
2. Timezone changes between years
3. Transaction atomicity with real PostgreSQL database

[Source: docs/architecture/test-strategy.md#Test-Scenarios]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-25 | 1.0 | Created Story 2.9 for Next Year Event Generation | Bob (Scrum Master) |
| 2025-10-25 | 1.1 | Story approved - ready for development | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used

*To be populated by dev agent during implementation*

### Implementation Summary

*To be populated by dev agent during implementation*

### Changes Made

*To be populated by dev agent during implementation*

### File List

*To be populated by dev agent during implementation*

---

## QA Results

*To be populated by QA agent after story completion*
