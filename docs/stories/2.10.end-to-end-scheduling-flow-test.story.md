# Story 2.10: End-to-End Scheduling Flow Test

---

## Status

Approved

---

## Story

**As a** developer,
**I want** comprehensive E2E tests for the complete scheduling flow,
**so that** I can verify the entire system works together correctly.

---

## Acceptance Criteria

1. E2E test creates user with birthday tomorrow
2. Test advances time to trigger event (using time mocking or fast-forward)
3. Test verifies scheduler finds and claims event
4. Test verifies event sent to SQS queue
5. Test verifies worker processes message and delivers webhook
6. Test verifies event status updated to COMPLETED
7. Test verifies next year's event was created
8. Test completes in <30 seconds with all assertions passing

---

## Tasks / Subtasks

- [ ] **Task 1: Set Up E2E Test Infrastructure** (AC: 1, 8)
  - [ ] Create E2E test file: `tests/e2e/event-scheduling-flow.e2e.test.ts`
  - [ ] Configure Jest timeout to 30000ms for E2E tests
  - [ ] Set up `beforeAll` hook to initialize:
    - Prisma client connected to local PostgreSQL (via docker-compose)
    - AWS SDK clients (SQS, Lambda, EventBridge) pointing to LocalStack
    - Queue URL retrieval from LocalStack (`events-queue`)
    - Webhook mock server or RequestBin endpoint URL
  - [ ] Set up `afterAll` hook to disconnect Prisma client
  - [ ] Set up `beforeEach` hook to clean database (delete all events and users)
  - [ ] Set up `afterEach` hook to purge SQS queue messages
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#End-to-End-Tests]
  - [ ] Reference: [Source: docs/architecture/localstack-setup.md#Testing-Considerations]

- [ ] **Task 2: Create User with Birthday Tomorrow** (AC: 1)
  - [ ] Use Prisma client directly to create user in database:
    - `firstName`: 'Jane'
    - `lastName`: 'Doe'
    - `dateOfBirth`: Tomorrow's date (e.g., if today is Jan 15, use `1990-01-16`)
    - `timezone`: 'America/New_York'
  - [ ] Calculate tomorrow's date using Luxon DateTime: `DateTime.now().plus({ days: 1 })`
  - [ ] Use `toISODate()` to format birthday as 'YYYY-MM-DD'
  - [ ] Manually create PENDING birthday event for tomorrow at 9:00 AM:
    - Use `BirthdayEventHandler.calculateNextOccurrence()` to get proper timestamp
    - Convert to UTC using `TimezoneService.convertToUTC()`
    - Generate `idempotencyKey` using `IdempotencyKey.generate(userId, targetTimestampUTC)`
    - Set `status` to 'PENDING'
    - Set `eventType` to 'BIRTHDAY'
  - [ ] Alternative approach: Invoke `CreateUserUseCase` via API (if REST API is available)
  - [ ] Verify user and event exist in database before advancing time
  - [ ] Reference: [Source: docs/architecture/data-models.md#User]
  - [ ] Reference: [Source: docs/architecture/data-models.md#Event]

- [ ] **Task 3: Advance Time to Trigger Event** (AC: 2)
  - [ ] **Option A: Time Mocking (Recommended for Speed)**
    - Mock Luxon DateTime.now() to return tomorrow's date + 9:05 AM
    - This makes the event "ready" (targetTimestampUTC <= NOW())
    - Note: Scheduler Lambda uses DateTime.now() internally
  - [ ] **Option B: Fast-Forward (Simpler, No Mocking)**
    - Create event with `targetTimestampUTC` set to 5 minutes ago (DateTime.now().minus({ minutes: 5 }))
    - Event is immediately "overdue" and scheduler will claim it
    - This avoids need for time mocking (simpler test setup)
  - [ ] **Recommendation:** Use Option B for E2E tests (no mocking, realistic scenario)
  - [ ] Document choice in test comments
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#End-to-End-Tests]

- [ ] **Task 4: Verify Scheduler Finds and Claims Event** (AC: 3)
  - [ ] Invoke scheduler Lambda manually via AWS SDK:
    - Use `LambdaClient.send(new InvokeCommand({ FunctionName: 'event-scheduler', Payload: '{}' }))`
    - This simulates EventBridge trigger
  - [ ] Verify Lambda invocation succeeds (StatusCode: 200)
  - [ ] Query database to verify event status changed from PENDING → PROCESSING:
    - Use `prisma.events.findUnique({ where: { id: eventId } })`
    - Assert `status === 'PROCESSING'`
  - [ ] Verify event's `version` field incremented by 1 (optimistic locking)
  - [ ] Reference: [Source: docs/architecture/data-models.md#Event]
  - [ ] Reference: [Source: src/adapters/primary/lambda/schedulerHandler.e2e.test.ts#66-97]

- [ ] **Task 5: Verify Event Sent to SQS Queue** (AC: 4)
  - [ ] Poll SQS queue for messages using `ReceiveMessageCommand`:
    - Set `MaxNumberOfMessages: 10`
    - Set `WaitTimeSeconds: 5` (long polling to reduce API calls)
  - [ ] Verify exactly 1 message received
  - [ ] Parse message body as JSON
  - [ ] Verify message contains:
    - `eventId` matches created event
    - `eventType` equals 'BIRTHDAY'
    - `idempotencyKey` matches event's idempotency key
  - [ ] Save `ReceiptHandle` for later message deletion (cleanup)
  - [ ] Reference: [Source: docs/architecture/localstack-setup.md#SQS-Commands]
  - [ ] Reference: [Source: Story 2.2 - SQS Message Schema]

- [ ] **Task 6: Verify Worker Processes Message and Delivers Webhook** (AC: 5)
  - [ ] Invoke worker Lambda manually via AWS SDK:
    - Use `LambdaClient.send(new InvokeCommand({ FunctionName: 'event-worker', Payload: sqsEventPayload }))`
    - Construct SQS event payload with message from Task 5
  - [ ] Verify Lambda invocation succeeds (StatusCode: 200)
  - [ ] **Webhook Verification Option A: Mock Webhook Server**
    - Start simple HTTP server in test (using `express` or `http.createServer`)
    - Listen on `http://localhost:3001/webhook`
    - Verify POST request received with correct payload
  - [ ] **Webhook Verification Option B: RequestBin (External Service)**
    - Use existing RequestBin endpoint from `.env.WEBHOOK_TEST_URL`
    - Poll RequestBin API to verify request received (may require API key)
  - [ ] **Webhook Verification Option C: Skip Webhook Validation**
    - Focus E2E test on internal system flow (scheduler → queue → worker → database)
    - Webhook delivery already tested in Story 2.4 integration tests
    - Verify worker Lambda completes successfully (implied webhook success)
  - [ ] **Recommendation:** Use Option C for E2E tests (webhook delivery tested elsewhere)
  - [ ] Reference: [Source: Story 2.4 - Webhook Delivery Adapter]
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#Test-Pyramid]

- [ ] **Task 7: Verify Event Status Updated to COMPLETED** (AC: 6)
  - [ ] Query database to verify event status changed from PROCESSING → COMPLETED:
    - Use `prisma.events.findUnique({ where: { id: eventId } })`
    - Assert `status === 'COMPLETED'`
  - [ ] Verify event's `executedAt` timestamp is populated (not null)
  - [ ] Verify event's `version` field incremented again (now version 3: PENDING→1, PROCESSING→2, COMPLETED→3)
  - [ ] Reference: [Source: docs/architecture/data-models.md#Event]
  - [ ] Reference: [Source: Story 2.5 - Event Executor Use Case]

- [ ] **Task 8: Verify Next Year Event Was Created** (AC: 7)
  - [ ] Query database for events belonging to same user:
    - Use `prisma.events.findMany({ where: { userId: userId }, orderBy: { targetTimestampUTC: 'asc' } })`
  - [ ] Verify exactly 2 events exist for user:
    - Event 1: COMPLETED (this year's birthday)
    - Event 2: PENDING (next year's birthday)
  - [ ] Verify next year event's `targetTimestampUTC` is exactly 1 year later:
    - Calculate expected timestamp: `completedEvent.targetTimestampUTC + 1 year`
    - Handle leap year edge case: If birthday is Feb 29, next year event should be Feb 28 (non-leap year)
  - [ ] Verify next year event's `idempotencyKey` is different from this year's event
  - [ ] Verify next year event's `status` is 'PENDING'
  - [ ] Reference: [Source: Story 2.9 - Next Year Event Generation]
  - [ ] Reference: [Source: docs/architecture/data-models.md#Event]

- [ ] **Task 9: Verify Test Completes in <30 Seconds** (AC: 8)
  - [ ] Configure Jest timeout: `jest.setTimeout(30000)`
  - [ ] Measure test execution time using `console.time('E2E Test')` / `console.timeEnd('E2E Test')`
  - [ ] Optimize slow operations:
    - Use SQS long polling (WaitTimeSeconds: 5) instead of short polling
    - Avoid unnecessary database queries (batch queries where possible)
    - Use `Promise.all()` for parallel operations (e.g., Lambda invocation + queue polling)
  - [ ] If test exceeds 30 seconds, identify bottleneck:
    - Lambda cold start: 3-5 seconds (acceptable)
    - Database queries: <1 second each (acceptable)
    - SQS polling: 5-10 seconds (acceptable with long polling)
  - [ ] Target: Test completes in 15-25 seconds (headroom for CI/CD variability)
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#End-to-End-Tests]

- [ ] **Task 10: Add Documentation and Test Helpers** (AC: 1-8)
  - [ ] Add comprehensive JSDoc comments explaining:
    - E2E test purpose and scope
    - Prerequisites (LocalStack, PostgreSQL, Lambda deployment)
    - How to run the test (`npm run test:e2e`)
    - Difference from integration tests (deployment verification vs unit testing)
  - [ ] Create reusable test helpers in `tests/helpers/e2e-helpers.ts`:
    - `waitForEventStatus(eventId, expectedStatus, timeoutMs)` - Poll database until status changes
    - `waitForSQSMessage(queueUrl, timeoutMs)` - Poll SQS queue until message appears
    - `invokeLambda(functionName, payload)` - Invoke Lambda and assert success
    - `createTestUser(dateOfBirth, timezone)` - Create user with event in database
  - [ ] Add README section: `docs/testing.md#Running-E2E-Tests`
  - [ ] Document known issues and troubleshooting:
    - Lambda not deployed: "ResourceNotFoundException" → Run `npm run lambda:all`
    - Queue not found: "QueueDoesNotExist" → Verify LocalStack init-aws.sh ran
    - Database connection error: "Can't reach database server" → Run `docker-compose up`
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#End-to-End-Tests]
  - [ ] Reference: [Source: src/adapters/primary/lambda/schedulerHandler.e2e.test.ts#16-55]

---

## Dev Notes

### Previous Story Insights

**From Story 2.9 (Next Year Event Generation):**
- ExecuteEventUseCase successfully implements next year event creation after COMPLETED status
- Integration tests validate next year event generation with correct timestamps and idempotency keys
- Worker Lambda handler located at `src/adapters/primary/lambda/workerHandler.ts`
- Next year event uses current user timezone (supports timezone changes between years)

**From Story 2.11 (LocalStack Configuration Simplification):**
- LocalStack is properly configured with dual-purpose pattern:
  - **Persistent infrastructure** (manual E2E/demos): `events-queue`, deployed Lambdas, EventBridge rules
  - **Ephemeral test resources** (automated tests): Unique queues per test, Testcontainers PostgreSQL
- Queue name is `events-queue` (standardized, not `bday-events-queue`)
- Lambda deployment scripts use AWS SDK v3 (`scripts/deploy-lambda.js`)
- LocalStack initialization script: `docker/localstack/init-aws.sh`
- Documentation: `docs/architecture/localstack-setup.md`, `docs/architecture/localstack-troubleshooting.md`

**From Story 2.8 (Event State Machine Enforcement):**
- Event status transitions: PENDING → PROCESSING → COMPLETED/FAILED
- Optimistic locking via `version` field prevents concurrent updates
- ExecuteEventUseCase properly handles state transitions with validation

**From Story 2.5 (Event Executor Use Case):**
- ExecuteEventUseCase location: `src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.ts`
- Use case marks events COMPLETED after successful webhook delivery
- Error handling distinguishes between transient (retry) and permanent (fail) errors

**From Story 2.3 (EventBridge Scheduler Trigger):**
- Scheduler Lambda handler: `src/adapters/primary/lambda/schedulerHandler.ts`
- Lambda function name: `event-scheduler`
- EventBridge rule name: `event-scheduler-rule`
- Deployment via `npm run lambda:all` (build + deploy)

**From Story 2.2 (SQS Queue Integration):**
- SQS message schema includes: `eventId`, `eventType`, `idempotencyKey`, `metadata`
- Messages validated against Zod schema before sending
- Queue URL retrieved dynamically from LocalStack

### Architecture Context

#### E2E Testing Philosophy

**Purpose of E2E Tests:**

E2E tests validate the **complete deployed system** in a production-like environment (LocalStack):

- **What E2E tests verify:**
  - Infrastructure wiring: EventBridge → Lambda, Lambda → SQS, SQS → Worker Lambda
  - Deployment correctness: Lambda functions deployed with correct configuration
  - End-to-end data flow: User creation → Event scheduling → Webhook delivery → Next year generation
  - Integration across all layers: API → Use Cases → Repositories → Database → Message Queue

- **What E2E tests do NOT verify:**
  - Unit-level business logic (covered by unit tests with 97%+ coverage)
  - Edge cases and error handling (covered by integration tests)
  - Code coverage (Jest cannot instrument Lambda code running in LocalStack)

**E2E vs Integration Tests:**

| Aspect | Integration Tests | E2E Tests |
|--------|------------------|-----------|
| **Execution** | In-process (Jest calls handler functions directly) | Out-of-process (AWS SDK invokes deployed Lambdas) |
| **Speed** | Fast (~1-5 seconds per test) | Slower (~15-30 seconds per test) |
| **Coverage** | 100% code coverage possible | Cannot measure code coverage (external process) |
| **Value** | Validate business logic and error handling | Validate deployment and infrastructure wiring |
| **CI/CD** | Run on every commit (fast feedback) | Run before merges or deployments (smoke test) |

[Source: docs/architecture/test-strategy.md#Test-Pyramid]
[Source: docs/architecture/test-strategy.md#End-to-End-Tests]

#### Test Pyramid Distribution

The project follows the testing pyramid pattern:

- **70% Unit Tests** - Fast, isolated, test business logic (domain entities, use cases)
- **20% Integration Tests** - Test component interactions with real dependencies (repositories, adapters)
- **10% E2E Tests** - Test complete user journeys (API → Database → Queue → Lambda)

**For this story:**
- Create **1 comprehensive E2E test** covering the happy path (AC 1-8)
- Rely on existing integration tests for edge cases and error scenarios
- Focus E2E test on validating infrastructure wiring, not business logic

[Source: docs/architecture/test-strategy.md#Test-Pyramid]

#### E2E Test Infrastructure

**Prerequisites (Manual Setup):**

1. **LocalStack running:**
   ```bash
   docker-compose up
   ```

2. **PostgreSQL running:**
   ```bash
   docker-compose up
   ```

3. **Lambda deployed to LocalStack:**
   ```bash
   npm run lambda:all
   ```

**Automated in Test:**

- Prisma client connects to local PostgreSQL (`DATABASE_URL` from `.env`)
- AWS SDK clients (SQS, Lambda, EventBridge) connect to LocalStack (`http://localhost:4566`)
- Queue URL retrieved dynamically from LocalStack (`events-queue`)
- Database cleaned before each test (`beforeEach` hook deletes all events and users)
- SQS queue purged after each test (`afterEach` hook removes all messages)

[Source: docs/architecture/localstack-setup.md#Testing-Considerations]
[Source: docs/architecture/local-development.md#Docker-Environment]

#### File Locations

**New E2E Test File:**
- `tests/e2e/event-scheduling-flow.e2e.test.ts` - Main E2E test for complete scheduling flow

**Existing E2E Test Reference:**
- `src/adapters/primary/lambda/schedulerHandler.e2e.test.ts` - Example E2E test for scheduler Lambda (shows AWS SDK patterns)

**Test Helpers (To Create):**
- `tests/helpers/e2e-helpers.ts` - Reusable E2E test utilities

**Lambda Handlers (Already Exist):**
- `src/adapters/primary/lambda/schedulerHandler.ts` - EventBridge → Scheduler Lambda
- `src/adapters/primary/lambda/workerHandler.ts` - SQS → Worker Lambda

**LocalStack Configuration:**
- `docker/localstack/init-aws.sh` - Creates static infrastructure (queues, EventBridge rules)
- `scripts/deploy-lambda.js` - Deploys Lambda functions to LocalStack
- `docker-compose.yml` - Starts LocalStack and PostgreSQL

[Source: docs/architecture/source-tree.md#Project-Structure]

#### Time Handling for E2E Tests

**Challenge:** Event is scheduled for "tomorrow at 9:00 AM" but test needs to verify it executes immediately.

**Solution Options:**

1. **Option A: Time Mocking (Complex)**
   - Mock Luxon DateTime.now() to return tomorrow's date
   - Requires Jest mocking setup in test
   - Risk: Mocking may not work in deployed Lambda (separate process)

2. **Option B: Fast-Forward (Recommended)**
   - Create event with `targetTimestampUTC` set to 5 minutes ago:
     ```typescript
     targetTimestampUTC: DateTime.now().minus({ minutes: 5 }).toJSDate()
     ```
   - Event is immediately "overdue" when scheduler runs
   - No mocking required, simpler test setup
   - Realistic scenario (scheduler catching up after downtime)

**Recommendation:** Use **Option B (Fast-Forward)** for E2E tests.

[Source: docs/architecture/test-strategy.md#End-to-End-Tests]

#### Webhook Delivery Verification

**Challenge:** E2E test needs to verify webhook was delivered successfully.

**Solution Options:**

1. **Option A: Mock Webhook Server**
   - Start simple HTTP server in test using `express` or `http.createServer`
   - Listen on `http://localhost:3001/webhook`
   - Verify POST request received with correct payload
   - Pros: Full control, fast, no external dependencies
   - Cons: Adds test complexity, another service to manage

2. **Option B: RequestBin (External Service)**
   - Use existing RequestBin endpoint from `.env.WEBHOOK_TEST_URL`
   - Poll RequestBin API to verify request received
   - Pros: Realistic external service simulation
   - Cons: Requires internet, API key, slower, test flakiness

3. **Option C: Skip Webhook Validation (Recommended)**
   - Focus E2E test on **internal system flow** (scheduler → queue → worker → database)
   - Webhook delivery already tested in **Story 2.4 integration tests** (comprehensive coverage)
   - Verify worker Lambda completes successfully (implied webhook success based on status COMPLETED)
   - Pros: Simpler test, faster, no external dependencies
   - Cons: Doesn't verify webhook payload format end-to-end

**Recommendation:** Use **Option C (Skip Webhook Validation)** for E2E tests.

**Rationale:**
- Webhook delivery is **thoroughly tested** in Story 2.4 integration tests (retry logic, error handling, schema validation)
- E2E test goal is **infrastructure wiring** (EventBridge → Lambda → SQS → Worker), not webhook payload validation
- Test pyramid: Unit/Integration tests cover detailed scenarios, E2E tests cover happy path
- Keeps E2E test focused, fast, and reliable

[Source: docs/architecture/test-strategy.md#Test-Pyramid]
[Source: Story 2.4 - Webhook Delivery Adapter]

#### SQS Message Polling Strategy

**Challenge:** Messages may not appear in queue immediately due to async processing.

**Solution: Long Polling**

```typescript
const receiveCommand = new ReceiveMessageCommand({
  QueueUrl: queueUrl,
  MaxNumberOfMessages: 10,
  WaitTimeSeconds: 5, // Long polling (wait up to 5 seconds for messages)
});

const response = await sqsClient.send(receiveCommand);
```

**Benefits:**
- Reduces API calls (more efficient than short polling loop)
- Avoids race conditions (wait for message to appear)
- Faster test execution (no retry loops with delays)

**Alternative: Retry Loop (Not Recommended)**

```typescript
// ❌ Avoid this pattern (unnecessary complexity)
for (let i = 0; i < 10; i++) {
  const response = await sqsClient.send(receiveCommand);
  if (response.Messages?.length > 0) break;
  await new Promise(resolve => setTimeout(resolve, 1000));
}
```

[Source: docs/architecture/localstack-setup.md#SQS-Commands]

#### Database Cleanup Strategy

**Pattern: Delete All Data Before Each Test**

```typescript
beforeEach(async () => {
  // Order matters: Delete child records (events) before parent records (users)
  await prisma.events.deleteMany();
  await prisma.users.deleteMany();
});
```

**Why Not Transactions with Rollback?**
- E2E tests use **deployed Lambdas** that connect to same database
- Lambdas cannot see uncommitted transactions
- Must use physical deletes, not transaction rollback

**Why Order Matters?**
- Foreign key constraint: `events.userId` references `users.id`
- Deleting users first would fail with constraint violation
- Always delete child records (events) before parent records (users)

[Source: docs/architecture/test-strategy.md#Test-Data-Management]
[Source: docs/architecture/database-schema.md#Foreign-Keys]

#### Lambda Invocation Pattern

**Scheduler Lambda Invocation:**

```typescript
const invokeCommand = new InvokeCommand({
  FunctionName: 'event-scheduler',
  Payload: Buffer.from(JSON.stringify({})), // Empty payload (EventBridge trigger)
});

const response = await lambdaClient.send(invokeCommand);

// Verify invocation succeeded
expect(response.StatusCode).toBe(200);
```

**Worker Lambda Invocation:**

```typescript
const sqsEventPayload = {
  Records: [
    {
      body: JSON.stringify({
        eventId: event.id,
        eventType: 'BIRTHDAY',
        idempotencyKey: event.idempotencyKey,
      }),
      messageId: 'test-message-id',
      receiptHandle: 'test-receipt-handle',
    },
  ],
};

const invokeCommand = new InvokeCommand({
  FunctionName: 'event-worker',
  Payload: Buffer.from(JSON.stringify(sqsEventPayload)),
});

const response = await lambdaClient.send(invokeCommand);
expect(response.StatusCode).toBe(200);
```

[Source: src/adapters/primary/lambda/schedulerHandler.e2e.test.ts#66-97]
[Source: docs/architecture/localstack-setup.md#Lambda-Commands]

#### Test Execution Time Budget

**AC 8 Requirement:** Test completes in <30 seconds

**Time Breakdown (Estimated):**

| Operation | Estimated Time |
|-----------|----------------|
| Test setup (Prisma, AWS clients) | 1-2 seconds |
| Create user and event | 0.5 seconds |
| Invoke scheduler Lambda | 3-5 seconds (cold start) |
| Poll SQS queue (long polling) | 5-6 seconds |
| Invoke worker Lambda | 3-5 seconds (cold start) |
| Verify database changes | 0.5 seconds |
| Test teardown | 0.5 seconds |
| **Total** | **14-20 seconds** |

**Optimization Strategies:**

1. **Use Long Polling (WaitTimeSeconds: 5)** - Reduces SQS API calls and total wait time
2. **Parallel Operations** - Use `Promise.all()` where possible (e.g., Lambda invocation + queue polling)
3. **Minimize Database Queries** - Batch queries, avoid N+1 queries
4. **Reuse AWS Clients** - Create clients in `beforeAll`, not per test
5. **Skip Webhook Server** - Avoid starting HTTP server (adds 1-2 seconds)

**Target: 15-25 seconds** (provides headroom for CI/CD variability and Lambda cold starts)

[Source: docs/architecture/test-strategy.md#End-to-End-Tests]

### Testing

#### Test Framework

- **Framework:** Jest 29.7.0
- **Pattern:** AAA (Arrange, Act, Assert) with async/await
- **Timeout:** 30000ms (30 seconds) for E2E tests
- **Coverage:** E2E tests do NOT contribute to code coverage (external process execution)

[Source: docs/architecture/test-strategy.md#Unit-Tests]

#### Test File Location

- **E2E Tests:** `tests/e2e/event-scheduling-flow.e2e.test.ts`
- **Test Helpers:** `tests/helpers/e2e-helpers.ts`

[Source: docs/architecture/source-tree.md#Project-Structure]

#### Test Data Builders

**Not Used for E2E Tests:**

- E2E tests use **real database** and **deployed Lambdas**
- Create data using **Prisma client directly** (not builder pattern)
- Builder pattern useful for unit/integration tests (in-process), not E2E tests (out-of-process)

**Example E2E Test Data Creation:**

```typescript
// Create user with birthday tomorrow
const tomorrow = DateTime.now().plus({ days: 1 });
const user = await prisma.users.create({
  data: {
    id: randomUUID(),
    firstName: 'Jane',
    lastName: 'Doe',
    dateOfBirth: tomorrow.toISODate(), // YYYY-MM-DD format
    timezone: 'America/New_York',
  },
});

// Create event manually (bypass use case for test isolation)
const event = await prisma.events.create({
  data: {
    id: randomUUID(),
    userId: user.id,
    eventType: 'BIRTHDAY',
    status: 'PENDING',
    targetTimestampUTC: DateTime.now().minus({ minutes: 5 }).toJSDate(), // Overdue
    targetTimestampLocal: tomorrow.set({ hour: 9, minute: 0 }).toISO(),
    targetTimezone: 'America/New_York',
    idempotencyKey: `event-${randomUUID()}`,
    deliveryPayload: { message: `Hey, Jane Doe it's your birthday` },
    retryCount: 0,
    version: 1,
  },
});
```

[Source: docs/architecture/test-strategy.md#Test-Data-Management]

#### Key Test Scenarios

**E2E Test (This Story):**
1. Complete scheduling flow: User creation → Event scheduling → Webhook delivery → Next year generation

**Integration Tests (Already Exist):**
- Scheduler Lambda integration tests (Story 2.3)
- Worker Lambda integration tests (Story 2.6)
- ExecuteEventUseCase integration tests (Story 2.5, 2.9)

**Unit Tests (Already Exist):**
- Event state machine unit tests (Story 2.8)
- Next year event generation unit tests (Story 2.9)
- Webhook delivery unit tests (Story 2.4)

[Source: docs/architecture/test-strategy.md#Test-Pyramid]

#### Running E2E Tests

**Prerequisites:**

1. Start Docker environment:
   ```bash
   docker-compose up
   ```

2. Deploy Lambda to LocalStack:
   ```bash
   npm run lambda:all
   ```

**Run E2E Tests:**

```bash
# Run all E2E tests
npm run test:e2e

# Run specific E2E test
npm test -- event-scheduling-flow.e2e.test.ts

# Run with verbose output
npm test -- event-scheduling-flow.e2e.test.ts --verbose
```

**Troubleshooting:**

- **"ResourceNotFoundException"** (Lambda not found) → Run `npm run lambda:all` to deploy Lambda
- **"QueueDoesNotExist"** → Verify LocalStack init-aws.sh ran (`docker logs localstack`)
- **"Can't reach database server"** → Verify PostgreSQL is running (`docker ps`)
- **Timeout after 30 seconds** → Check LocalStack logs for errors (`docker logs localstack`)

[Source: docs/architecture/localstack-troubleshooting.md]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-26 | 1.0 | Created Story 2.10 for End-to-End Scheduling Flow Test | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used

(To be filled by dev agent)

### Implementation Summary

(To be filled by dev agent)

### Changes Made

(To be filled by dev agent)

### File List

(To be filled by dev agent)

---

## QA Results

(To be filled by QA agent after story completion)
