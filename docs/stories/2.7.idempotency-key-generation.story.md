# Story 2.7: Idempotency Key Generation

---

## Status

Approved

---

## Story

**As a** developer,
**I want** unique idempotency keys generated for each event,
**so that** duplicate deliveries are prevented even if executor runs multiple times.

---

## Acceptance Criteria

1. Idempotency key generated when event is created (format: `evt-{eventId}-{timestamp}`)
2. Key stored in events table and included in webhook headers
3. Same key used for all retry attempts of the same event
4. Documentation added explaining idempotency key purpose
5. Unit tests verify key format and uniqueness
6. Integration tests verify webhook receives consistent idempotency key on retries
7. External webhook service (RequestBin) can be configured to respect idempotency keys
8. Logs include idempotency key for request tracing

---

## Tasks / Subtasks

- [ ] **Task 1: Verify IdempotencyKey Value Object Implementation** (AC: 1, 3, 5)
  - [ ] Review `src/modules/event-scheduling/domain/value-objects/IdempotencyKey.ts`
  - [ ] Verify `IdempotencyKey.generate()` creates deterministic keys using SHA-256 hash
  - [ ] Confirm format matches spec: Uses `event-{hash}` pattern (not exact format from AC due to implementation detail)
  - [ ] Verify `IdempotencyKey.fromString()` reconstructs keys from database
  - [ ] Verify tests exist in `IdempotencyKey.test.ts` covering:
    - Key generation produces consistent output for same inputs
    - Keys are unique for different userId/timestamp combinations
    - `equals()` method works correctly
    - `toString()` returns string representation
  - [ ] **Note**: Current implementation uses `event-{sha256_hash_16chars}` instead of `evt-{eventId}-{timestamp}`. The hash-based approach is superior (more secure, consistent length). AC1 format should be updated to match implementation, or accept as implementation deviation with justification.
  - [ ] Reference: [Source: docs/architecture/data-models.md#IdempotencyKey-Value-Object]

- [ ] **Task 2: Verify Idempotency Key Integration in Event Entity** (AC: 1, 2, 3)
  - [ ] Review `src/modules/event-scheduling/domain/entities/Event.ts`
  - [ ] Confirm `idempotencyKey: IdempotencyKey` field exists and is immutable
  - [ ] Verify key is included in Event constructor props
  - [ ] Confirm key remains unchanged through state transitions (claim, markCompleted, markFailed)
  - [ ] Verify tests exist in `Event.test.ts` covering:
    - Event creation includes idempotency key
    - Idempotency key persists through state transitions
  - [ ] Reference: [Source: docs/architecture/data-models.md#Event]

- [ ] **Task 3: Verify Idempotency Key Generation in CreateBirthdayEventUseCase** (AC: 1, 3)
  - [ ] Review `src/modules/event-scheduling/application/use-cases/CreateBirthdayEventUseCase.ts`
  - [ ] Locate where `IdempotencyKey.generate(userId, targetTimestampUTC)` is called
  - [ ] Confirm key is generated once during event creation (line ~98)
  - [ ] Verify key is passed to Event constructor
  - [ ] Verify tests exist in `CreateBirthdayEventUseCase.test.ts` covering:
    - Idempotency key is generated with correct userId and timestamp
    - Same inputs produce same key (deterministic)
  - [ ] Reference: [Source: docs/stories/1.9.birthday-event-creation.story.md]

- [ ] **Task 4: Verify Idempotency Key Persistence in PrismaEventRepository** (AC: 2)
  - [ ] Review `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.ts`
  - [ ] Verify `save()` method persists `idempotencyKey` field to database
  - [ ] Verify `findById()` and other query methods retrieve `idempotencyKey` from database
  - [ ] Verify mapper converts between domain `IdempotencyKey` object and database string
  - [ ] Check `prisma/schema.prisma` confirms `idempotencyKey String @unique` field exists
  - [ ] Verify integration tests exist in `PrismaEventRepository.integration.test.ts` covering:
    - Idempotency key is persisted correctly
    - Idempotency key can be retrieved after persistence
    - Unique constraint prevents duplicate keys
  - [ ] Reference: [Source: docs/architecture/port-interfaces.md#IEventRepository]

- [ ] **Task 5: Verify Idempotency Key in Webhook Headers** (AC: 2, 3, 8)
  - [ ] Review `src/adapters/secondary/delivery/WebhookAdapter.ts`
  - [ ] Locate where `X-Idempotency-Key` header is set (line ~111)
  - [ ] Confirm header value comes from `idempotencyKey` parameter
  - [ ] Verify `ExecuteEventUseCase.ts` passes `event.idempotencyKey.toString()` to WebhookAdapter
  - [ ] Verify tests exist in `WebhookAdapter.test.ts` and/or `ExecuteEventUseCase.test.ts` covering:
    - Webhook request includes `X-Idempotency-Key` header
    - Header value matches event's idempotency key
    - Same idempotency key used on retry attempts
  - [ ] Reference: [Source: docs/stories/2.4.webhook-delivery-adapter.story.md, docs/stories/2.5.event-executor-use-case.story.md]

- [ ] **Task 6: Verify Logging Includes Idempotency Key** (AC: 8)
  - [ ] Review `src/adapters/secondary/delivery/WebhookAdapter.ts` logging statements
  - [ ] Review `src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.ts` logging
  - [ ] Review `src/adapters/primary/lambda/workerHandler.ts` logging
  - [ ] Confirm all log statements related to event execution include `idempotencyKey` field
  - [ ] Verify structured logging format: `{ eventId, idempotencyKey, ... }`
  - [ ] Manually test logging output to verify idempotency key appears in logs
  - [ ] Reference: [Source: docs/architecture/error-handling.md#Logging-Standards]

- [ ] **Task 7: Write Integration Test for Retry Consistency** (AC: 3, 6)
  - [ ] Create or enhance test in `ExecuteEventUseCase.integration.test.ts` or `workerHandler.integration.test.ts`
  - [ ] Test scenario: Event execution fails with `InfrastructureError` (simulated 503)
  - [ ] Verify first attempt sends webhook with `X-Idempotency-Key: event-abc123...`
  - [ ] Simulate retry (SQS redelivers message)
  - [ ] Verify second attempt sends same webhook with identical `X-Idempotency-Key`
  - [ ] Assert: Both requests have identical idempotency keys
  - [ ] Use nock or similar library to capture HTTP headers
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#Integration-Tests]

- [ ] **Task 8: Document Idempotency Key Purpose and Behavior** (AC: 4, 7)
  - [ ] Create or enhance documentation in `docs/architecture/data-models.md#IdempotencyKey`
  - [ ] Explain purpose: Prevents duplicate webhook deliveries during retries
  - [ ] Explain generation algorithm: SHA-256 hash of userId + timestamp + eventType
  - [ ] Explain deterministic behavior: Same inputs always produce same key
  - [ ] Explain usage in webhook headers: `X-Idempotency-Key` sent with every request
  - [ ] Document external webhook service configuration (AC: 7):
    - Explain how RequestBin or webhook.site can be used for testing
    - Document how to verify idempotency key in webhook logs
    - Provide example of checking duplicate requests with same key
    - Include note that actual idempotency enforcement is webhook service's responsibility
  - [ ] Add example of viewing idempotency keys in logs
  - [ ] Reference: [Source: docs/prd/epic-2-event-scheduling-execution.md#Story-2.7]

- [ ] **Task 9: Update AC1 Format Specification (If Needed)** (AC: 1)
  - [ ] Compare current implementation format `event-{sha256_hash}` with AC requirement `evt-{eventId}-{timestamp}`
  - [ ] **Decision Option 1**: Update AC to match implementation: `event-{sha256_hash_16chars}`
  - [ ] **Decision Option 2**: Change implementation to match AC (NOT RECOMMENDED - hash approach is better)
  - [ ] **Recommended**: Option 1 with justification in completion notes:
    - Hash-based approach provides better security (no exposure of internal IDs/timestamps)
    - Consistent key length (24 chars) easier for external systems to handle
    - Still deterministic (same userId+timestamp always produces same key)
    - Still unique (SHA-256 collision probability negligible)
  - [ ] Document decision in story completion notes
  - [ ] If AC updated, add change to Story Change Log

---

## Dev Notes

### Implementation Status

**CRITICAL**: This story is primarily a **verification and documentation story**, not a new implementation story. The IdempotencyKey functionality has already been fully implemented in previous stories (1.9, 2.4, 2.5, 2.6). The tasks focus on:

1. **Verification**: Confirm existing implementation meets acceptance criteria
2. **Testing**: Ensure comprehensive test coverage exists
3. **Documentation**: Document purpose, behavior, and external service configuration

### Previous Story Insights

**From Story 2.6 (Worker Lambda - SQS Consumer):**
- Worker Lambda already includes idempotency key in SQS message processing
- Structured logging includes `idempotencyKey` field for correlation
- Error handling preserves idempotency key through retry attempts

**From Story 2.5 (Event Executor Use Case):**
- `ExecuteEventUseCase` passes idempotency key to WebhookAdapter
- Idempotency key remains consistent across retry attempts
- Use case logs include idempotency key for tracing

**From Story 2.4 (Webhook Delivery Adapter):**
- `WebhookAdapter` sends idempotency key in `X-Idempotency-Key` header
- Header included in all webhook requests (initial + retries)
- Tests verify header is present

**From Story 1.9 (Birthday Event Creation):**
- `CreateBirthdayEventUseCase` generates idempotency key using `IdempotencyKey.generate()`
- Key generated deterministically from userId + targetTimestampUTC + eventType
- Key stored in Event entity and persisted to database

### Architecture Context

#### IdempotencyKey Value Object Location

```
src/modules/event-scheduling/domain/value-objects/IdempotencyKey.ts
src/modules/event-scheduling/domain/value-objects/IdempotencyKey.test.ts
```

[Source: docs/architecture/source-tree.md#Value-Objects]

#### IdempotencyKey Implementation Details

**Current Implementation** (from `IdempotencyKey.ts`):

```typescript
public static generate(userId: string, targetTimestampUTC: DateTime): IdempotencyKey {
  const keyData = `${userId}-${targetTimestampUTC.toISO()}-BIRTHDAY`;
  const hash = createHash('sha256').update(keyData).digest('hex');
  return new IdempotencyKey(`event-${hash.substring(0, 16)}`);
}
```

**Key Format**: `event-{16_char_sha256_hash}`

**Example**: `event-a1b2c3d4e5f6g7h8`

**Note**: AC1 specifies format `evt-{eventId}-{timestamp}`, but implementation uses SHA-256 hash. Hash approach is superior:
- **Security**: Doesn't expose internal event IDs or timestamps
- **Consistency**: Fixed 24-character length
- **Determinism**: Same inputs always produce same key
- **Uniqueness**: SHA-256 collision probability negligible

**Recommendation**: Update AC1 to match implementation or document as acceptable deviation.

[Source: docs/architecture/data-models.md#IdempotencyKey-Value-Object]

#### Event Entity Integration

**Event Entity** includes `idempotencyKey: IdempotencyKey` field:

```typescript
export class Event {
  public readonly idempotencyKey: IdempotencyKey;
  // ... other fields
}
```

**Immutability**: Idempotency key never changes once event is created. Persists through all state transitions (PENDING → PROCESSING → COMPLETED/FAILED).

[Source: docs/architecture/data-models.md#Event]

#### Webhook Header Usage

**WebhookAdapter** sends idempotency key in HTTP header:

```typescript
headers: {
  'Content-Type': 'application/json',
  'X-Idempotency-Key': idempotencyKey,
},
```

**External Service Responsibility**: The webhook service (e.g., RequestBin, webhook.site, or production endpoint) is responsible for:
- Recognizing the `X-Idempotency-Key` header
- Storing processed request IDs to detect duplicates
- Returning success for duplicate requests without re-processing

**System's Responsibility**: Generate and send consistent key on retries.

[Source: docs/stories/2.4.webhook-delivery-adapter.story.md]

#### Database Schema

**Prisma Schema** (from `prisma/schema.prisma`):

```prisma
model Event {
  idempotencyKey       String      @unique @map("idempotency_key") @db.VarChar(255)
  // ... other fields
}
```

**Unique Constraint**: Ensures no two events can have the same idempotency key.

[Source: docs/architecture/database-schema.md]

#### Logging Standards

**Structured Logging with Pino** (from Story 1.11c):

All event execution logs MUST include:
- `eventId` - Event identifier
- `idempotencyKey` - For request tracing and correlation
- `userId` - User identifier
- `targetTimestampUTC` - Scheduled execution time

**Example Log Statement**:

```typescript
logger.info({
  msg: 'Executing event',
  eventId: event.id,
  idempotencyKey: event.idempotencyKey.toString(),
  userId: event.userId,
});
```

[Source: docs/architecture/error-handling.md#Logging-Standards, docs/stories/1.11c.implement-structured-logging.story.md]

### Testing

#### Test Framework

- **Framework**: Jest 29.7.0
- **Pattern**: AAA (Arrange, Act, Assert)
- **Coverage**: ≥80% for value objects and use cases

[Source: docs/architecture/test-strategy.md#Unit-Tests]

#### Unit Test Locations

```
src/modules/event-scheduling/domain/value-objects/IdempotencyKey.test.ts
src/modules/event-scheduling/domain/entities/Event.test.ts
src/modules/event-scheduling/application/use-cases/CreateBirthdayEventUseCase.test.ts
src/adapters/secondary/delivery/WebhookAdapter.test.ts
src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.test.ts
```

[Source: docs/architecture/test-strategy.md#Test-Naming-Conventions]

#### Integration Test Locations

```
src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.integration.test.ts
src/adapters/secondary/delivery/WebhookAdapter.integration.test.ts (if exists)
src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.integration.test.ts (create if needed)
src/adapters/primary/lambda/workerHandler.integration.test.ts
```

**New Test Required** (Task 7): Create integration test verifying consistent idempotency key on retry attempts.

[Source: docs/architecture/test-strategy.md#Integration-Tests]

#### Test Scenarios to Verify

**Unit Tests:**
1. `IdempotencyKey.generate()` produces deterministic keys
2. Same userId + timestamp → same key
3. Different userId or timestamp → different key
4. Key format matches `event-{hash}` pattern
5. `IdempotencyKey.fromString()` reconstructs keys correctly
6. `equals()` method works correctly

**Integration Tests:**
7. Idempotency key persisted to database
8. Idempotency key retrieved from database matches original
9. Unique constraint prevents duplicate keys
10. Webhook receives `X-Idempotency-Key` header with correct value
11. Retry attempts send same idempotency key (NEW - Task 7)

[Source: docs/architecture/test-strategy.md#AI-Agent-Requirements]

### External Webhook Service Configuration

**Purpose**: Verify idempotency key behavior with external webhook endpoints.

**Test Services** (for development/testing):
- **RequestBin** (https://requestbin.com)
  - Free service for inspecting HTTP requests
  - Shows all headers including `X-Idempotency-Key`
  - Can manually verify duplicate requests with same key
- **webhook.site** (https://webhook.site)
  - Alternative to RequestBin
  - Similar functionality
  - Real-time request inspection

**Configuration** (from `.env.example`):

```bash
WEBHOOK_TEST_URL=https://your-requestbin-url.requestbin.com/endpoint
```

**Testing Workflow**:
1. Create RequestBin endpoint
2. Set `WEBHOOK_TEST_URL` to RequestBin URL
3. Run integration tests or manual test
4. View requests in RequestBin dashboard
5. Verify `X-Idempotency-Key` header is present and consistent on retries

**Note**: RequestBin and webhook.site do NOT enforce idempotency automatically. They are testing tools for verifying our system sends the correct headers. Production webhook endpoints must implement their own idempotency logic using the `X-Idempotency-Key` header.

[Source: docs/stories/2.4.webhook-delivery-adapter.story.md, docs/prd/epic-2-event-scheduling-execution.md#Story-2.7]

### Documentation Location

**Target Document**: `docs/architecture/data-models.md#IdempotencyKey-Value-Object`

**Content to Add/Enhance** (Task 8):
- Purpose explanation
- Generation algorithm (SHA-256 hash)
- Deterministic behavior
- Webhook header usage
- External service configuration examples
- Example of viewing keys in logs

[Source: docs/architecture/data-models.md]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-25 | 1.0 | Created story for Idempotency Key Generation verification and documentation | Bob (Scrum Master) |
| 2025-10-25 | 1.1 | Story approved - ready for development | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes

_To be populated by dev agent_

### Files Created/Modified

_To be populated by dev agent_

---

## QA Results

_To be populated by QA agent_
