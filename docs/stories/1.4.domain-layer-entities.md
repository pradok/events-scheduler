# Story 1.4: Domain Layer - User & Event Entities

---

## Status

**Draft**

---

## Story

**As a** developer,
**I want** pure domain entities for User and Event with business logic,
**so that** the core domain model is independent of infrastructure concerns.

---

## Acceptance Criteria

1. User entity created in `src/domain/entities/User.ts` with no external dependencies
2. Event entity created in `src/domain/entities/Event.ts` with status state machine
3. Value objects created: Timezone, DateOfBirth, EventStatus (in `src/domain/value-objects/`)
4. User entity validates: firstName/lastName not empty, dateOfBirth not in future, timezone is valid IANA
5. Event entity enforces valid state transitions (PENDING → PROCESSING → COMPLETED/FAILED)
6. Domain entities are immutable (use methods that return new instances for changes)
7. Unit tests achieve 100% coverage for domain entities and value objects
8. All domain code has zero imports from Fastify, Prisma, AWS, or infrastructure layers

---

## Tasks / Subtasks

- [ ] **Task 1: Create domain directory structure** (AC: 1, 2, 3)
  - [ ] Create `src/domain/` directory
  - [ ] Create `src/domain/entities/` subdirectory
  - [ ] Create `src/domain/value-objects/` subdirectory
  - [ ] Create `src/domain/errors/` subdirectory

- [ ] **Task 2: Create base domain error classes** (AC: 1, 4, 5)
  - [ ] Create `src/domain/errors/DomainError.ts` base class extending Error
  - [ ] Create `src/domain/errors/InvalidTimezoneError.ts`
  - [ ] Create `src/domain/errors/InvalidDateOfBirthError.ts`
  - [ ] Create `src/domain/errors/InvalidStateTransitionError.ts`
  - [ ] Create `src/domain/errors/ValidationError.ts`

- [ ] **Task 3: Create Timezone value object** (AC: 3, 4)
  - [ ] Create `src/domain/value-objects/Timezone.ts`
  - [ ] Implement constructor with IANA timezone validation
  - [ ] Implement `static isValid(tz: string): boolean` method using Luxon
  - [ ] Implement `toString(): string` method
  - [ ] Implement `equals(other: Timezone): boolean` method
  - [ ] Throw InvalidTimezoneError for invalid timezones
  - [ ] Make class immutable (readonly value property)

- [ ] **Task 4: Create EventStatus value object** (AC: 3, 5)
  - [ ] Create `src/domain/value-objects/EventStatus.ts` as enum
  - [ ] Define PENDING, PROCESSING, COMPLETED, FAILED states
  - [ ] Create `isValidTransition(from: EventStatus, to: EventStatus): boolean` static method
  - [ ] Implement state machine logic: PENDING → PROCESSING → (COMPLETED | FAILED)
  - [ ] Prevent transitions from COMPLETED/FAILED to any other state

- [ ] **Task 5: Create DateOfBirth value object** (AC: 3, 4)
  - [ ] Create `src/domain/value-objects/DateOfBirth.ts`
  - [ ] Implement constructor accepting ISO date string (YYYY-MM-DD)
  - [ ] Validate date format using Luxon DateTime.fromISO()
  - [ ] Validate date is not in future (compare with DateTime.now())
  - [ ] Implement `getMonthDay(): { month: number; day: number }` method
  - [ ] Implement `calculateNextOccurrence(timezone: Timezone, referenceDate: DateTime): DateTime` method
  - [ ] Implement `toString(): string` method returning ISO date
  - [ ] Throw InvalidDateOfBirthError for invalid dates
  - [ ] Make class immutable (readonly value property)

- [ ] **Task 6: Create User entity** (AC: 1, 4, 6)
  - [ ] Create `src/domain/entities/User.ts`
  - [ ] Define User constructor accepting: id, firstName, lastName, dateOfBirth, timezone, createdAt, updatedAt
  - [ ] Use value objects: DateOfBirth for dateOfBirth, Timezone for timezone
  - [ ] Validate firstName is not empty (1-100 characters)
  - [ ] Validate lastName is not empty (1-100 characters)
  - [ ] Make all properties readonly (immutability)
  - [ ] Implement `calculateNextBirthday(currentDate: DateTime): DateTime` method
  - [ ] Implement `updateTimezone(newTimezone: Timezone): User` returning new instance
  - [ ] Implement `updateName(firstName: string, lastName: string): User` returning new instance
  - [ ] Throw ValidationError for validation failures

- [ ] **Task 7: Create IdempotencyKey value object** (AC: 2)
  - [ ] Create `src/domain/value-objects/IdempotencyKey.ts`
  - [ ] Implement private constructor
  - [ ] Implement `static generate(userId: string, targetTimestampUTC: DateTime): IdempotencyKey`
  - [ ] Use deterministic hash: SHA-256(userId + targetTimestampUTC + eventType)
  - [ ] Format: `event-{hash_substring}`
  - [ ] Implement `toString(): string` method
  - [ ] Implement `equals(other: IdempotencyKey): boolean` method
  - [ ] Make class immutable

- [ ] **Task 8: Create Event entity** (AC: 2, 5, 6)
  - [ ] Create `src/domain/entities/Event.ts`
  - [ ] Define Event constructor accepting all 15 properties from data model
  - [ ] Use EventStatus enum for status property
  - [ ] Use IdempotencyKey value object for idempotencyKey
  - [ ] Make all properties readonly (immutability)
  - [ ] Implement `claim(): Event` method (PENDING → PROCESSING, returns new instance)
  - [ ] Implement `markCompleted(executedAt: DateTime): Event` method (PROCESSING → COMPLETED)
  - [ ] Implement `markFailed(reason: string): Event` method (PROCESSING → FAILED, increments retryCount)
  - [ ] Implement `canRetry(): boolean` method (retryCount < 3 && status === FAILED)
  - [ ] Validate state transitions using EventStatus.isValidTransition()
  - [ ] Throw InvalidStateTransitionError for invalid transitions
  - [ ] Increment version on all state changes (optimistic locking)

- [ ] **Task 9: Write unit tests for Timezone value object** (AC: 7)
  - [ ] Create `tests/unit/domain/value-objects/Timezone.test.ts`
  - [ ] Test valid IANA timezones (America/New_York, Europe/London, Asia/Tokyo)
  - [ ] Test invalid timezone throws InvalidTimezoneError
  - [ ] Test toString() returns original string
  - [ ] Test equals() for same and different timezones
  - [ ] Achieve 100% code coverage

- [ ] **Task 10: Write unit tests for EventStatus value object** (AC: 7)
  - [ ] Create `tests/unit/domain/value-objects/EventStatus.test.ts`
  - [ ] Test valid transitions: PENDING → PROCESSING
  - [ ] Test valid transitions: PROCESSING → COMPLETED
  - [ ] Test valid transitions: PROCESSING → FAILED
  - [ ] Test invalid transition: PENDING → COMPLETED (skip PROCESSING)
  - [ ] Test invalid transition: COMPLETED → PENDING
  - [ ] Test invalid transition: FAILED → PENDING
  - [ ] Achieve 100% code coverage

- [ ] **Task 11: Write unit tests for DateOfBirth value object** (AC: 7)
  - [ ] Create `tests/unit/domain/value-objects/DateOfBirth.test.ts`
  - [ ] Test valid past date creates instance
  - [ ] Test future date throws InvalidDateOfBirthError
  - [ ] Test invalid date format throws error
  - [ ] Test getMonthDay() returns correct month and day
  - [ ] Test calculateNextOccurrence() for birthday not yet passed this year
  - [ ] Test calculateNextOccurrence() for birthday already passed this year
  - [ ] Test leap year birthday (Feb 29) handling
  - [ ] Test toString() returns ISO date format
  - [ ] Achieve 100% code coverage

- [ ] **Task 12: Write unit tests for IdempotencyKey value object** (AC: 7)
  - [ ] Create `tests/unit/domain/value-objects/IdempotencyKey.test.ts`
  - [ ] Test generate() creates key with correct format
  - [ ] Test same inputs produce same key (deterministic)
  - [ ] Test different inputs produce different keys
  - [ ] Test toString() returns key string
  - [ ] Test equals() for same and different keys
  - [ ] Achieve 100% code coverage

- [ ] **Task 13: Write unit tests for User entity** (AC: 7)
  - [ ] Create `tests/unit/domain/entities/User.test.ts`
  - [ ] Test User creation with valid data
  - [ ] Test empty firstName throws ValidationError
  - [ ] Test empty lastName throws ValidationError
  - [ ] Test firstName >100 chars throws ValidationError
  - [ ] Test lastName >100 chars throws ValidationError
  - [ ] Test invalid timezone throws InvalidTimezoneError
  - [ ] Test future dateOfBirth throws InvalidDateOfBirthError
  - [ ] Test calculateNextBirthday() when birthday hasn't passed
  - [ ] Test calculateNextBirthday() when birthday has passed
  - [ ] Test updateTimezone() returns new User instance
  - [ ] Test updateName() returns new User instance
  - [ ] Test immutability (original instance unchanged after updates)
  - [ ] Achieve 100% code coverage

- [ ] **Task 14: Write unit tests for Event entity** (AC: 7)
  - [ ] Create `tests/unit/domain/entities/Event.test.ts`
  - [ ] Test Event creation with valid data
  - [ ] Test claim() transitions PENDING → PROCESSING
  - [ ] Test claim() throws error if not PENDING
  - [ ] Test claim() increments version
  - [ ] Test markCompleted() transitions PROCESSING → COMPLETED
  - [ ] Test markCompleted() throws error if not PROCESSING
  - [ ] Test markCompleted() sets executedAt timestamp
  - [ ] Test markFailed() transitions PROCESSING → FAILED
  - [ ] Test markFailed() increments retryCount
  - [ ] Test markFailed() sets failureReason
  - [ ] Test canRetry() returns true when retryCount < 3
  - [ ] Test canRetry() returns false when retryCount >= 3
  - [ ] Test canRetry() returns false when status !== FAILED
  - [ ] Test immutability (original instance unchanged after state changes)
  - [ ] Test version increments on all state changes
  - [ ] Achieve 100% code coverage

- [ ] **Task 15: Verify domain layer purity** (AC: 8)
  - [ ] Run ESLint to check no imports from Fastify, Prisma, AWS
  - [ ] Verify only Luxon (for DateTime) and Node crypto (for hashing) are imported
  - [ ] Verify zero imports from `src/adapters/` or `src/application/`
  - [ ] Verify all tests pass
  - [ ] Verify coverage is 100% for domain layer

---

## Dev Notes

### Previous Story Insights

**Source:** [docs/stories/1.3.database-schema-prisma.md](1.3.database-schema-prisma.md)

- Prisma schema defines User and Event models with all fields
- EventStatus enum already defined in Prisma: PENDING, PROCESSING, COMPLETED, FAILED
- Database uses UUID for primary keys
- Timestamps use TIMESTAMPTZ (timezone-aware)
- Version field exists for optimistic locking
- IdempotencyKey is unique string field

### Data Models & Business Rules

**Source:** [docs/architecture/data-models.md](../architecture/data-models.md)

**User Entity:**
- Attributes: id (UUID), firstName (1-100 chars), lastName (1-100 chars), dateOfBirth (DateOfBirth value object), timezone (Timezone value object), createdAt, updatedAt
- Business Invariants:
  - First name and last name cannot be empty
  - Date of birth must be in the past
  - Timezone must be valid IANA identifier
- Domain Behaviors:
  - `calculateNextBirthday(currentDate: DateTime): DateTime` - Calculates next birthday occurrence in user's timezone
  - `updateTimezone(newTimezone: Timezone): User` - Returns new User instance with updated timezone (immutability)

**Event Entity:**
- Attributes: id (UUID), userId (UUID), eventType (string), status (EventStatus enum), targetTimestampUTC (DateTime), targetTimestampLocal (DateTime), targetTimezone (string), executedAt (DateTime | null), failureReason (string | null), retryCount (number, max 3), version (number), idempotencyKey (IdempotencyKey), deliveryPayload (JSON), createdAt, updatedAt
- Business Invariants:
  - Status transitions: PENDING → PROCESSING → (COMPLETED | FAILED)
  - Cannot transition from COMPLETED or FAILED back to PENDING
  - Cannot skip states (e.g., PENDING → COMPLETED without PROCESSING)
  - Retry count cannot exceed 3
  - Version must increment on every update
- Domain Behaviors:
  - `claim(): Event` - Transitions PENDING → PROCESSING (atomically)
  - `markCompleted(executedAt: DateTime): Event` - Transitions to COMPLETED
  - `markFailed(reason: string): Event` - Transitions to FAILED, increments retryCount
  - `canRetry(): boolean` - Returns true if retryCount < 3 and status === FAILED

**Timezone Value Object:**
```typescript
class Timezone {
  private readonly value: string;

  constructor(value: string) {
    if (!Timezone.isValid(value)) {
      throw new InvalidTimezoneError(value);
    }
    this.value = value;
  }

  static isValid(tz: string): boolean {
    // Use Luxon to validate IANA timezone
    try {
      DateTime.local().setZone(tz);
      return true;
    } catch {
      return false;
    }
  }

  toString(): string {
    return this.value;
  }

  equals(other: Timezone): boolean {
    return this.value === other.value;
  }
}
```

**DateOfBirth Value Object:**
```typescript
class DateOfBirth {
  private readonly value: DateTime; // Luxon DateTime

  constructor(dateString: string) {
    const parsed = DateTime.fromISO(dateString);
    if (!parsed.isValid) {
      throw new InvalidDateOfBirthError(dateString);
    }
    if (parsed > DateTime.now()) {
      throw new DateOfBirthInFutureError(dateString);
    }
    this.value = parsed;
  }

  getMonthDay(): { month: number; day: number } {
    return { month: this.value.month, day: this.value.day };
  }

  calculateNextOccurrence(timezone: Timezone, referenceDate: DateTime): DateTime {
    // Calculate next birthday in user's timezone
    const { month, day } = this.getMonthDay();
    let nextBirthday = referenceDate.setZone(timezone.toString()).set({ month, day });
    if (nextBirthday < referenceDate) {
      nextBirthday = nextBirthday.plus({ years: 1 });
    }
    return nextBirthday;
  }

  toString(): string {
    return this.value.toISODate(); // YYYY-MM-DD
  }
}
```

**IdempotencyKey Value Object:**
```typescript
import { createHash } from 'crypto';

class IdempotencyKey {
  private readonly value: string;

  private constructor(value: string) {
    this.value = value;
  }

  static generate(userId: string, targetTimestampUTC: DateTime): IdempotencyKey {
    const keyData = `${userId}-${targetTimestampUTC.toISO()}-BIRTHDAY`;
    const hash = createHash('sha256').update(keyData).digest('hex');
    return new IdempotencyKey(`event-${hash.substring(0, 16)}`);
  }

  toString(): string {
    return this.value;
  }

  equals(other: IdempotencyKey): boolean {
    return this.value === other.value;
  }
}
```

**EventStatus Enum & State Machine:**
```typescript
enum EventStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED'
}

// Valid transitions
const VALID_TRANSITIONS = {
  [EventStatus.PENDING]: [EventStatus.PROCESSING],
  [EventStatus.PROCESSING]: [EventStatus.COMPLETED, EventStatus.FAILED],
  [EventStatus.COMPLETED]: [],
  [EventStatus.FAILED]: []
};

function isValidTransition(from: EventStatus, to: EventStatus): boolean {
  return VALID_TRANSITIONS[from]?.includes(to) ?? false;
}
```

### Project Structure

**Source:** [docs/architecture/source-tree.md](../architecture/source-tree.md)

**Domain Layer Structure:**
```
src/domain/
├── entities/
│   ├── User.ts
│   ├── Event.ts
│   ├── User.test.ts (colocated tests - optional)
│   └── Event.test.ts (colocated tests - optional)
├── value-objects/
│   ├── Timezone.ts
│   ├── DateOfBirth.ts
│   ├── EventStatus.ts
│   └── IdempotencyKey.ts
└── errors/
    ├── DomainError.ts
    ├── InvalidTimezoneError.ts
    ├── InvalidDateOfBirthError.ts
    ├── InvalidStateTransitionError.ts
    └── ValidationError.ts
```

**Test Structure (if using separate tests/ directory):**
```
tests/unit/domain/
├── entities/
│   ├── User.test.ts
│   └── Event.test.ts
└── value-objects/
    ├── Timezone.test.ts
    ├── DateOfBirth.test.ts
    ├── EventStatus.test.ts
    └── IdempotencyKey.test.ts
```

### Coding Standards

**Source:** [docs/architecture/coding-standards.md](../architecture/coding-standards.md)

**Critical Rules for Domain Layer:**

1. **No `any` Types**: TypeScript strict mode enabled, explicit typing required for all function signatures
2. **Domain Layer Purity**: Zero imports from `src/adapters/`, `src/application/`, or infrastructure (Fastify, Prisma, AWS). Only imports allowed:
   - Luxon (for DateTime, timezone handling)
   - Node crypto (for hashing)
   - Other domain files (entities, value objects, errors)
3. **Immutability**: All domain entities must be immutable. Methods that "change" state must return new instances
4. **Value Objects for Validation**: Encapsulate validation in value objects (Timezone, DateOfBirth), not primitive types
5. **Error Handling**: Use custom domain error classes extending DomainError base class

**Naming Conventions:**
- Classes: PascalCase (User, Event, Timezone, DateOfBirth)
- Methods: camelCase (calculateNextBirthday, markCompleted)
- Constants: UPPER_SNAKE_CASE (VALID_TRANSITIONS, MAX_RETRY_COUNT)
- Files: PascalCase for domain (User.ts, Event.ts)

**Dependencies:**
- **Luxon 3.4.4**: DateTime and timezone handling
- **Node crypto**: Built-in (for SHA-256 hashing in IdempotencyKey)

### Testing Requirements

**Source:** [docs/architecture/test-strategy.md](../architecture/test-strategy.md)

**Framework:** Jest 29.7.0

**Test File Convention:** `{SourceFileName}.test.ts` (e.g., `User.test.ts`, `Timezone.test.ts`)

**Test Location:** Either:
- Colocated: `src/domain/entities/User.test.ts` (next to User.ts)
- Separate: `tests/unit/domain/entities/User.test.ts`

**Coverage Requirement:** 100% for domain entities and value objects (critical business logic)

**Test Pattern:** AAA (Arrange, Act, Assert)

**Mocking:** Not needed for domain layer (pure functions, no dependencies)

**Test Structure Example:**
```typescript
describe('User', () => {
  describe('calculateNextBirthday', () => {
    it('should calculate next birthday in same year when birthday has not passed', () => {
      // Arrange
      const user = new User({
        id: randomUUID(),
        firstName: 'John',
        lastName: 'Doe',
        dateOfBirth: new DateOfBirth('1990-03-15'),
        timezone: new Timezone('America/New_York'),
        createdAt: DateTime.now(),
        updatedAt: DateTime.now()
      });
      const referenceDate = DateTime.fromISO('2025-01-01');

      // Act
      const nextBirthday = user.calculateNextBirthday(referenceDate);

      // Assert
      expect(nextBirthday.toISODate()).toBe('2025-03-15');
    });
  });
});
```

**Key Test Cases to Cover:**
- Valid inputs create instances successfully
- Invalid inputs throw appropriate errors
- Validation logic works correctly (empty strings, future dates, invalid timezones)
- State transitions follow state machine rules
- Immutability is enforced (methods return new instances)
- Edge cases: leap years (Feb 29), timezone conversions, state machine edge cases
- Boundary conditions: 100-char limits, retry count = 3

### Design Patterns

**Source:** [docs/architecture/design-patterns.md](../architecture/design-patterns.md)

**Patterns NOT Used in Story 1.4 (Future Stories):**
- Strategy Pattern (Event Handlers) - Story 1.5+
- Factory Pattern (Event Factory) - Story 1.5+
- Observer Pattern (Event Observers) - Story 1.8+
- Specification Pattern (Query Specs) - Story 1.7+
- Builder Pattern (Test Builders) - Story 1.7+

**Patterns Used in Story 1.4:**
- **Value Objects (DDD)**: Timezone, DateOfBirth, EventStatus, IdempotencyKey
- **Immutability**: All entities return new instances on updates
- **State Machine**: EventStatus enforces valid state transitions

**Entity Immutability Example:**
```typescript
class User {
  private constructor(
    public readonly id: string,
    public readonly firstName: string,
    public readonly lastName: string,
    public readonly dateOfBirth: DateOfBirth,
    public readonly timezone: Timezone,
    public readonly createdAt: DateTime,
    public readonly updatedAt: DateTime
  ) {}

  updateTimezone(newTimezone: Timezone): User {
    return new User(
      this.id,
      this.firstName,
      this.lastName,
      this.dateOfBirth,
      newTimezone, // Updated
      this.createdAt,
      DateTime.now() // New updatedAt
    );
  }
}
```

### Key Implementation Notes

1. **Luxon DateTime Usage**: All date/time handling must use Luxon DateTime, not native JavaScript Date. This provides timezone-aware operations.

2. **Value Object Validation**: Validation happens in value object constructors. Once constructed, value objects are guaranteed valid.

3. **Entity Constructors**: Entities should have constructor that accepts all required properties. Validation happens via value objects.

4. **Immutability Pattern**: All entity methods that modify state return new instances using spread operator or explicit constructor calls.

5. **State Machine Enforcement**: Event status transitions must validate using EventStatus.isValidTransition() before applying changes.

6. **Error Classes**: Create specific error classes for each validation scenario. All domain errors extend DomainError base class.

7. **No Infrastructure Dependencies**: Domain layer is pure TypeScript + Luxon. No Prisma, no Fastify, no AWS SDK, no database clients.

8. **Test Coverage**: Unit tests must cover all public methods, all validation rules, all state transitions, and all edge cases. Aim for 100% coverage.

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story creation from Epic 1 | Scrum Master Agent (Bob) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

### Debug Log References

### Completion Notes

### File List

**Created:**
**Modified:**
**Deleted:**

---

## QA Results

*This section will be populated by the QA agent after implementation review.*
