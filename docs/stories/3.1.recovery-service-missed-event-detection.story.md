# Story 3.1: Recovery Service - Missed Event Detection

---

## Status

Approved

---

## Story

**As a** developer,
**I want** a recovery service that automatically detects missed events on startup,
**so that** events missed during downtime are identified without manual intervention.

---

## Acceptance Criteria

1. RecoveryService created in `src/application/use-cases/RecoveryService.ts`
2. Service queries events where `targetTimestampUTC < NOW() AND status = 'PENDING'`
3. Query ordered by targetTimestampUTC ASC (oldest events first)
4. Query limited to 1000 events per recovery batch to prevent overflow
5. Service logs total count of missed events found
6. Service logs oldest and newest missed event timestamps
7. Unit tests verify query logic with various downtime scenarios
8. Integration tests verify missed events detected correctly

---

## Tasks / Subtasks

- [ ] **Task 1: Create RecoveryService Use Case** (AC: 1)
  - [ ] Create file `src/application/use-cases/RecoveryService.ts`
  - [ ] Implement constructor accepting `IEventRepository` and `ILogger` dependencies
  - [ ] Add explicit accessibility modifiers for all class members (required by coding standards)
  - [ ] Follow use case pattern from existing ExecuteEventUseCase
  - [ ] Reference: [Source: docs/architecture/source-tree.md#Use-Cases]
  - [ ] Reference: [Source: docs/architecture/coding-standards.md#3-explicit-accessibility-modifiers]

- [ ] **Task 2: Implement findMissedEvents() Query Method** (AC: 2, 3, 4)
  - [ ] Create private method `findMissedEvents()` in RecoveryService
  - [ ] Query events with: `status = 'PENDING' AND targetTimestampUTC < NOW()`
  - [ ] Order by `targetTimestampUTC ASC` (oldest first - fair recovery order)
  - [ ] Limit results to 1000 events per batch (configurable constant `MAX_RECOVERY_BATCH_SIZE`)
  - [ ] Use IEventRepository port interface (NOT direct Prisma calls)
  - [ ] Consider adding `findMissedEvents(limit: number): Promise<Event[]>` method to IEventRepository
  - [ ] Reference: [Source: docs/architecture/port-interfaces.md#IEventRepository]
  - [ ] Reference: [Source: docs/architecture/data-models.md#Event]

- [ ] **Task 3: Implement execute() Method with Logging** (AC: 5, 6)
  - [ ] Create public async `execute(): Promise<RecoveryResult>` method
  - [ ] Call findMissedEvents() to retrieve missed events
  - [ ] If no events found, log: "No missed events found" and return early
  - [ ] If events found, log total count: `logger.info('Missed events found', { count: events.length })`
  - [ ] Calculate and log oldest event timestamp: `events[0].targetTimestampUTC` (array is ASC sorted)
  - [ ] Calculate and log newest event timestamp: `events[events.length - 1].targetTimestampUTC`
  - [ ] Return `RecoveryResult` object with count and event IDs
  - [ ] Use Pino structured logging (NOT console.log)
  - [ ] Reference: [Source: docs/architecture/coding-standards.md#1-no-consolelog-in-production]
  - [ ] Reference: [Source: docs/architecture/tech-stack.md#Pino-Over-Winston]

- [ ] **Task 4: Define RecoveryResult Type** (AC: 1)
  - [ ] Create `RecoveryResult` interface in RecoveryService.ts
  - [ ] Properties: `missedEventsCount: number`, `oldestEventTimestamp: DateTime | null`, `newestEventTimestamp: DateTime | null`
  - [ ] Use Luxon DateTime for timestamp types
  - [ ] Export type for testing
  - [ ] Reference: [Source: docs/architecture/tech-stack.md#Date-Time-Luxon]

- [ ] **Task 5: Add Method to IEventRepository for Finding Missed Events** (AC: 2)
  - [ ] Open `src/modules/event-scheduling/application/ports/IEventRepository.ts`
  - [ ] Add method signature: `findMissedEvents(limit: number): Promise<Event[]>`
  - [ ] Document contract: Returns PENDING events with targetTimestampUTC < NOW(), ordered oldest first
  - [ ] Reference: [Source: docs/architecture/port-interfaces.md#IEventRepository]

- [ ] **Task 6: Implement findMissedEvents() in PrismaEventRepository** (AC: 2, 3, 4)
  - [ ] Open `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.ts`
  - [ ] Implement `findMissedEvents(limit: number): Promise<Event[]>`
  - [ ] Use Prisma query builder (NOT raw SQL unless required for performance)
  - [ ] Query: `where: { status: 'PENDING', targetTimestampUTC: { lt: new Date() } }`
  - [ ] Order: `orderBy: { targetTimestampUTC: 'asc' }`
  - [ ] Limit: `take: limit`
  - [ ] Map results using existing `eventToDomain()` mapper
  - [ ] Reference: [Source: docs/architecture/coding-standards.md#5-raw-sql-usage-in-prisma-repositories]
  - [ ] Reference: [Source: docs/architecture/port-interfaces.md#IEventRepository]

- [ ] **Task 7: Write Unit Tests for RecoveryService** (AC: 7)
  - [ ] Create file `src/application/use-cases/RecoveryService.test.ts`
  - [ ] Mock IEventRepository using Jest mocks
  - [ ] Mock ILogger using Jest mocks
  - [ ] Test: `should return zero count when no missed events exist`
  - [ ] Test: `should detect and log missed events with correct timestamps`
  - [ ] Test: `should respect batch limit of 1000 events`
  - [ ] Test: `should handle various downtime scenarios (1 hour, 1 day, 1 week)`
  - [ ] Test: `should return events ordered by targetTimestampUTC ASC`
  - [ ] Test: `should log oldest and newest event timestamps`
  - [ ] Use AAA pattern (Arrange, Act, Assert)
  - [ ] Follow EventBuilder pattern for test data creation
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#Unit-Tests]
  - [ ] Reference: [Source: docs/architecture/design-patterns.md#6-builder-pattern]

- [ ] **Task 8: Write Integration Tests for findMissedEvents()** (AC: 8)
  - [ ] Create or extend `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.integration.test.ts`
  - [ ] Test: `should find events with targetTimestampUTC in the past and PENDING status`
  - [ ] Test: `should exclude PROCESSING, COMPLETED, and FAILED events from results`
  - [ ] Test: `should return events ordered by targetTimestampUTC ASC`
  - [ ] Test: `should respect batch limit parameter`
  - [ ] Test: `should return empty array when no missed events exist`
  - [ ] Use real PostgreSQL database (Testcontainers pattern)
  - [ ] Clean up test data in `afterEach` hook
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#Integration-Tests]

- [ ] **Task 9: Run All Tests and Verify Coverage** (AC: 7, 8)
  - [ ] Run unit tests: `npm run test:unit`
  - [ ] Run integration tests: `npm run test:integration`
  - [ ] Verify all tests pass
  - [ ] Verify code coverage >= 80% for RecoveryService
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#Coverage-Goals]

---

## Dev Notes

### Important Context from Previous Stories

**Story 2.11 - LocalStack Configuration:**
- LocalStack uses `events-queue` (not `bday-events-queue`) for SQS queue name
- Integration tests create isolated test queues with timestamp-based names
- Two-step LocalStack setup: docker-compose (static infra) then deploy-lambda.js (dynamic resources)

**Story 2.10 - End-to-End Scheduling:**
- Scheduler Lambda invoked via `LambdaClient.send(new InvokeCommand({ FunctionName: 'event-scheduler', Payload: '{}' }))`
- Events transition: PENDING → PROCESSING → COMPLETED/FAILED
- Version field increments on each state transition (optimistic locking)

**Story 2.1 - Event Scheduler Polling:**
- Scheduler queries: `targetTimestampUTC <= NOW() AND status = 'PENDING'`
- Uses `FOR UPDATE SKIP LOCKED` for atomic claiming (prevents race conditions)
- Batch size limited to 100 events per poll

### Data Models

**Event Entity** [Source: docs/architecture/data-models.md#Event]

Key attributes for recovery:
- `targetTimestampUTC: DateTime` - When event should execute (UTC, indexed)
- `status: EventStatus` - Current lifecycle state (PENDING, PROCESSING, COMPLETED, FAILED)
- `createdAt: DateTime` - When event was created
- `userId: UUID` - Foreign key to User

**EventStatus Enum** [Source: docs/architecture/data-models.md#EventStatus]

States:
- `PENDING` - Event created, waiting for target time ← **Target for recovery**
- `PROCESSING` - Event claimed by scheduler
- `COMPLETED` - Successfully executed
- `FAILED` - Execution failed after max retries

### Repository Pattern

**IEventRepository Port** [Source: docs/architecture/port-interfaces.md#IEventRepository]

Existing methods:
- `create(event: Event): Promise<Event>`
- `findById(eventId: string): Promise<Event | null>`
- `findByUserId(userId: string): Promise<Event[]>`
- `update(event: Event): Promise<Event>`
- `claimReadyEvents(limit: number): Promise<Event[]>` ← Similar pattern for recovery

**NEW method to add:**
- `findMissedEvents(limit: number): Promise<Event[]>`

**Implementation:** `PrismaEventRepository` [Source: docs/architecture/source-tree.md#Event-Scheduling-Bounded-Context]
- Location: `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.ts`
- Uses Prisma Client for PostgreSQL access
- Includes mapper: `eventToDomain()` for Prisma → Domain conversion

### Recovery Query Logic

**Query Specification:**
```typescript
// Missed events = events that should have executed but haven't
WHERE status = 'PENDING'
  AND targetTimestampUTC < NOW()
ORDER BY targetTimestampUTC ASC
LIMIT 1000
```

**Why ORDER BY targetTimestampUTC ASC?**
- Process oldest missed events first (fairness)
- User with birthday 7 days ago gets priority over user with birthday 1 hour ago
- Matches scheduler's query pattern (oldest first)

**Why LIMIT 1000?**
- Prevents memory overflow during recovery
- Allows incremental recovery (process 1000, then next 1000, etc.)
- Story 3.2 will add batch processing via SQS

**Why NOT claim events in recovery service?**
- This story only **detects** missed events
- Story 3.2 will handle **execution** (sending to SQS)
- Separation of concerns: detection ≠ processing

### File Locations

[Source: docs/architecture/source-tree.md]

**Use Case:**
- `src/application/use-cases/RecoveryService.ts`
- `src/application/use-cases/RecoveryService.test.ts`

**Repository Port:**
- `src/modules/event-scheduling/application/ports/IEventRepository.ts` (add method)

**Repository Implementation:**
- `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.ts` (add method)
- `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.integration.test.ts` (add tests)

### Logging Standards

[Source: docs/architecture/coding-standards.md#1-no-consolelog-in-production]

**Use Pino logger exclusively:**
```typescript
// ✅ CORRECT
logger.info('Missed events found', {
  count: events.length,
  oldestEventTimestamp: events[0].targetTimestampUTC.toISO(),
  newestEventTimestamp: events[events.length - 1].targetTimestampUTC.toISO()
});

// ❌ WRONG
console.log('Found', events.length, 'missed events');
```

**Structured logging requirements:**
- Use JSON format (Pino default)
- Include context: serviceName, correlationId
- Log levels: ERROR, WARN, INFO, DEBUG
- CloudWatch-friendly format

### Technology Stack

[Source: docs/architecture/tech-stack.md]

**Dependencies:**
- **Language:** TypeScript 5.3.3 (strict mode)
- **Date/Time:** Luxon 3.4.4 (DateTime objects, NOT JavaScript Date)
- **Logger:** Pino 8.17.2 (NOT Winston, NOT console.log)
- **ORM:** Prisma 6.17.1 (type-safe database client)
- **Testing:** Jest 29.7.0

### Coding Standards

[Source: docs/architecture/coding-standards.md]

**Critical Rules:**
1. **No console.log** - Use Pino logger
2. **No `any` types** - Use explicit types or `unknown`
3. **Explicit accessibility modifiers** - `public`, `private`, `protected` required for all class members
4. **Repository pattern** - Use IEventRepository port, NOT direct Prisma calls in use case
5. **Async/await only** - No callbacks or raw promises
6. **Value objects** - Use EventStatus enum, DateTime (Luxon)

**Example Pattern:**
```typescript
export class RecoveryService {
  public constructor(
    private readonly eventRepository: IEventRepository,
    private readonly logger: ILogger
  ) {}

  public async execute(): Promise<RecoveryResult> {
    // Implementation
  }

  private async findMissedEvents(): Promise<Event[]> {
    // Implementation
  }
}
```

### Port Interface Pattern

[Source: docs/architecture/port-interfaces.md]

**Dependency Inversion:**
- Use case depends on `IEventRepository` interface (abstraction)
- `PrismaEventRepository` implements `IEventRepository` (concrete)
- Injected at runtime via constructor

**Benefits:**
- Easy to test (mock IEventRepository)
- Technology-agnostic (could swap Prisma for TypeORM)
- Clear architectural boundaries

---

## Testing

### Test File Locations

[Source: docs/architecture/test-strategy.md#Test-Types-and-Organization]

**Unit Tests:**
- `src/application/use-cases/RecoveryService.test.ts` (colocated with source)

**Integration Tests:**
- `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.integration.test.ts`

### Test Standards

[Source: docs/architecture/test-strategy.md]

**Unit Test Requirements:**
- Framework: Jest 29.7.0
- File convention: `{SourceFileName}.test.ts`
- Coverage requirement: ≥80% for application layer
- Mock all external dependencies (repositories, loggers)
- Use AAA pattern (Arrange, Act, Assert)
- Use EventBuilder for test data creation

**Integration Test Requirements:**
- Framework: Jest 29.7.0 + Testcontainers PostgreSQL 16
- Test real database interactions
- Clean up data in `afterEach` hooks
- Use `beforeAll` to start PostgreSQL container
- Use `afterAll` to stop container
- Timeout: 60000ms for container startup

**Test Data Builders:**
[Source: docs/architecture/design-patterns.md#6-builder-pattern]

Use existing `EventBuilder` pattern:
```typescript
const missedEvent = new EventBuilder()
  .thatIsOverdue(24) // 24 hours late
  .build();
```

### Test-Driven Development (TDD)

[Source: docs/architecture/test-strategy.md#Testing-Philosophy]

**TDD is STRONGLY RECOMMENDED for this story:**
- ✅ Well-defined interface (IEventRepository.findMissedEvents)
- ✅ Following established pattern (similar to claimReadyEvents)
- ✅ Clear acceptance criteria

**TDD Workflow:**
1. **RED**: Write failing test for findMissedEvents()
2. **GREEN**: Implement minimal code to pass
3. **REFACTOR**: Clean up while keeping tests green
4. **REPEAT**: Continue for RecoveryService

### Example Unit Test Structure

```typescript
describe('RecoveryService', () => {
  let service: RecoveryService;
  let mockEventRepo: jest.Mocked<IEventRepository>;
  let mockLogger: jest.Mocked<ILogger>;

  beforeEach(() => {
    mockEventRepo = {
      findMissedEvents: jest.fn()
    } as any;
    mockLogger = {
      info: jest.fn(),
      warn: jest.fn(),
      error: jest.fn()
    } as any;
    service = new RecoveryService(mockEventRepo, mockLogger);
  });

  it('should return zero count when no missed events exist', async () => {
    // Arrange
    mockEventRepo.findMissedEvents.mockResolvedValue([]);

    // Act
    const result = await service.execute();

    // Assert
    expect(result.missedEventsCount).toBe(0);
    expect(mockLogger.info).toHaveBeenCalledWith('No missed events found');
  });

  // ... more tests
});
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-26 | 1.0 | Initial draft created | Bob (Scrum Master) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used

*TBD by dev agent*

### Debug Log References

*TBD by dev agent*

### Completion Notes

*TBD by dev agent*

### File List

*TBD by dev agent*

---

## QA Results

*This section will be populated by QA agent after implementation*
