# Story 2.8: Event State Machine Enforcement

---

## Status

Approved

---

## Story

**As a** developer,
**I want** strict enforcement of event status transitions,
**so that** invalid state changes are prevented.

---

## Acceptance Criteria

1. Event entity validates state transitions in domain layer
2. Valid transitions: PENDING → PROCESSING, PROCESSING → COMPLETED, PROCESSING → FAILED
3. Invalid transitions throw domain errors (e.g., COMPLETED → PROCESSING)
4. Repository layer enforces state machine rules before persistence
5. Concurrent update attempts detected via optimistic locking (version mismatch)
6. Failed optimistic lock updates are logged and not retried (event already claimed)
7. Unit tests cover all valid and invalid transition scenarios
8. Integration tests verify state machine works with concurrent updates

---

## Tasks / Subtasks

- [ ] **Task 1: Verify State Machine Implementation in Domain Layer** (AC: 1, 2, 3, 7)
  - [ ] Review `src/modules/event-scheduling/domain/value-objects/EventStatus.ts`
  - [ ] Verify `VALID_TRANSITIONS` mapping is correct: PENDING → [PROCESSING], PROCESSING → [COMPLETED, FAILED], terminal states → []
  - [ ] Verify `validateTransition()` function throws `InvalidStateTransitionError` for invalid transitions
  - [ ] Review `src/modules/event-scheduling/domain/entities/Event.ts`
  - [ ] Verify `claim()`, `markCompleted()`, `markFailed()` all call `validateTransition()` before state change
  - [ ] Verify version is incremented on every state change (optimistic locking)
  - [ ] Verify tests exist in `EventStatus.test.ts` covering:
    - Valid transitions return true from `isValidTransition()`
    - Invalid transitions return false from `isValidTransition()`
    - Invalid transitions throw `InvalidStateTransitionError` from `validateTransition()`
  - [ ] Verify tests exist in `Event.test.ts` covering:
    - `claim()` succeeds from PENDING, throws from other states
    - `markCompleted()` succeeds from PROCESSING, throws from other states
    - `markFailed()` succeeds from PROCESSING, throws from other states
    - Terminal states (COMPLETED, FAILED) cannot transition to any other state
  - [ ] Reference: [Source: docs/architecture/data-models.md#Event]

- [ ] **Task 2: Add Missing State Transition Tests** (AC: 3, 7)
  - [ ] If gaps found in Task 1, add comprehensive state machine tests to `Event.test.ts`
  - [ ] Test matrix: For each status (PENDING, PROCESSING, COMPLETED, FAILED), test all possible transitions (valid and invalid)
  - [ ] Test scenarios:
    - PENDING → PROCESSING (valid via `claim()`)
    - PENDING → COMPLETED (invalid, throws error)
    - PENDING → FAILED (invalid, throws error)
    - PROCESSING → COMPLETED (valid via `markCompleted()`)
    - PROCESSING → FAILED (valid via `markFailed()`)
    - PROCESSING → PENDING (invalid, throws error)
    - COMPLETED → any state (all invalid, throws error)
    - FAILED → any state (all invalid, throws error)
  - [ ] Verify error messages clearly indicate source state, target state, and why transition is invalid
  - [ ] Run tests to ensure 100% coverage of state machine logic
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#Unit-Tests]

- [ ] **Task 3: Verify Optimistic Locking in Repository Layer** (AC: 4, 5, 6)
  - [ ] Review `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.ts`
  - [ ] Verify `update()` method checks `version` field before updating (line ~64-97)
  - [ ] Verify Prisma update uses `where: { id: event.id, version: previousVersion }` to enforce optimistic lock
  - [ ] Verify `OptimisticLockError` thrown when update affects 0 rows (version mismatch from Prisma P2025 error)
  - [ ] Verify error message includes event ID and expected version for debugging
  - [ ] Verify `claimReadyEvents()` uses `FOR UPDATE SKIP LOCKED` to prevent race conditions (line ~100+)
  - [ ] Check existing integration tests in `PrismaEventRepository.integration.test.ts`:
    - Does test verify optimistic lock detection on concurrent updates?
    - Does test verify version mismatch throws `OptimisticLockError`?
  - [ ] Reference: [Source: docs/architecture/database-schema.md#Optimistic-Locking-Strategy]
  - [ ] Reference: [Source: docs/architecture/port-interfaces.md#IEventRepository]

- [ ] **Task 4: Add Optimistic Locking Integration Tests** (AC: 5, 6, 8)
  - [ ] If gaps found in Task 3, add integration tests to `PrismaEventRepository.integration.test.ts`
  - [ ] Test scenario 1: Concurrent update detection
    - Create event in PENDING state
    - Load event instance A
    - Load event instance B (same event, different object)
    - Update instance A (claim event → PROCESSING)
    - Attempt update instance B (should throw `OptimisticLockError` due to version mismatch)
    - Verify instance A update succeeded, instance B update failed
    - Verify error message indicates version mismatch
  - [ ] Test scenario 2: Verify version increments correctly
    - Create event with version 1
    - Claim event (version → 2)
    - Mark completed (version → 3)
    - Verify each state change incremented version
  - [ ] Test scenario 3: Concurrent claiming (race condition)
    - Create multiple events ready for claiming
    - Simulate two concurrent processes calling `claimReadyEvents()`
    - Verify no event is claimed twice (FOR UPDATE SKIP LOCKED prevents duplicates)
    - Verify each process gets distinct events
  - [ ] Run tests with real database (LocalStack PostgreSQL) to ensure locking works
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#Integration-Tests]

- [ ] **Task 5: Verify Error Handling in Use Cases** (AC: 6)
  - [ ] Review `src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.ts`
  - [ ] Verify use case catches `OptimisticLockError` from repository
  - [ ] Verify optimistic lock failures are logged with appropriate context (eventId, version)
  - [ ] Verify optimistic lock failures are NOT retried (event already claimed by another worker)
  - [ ] Check if `InvalidStateTransitionError` is caught and logged appropriately
  - [ ] If error handling is missing, add try-catch blocks and logging:
    ```typescript
    try {
      await repository.update(event.claim());
    } catch (error) {
      if (error instanceof OptimisticLockError) {
        logger.warn({ eventId: event.id, error }, 'Event already claimed by another worker');
        return; // Do not retry
      }
      throw error; // Re-throw for other errors
    }
    ```
  - [ ] Verify tests exist in `ExecuteEventUseCase.test.ts` covering optimistic lock failure handling
  - [ ] Reference: [Source: docs/architecture/error-handling.md#Error-Classification]

- [ ] **Task 6: Document State Machine Behavior** (AC: 1, 2, 3)
  - [ ] If not already documented, enhance `docs/architecture/data-models.md#Event` section
  - [ ] Add clear state machine diagram or table showing valid transitions:
    ```
    PENDING → PROCESSING → COMPLETED
                        ↘ FAILED
    ```
  - [ ] Document rationale for state machine rules:
    - Why COMPLETED and FAILED are terminal states (historical record, audit trail)
    - Why PENDING cannot transition directly to COMPLETED or FAILED (must be claimed first)
    - Why concurrent updates are prevented via optimistic locking
  - [ ] Document error handling behavior:
    - `InvalidStateTransitionError` indicates programming bug or race condition
    - `OptimisticLockError` indicates concurrent update, normal in distributed system
    - Optimistic lock failures should be logged but not retried
  - [ ] Add examples of valid and invalid state transitions
  - [ ] Reference: [Source: docs/architecture/data-models.md#Event]

---

## Dev Notes

### Implementation Status

**CRITICAL**: The Event state machine is **largely already implemented** in the domain layer (Stories 1.3, 1.4, 1.6). This story is primarily a **verification, testing, and enforcement story** to ensure:

1. **State machine validation is complete and correct** in domain layer
2. **Comprehensive tests exist** for all valid and invalid transitions
3. **Optimistic locking is properly enforced** in repository layer
4. **Concurrent updates are detected and handled** correctly
5. **Error handling and logging** is appropriate for state machine violations

### Previous Story Insights

**From Story 2.7 (Idempotency Key Generation):**
- Story was verification-focused, successfully validated existing implementation
- Added comprehensive tests (15 new tests) where gaps identified
- Enhanced documentation significantly (~160 lines added)
- Dev agent should follow similar pattern: verify first, add tests where needed, document behavior

**From Story 2.6 (Worker Lambda - SQS Consumer):**
- Worker Lambda successfully processes events with state transitions
- ExecuteEventUseCase handles event claiming and completion
- Error handling includes retries for transient failures

**From Story 1.6 (Event Repository Implementation):**
- PrismaEventRepository implements optimistic locking via version field
- `update()` method checks previous version before updating
- `claimReadyEvents()` uses FOR UPDATE SKIP LOCKED for concurrent claiming

### Architecture Context

#### Event State Machine

**State Diagram:**

```
┌─────────┐
│ PENDING │ (Initial state when event created)
└────┬────┘
     │ claim()
     ↓
┌────────────┐
│ PROCESSING │ (Event being executed)
└─────┬──────┘
      │
      ├─→ markCompleted() → ┌───────────┐
      │                      │ COMPLETED │ (Terminal state)
      │                      └───────────┘
      │
      └─→ markFailed() ────→ ┌────────┐
                             │ FAILED │ (Terminal state, can retry if retryCount < 3)
                             └────────┘
```

**Valid Transitions:** PENDING → PROCESSING, PROCESSING → COMPLETED, PROCESSING → FAILED

**Invalid Transitions:** All other combinations (e.g., COMPLETED → PROCESSING, PENDING → COMPLETED, FAILED → PENDING)

**Terminal States:** COMPLETED and FAILED are terminal - no outbound transitions allowed. These represent historical records and audit trail.

[Source: docs/architecture/data-models.md#Event]

#### State Machine Implementation

**Location:** `src/modules/event-scheduling/domain/value-objects/EventStatus.ts`

**Implementation:**

```typescript
export enum EventStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
}

const VALID_TRANSITIONS: Record<EventStatus, EventStatus[]> = {
  [EventStatus.PENDING]: [EventStatus.PROCESSING],
  [EventStatus.PROCESSING]: [EventStatus.COMPLETED, EventStatus.FAILED],
  [EventStatus.COMPLETED]: [],
  [EventStatus.FAILED]: [],
};

export function validateTransition(from: EventStatus, to: EventStatus): void {
  if (!isValidTransition(from, to)) {
    throw new InvalidStateTransitionError(from, to);
  }
}
```

**Error:** `InvalidStateTransitionError` thrown for invalid transitions.

[Source: src/modules/event-scheduling/domain/value-objects/EventStatus.ts]

#### Event Entity State Methods

**Location:** `src/modules/event-scheduling/domain/entities/Event.ts`

**Methods:**

1. **claim()** - Transitions PENDING → PROCESSING, increments version
2. **markCompleted(executedAt)** - Transitions PROCESSING → COMPLETED, increments version
3. **markFailed(reason)** - Transitions PROCESSING → FAILED, increments retry count and version

All methods call `validateTransition()` before applying state change, ensuring invalid transitions are prevented at the domain layer.

**Immutability:** Event entity is immutable - all state change methods return new Event instances.

[Source: docs/architecture/data-models.md#Event]
[Source: src/modules/event-scheduling/domain/entities/Event.ts]

#### Optimistic Locking

**Purpose:** Prevents lost updates when multiple workers attempt to modify the same event concurrently.

**Database Schema:**

```sql
CREATE TABLE events (
  id UUID PRIMARY KEY,
  version INTEGER NOT NULL DEFAULT 1,
  status VARCHAR(20) NOT NULL,
  -- ... other fields
  CONSTRAINT chk_version_positive CHECK (version > 0)
);
```

**Update Strategy:**

```sql
UPDATE events
SET status = 'PROCESSING', version = version + 1, updated_at = NOW()
WHERE id = ? AND version = ?;
```

If the update affects 0 rows, it means another process has already modified the event (version mismatch). This triggers `OptimisticLockError`.

**Version Increment:** Every state change (claim, markCompleted, markFailed) increments version by 1.

[Source: docs/architecture/database-schema.md#Optimistic-Locking-Strategy]

#### Repository Optimistic Lock Implementation

**Location:** `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.ts`

**update() Method:**

```typescript
public async update(event: Event): Promise<Event> {
  const prismaData = eventToPrisma(event);
  const previousVersion = event.version - 1; // Version before domain operation

  try {
    const updated = await this.prisma.event.update({
      where: {
        id: event.id,
        version: previousVersion, // Optimistic lock check
      },
      data: prismaData,
    });
    return eventToDomain(updated);
  } catch (error) {
    // Prisma throws P2025 when no record found (version mismatch)
    if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
      throw new OptimisticLockError(
        `Event ${event.id} was modified by another transaction (expected version ${previousVersion})`
      );
    }
    throw error;
  }
}
```

**claimReadyEvents() Method:** Uses `FOR UPDATE SKIP LOCKED` to prevent race conditions when multiple workers claim events concurrently.

[Source: src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.ts]
[Source: docs/architecture/port-interfaces.md#IEventRepository]

#### Concurrent Update Scenarios

**Scenario 1: Two workers claim the same event (prevented)**

```
Worker A: Load event (version 1, status PENDING)
Worker B: Load event (version 1, status PENDING)
Worker A: Claim event → UPDATE ... WHERE version = 1 (succeeds, version → 2)
Worker B: Claim event → UPDATE ... WHERE version = 1 (fails, version mismatch)
Result: Worker A gets event, Worker B receives OptimisticLockError
```

**Scenario 2: Event already claimed (logged, not retried)**

```
Worker A: Claims event via claimReadyEvents() (version 1 → 2)
Worker B: Attempts to execute same event
Worker B: UPDATE fails with OptimisticLockError
Worker B: Logs warning "Event already claimed by another worker"
Worker B: Does NOT retry (event is already being processed)
```

[Source: docs/architecture/database-schema.md#Optimistic-Locking-Strategy]

#### Error Handling

**InvalidStateTransitionError:**
- **Cause:** Attempt to perform invalid state transition (e.g., COMPLETED → PROCESSING)
- **Classification:** Programming bug or race condition
- **Handling:** Log error, do not retry, investigate root cause
- **Example:** Attempting to claim event that's already COMPLETED

**OptimisticLockError:**
- **Cause:** Version mismatch during concurrent update
- **Classification:** Expected in distributed system with multiple workers
- **Handling:** Log warning, do not retry (event already claimed/processed by another worker)
- **Example:** Two workers simultaneously trying to claim the same event

[Source: docs/architecture/error-handling.md#Error-Classification]

#### Testing Requirements

**Unit Tests:** (Colocated with source files)

- `EventStatus.test.ts`: Test `isValidTransition()` and `validateTransition()` for all state combinations
- `Event.test.ts`: Test `claim()`, `markCompleted()`, `markFailed()` with valid and invalid states
- Test that invalid transitions throw `InvalidStateTransitionError` with clear error messages
- Test version increments correctly on every state change

**Integration Tests:** (with real database)

- `PrismaEventRepository.integration.test.ts`: Test optimistic locking with concurrent updates
- Test scenario: Load event twice, update first instance, verify second instance fails with `OptimisticLockError`
- Test scenario: Concurrent `claimReadyEvents()` calls do not claim same event twice (FOR UPDATE SKIP LOCKED)
- Test scenario: Version increments correctly through event lifecycle (PENDING → PROCESSING → COMPLETED)

[Source: docs/architecture/test-strategy.md#Unit-Tests]
[Source: docs/architecture/test-strategy.md#Integration-Tests]

#### File Locations

**Domain Layer:**
- `src/modules/event-scheduling/domain/value-objects/EventStatus.ts` - State enum and validation
- `src/modules/event-scheduling/domain/value-objects/EventStatus.test.ts` - Unit tests for state validation
- `src/modules/event-scheduling/domain/entities/Event.ts` - Event entity with state methods
- `src/modules/event-scheduling/domain/entities/Event.test.ts` - Unit tests for Event entity

**Repository Layer:**
- `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.ts` - Optimistic locking implementation
- `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.integration.test.ts` - Integration tests for locking

**Error Classes:**
- `src/domain/errors/InvalidStateTransitionError.ts` - Domain error for invalid transitions
- `src/domain/errors/OptimisticLockError.ts` - Repository error for version mismatch

[Source: docs/architecture/source-tree.md#Domain-Layer]
[Source: docs/architecture/source-tree.md#Adapters-Layer]

#### Database Schema

**events Table:**

```sql
CREATE TABLE events (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  event_type VARCHAR(50) NOT NULL,
  status VARCHAR(20) NOT NULL CHECK (status IN ('PENDING', 'PROCESSING', 'COMPLETED', 'FAILED')),
  target_timestamp_utc TIMESTAMP WITH TIME ZONE NOT NULL,
  target_timestamp_local TIMESTAMP WITH TIME ZONE NOT NULL,
  target_timezone VARCHAR(100) NOT NULL,
  executed_at TIMESTAMP WITH TIME ZONE,
  failure_reason TEXT,
  retry_count INTEGER NOT NULL DEFAULT 0 CHECK (retry_count >= 0 AND retry_count <= 3),
  version INTEGER NOT NULL DEFAULT 1 CHECK (version > 0),
  idempotency_key VARCHAR(255) UNIQUE NOT NULL,
  delivery_payload JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_events_scheduler_query ON events (target_timestamp_utc, status)
WHERE status = 'PENDING';
```

**Constraints:**
- `status` must be one of 4 valid values
- `retry_count` between 0 and 3
- `version` must be positive (> 0)
- `idempotency_key` is unique

[Source: docs/architecture/database-schema.md#Events-Table]

### Testing

#### Test Framework

- **Framework:** Jest 29.7.0
- **Pattern:** AAA (Arrange, Act, Assert)
- **Coverage:** ≥80% for domain entities and value objects
- **Unit Test Location:** Colocated with source files (e.g., `Event.test.ts` next to `Event.ts`)
- **Integration Test Location:** `src/modules/event-scheduling/adapters/persistence/*.integration.test.ts`

[Source: docs/architecture/test-strategy.md#Unit-Tests]

#### Test Scenarios

**Unit Tests (Event State Machine):**

1. Valid transition PENDING → PROCESSING via `claim()` succeeds
2. Invalid transition PENDING → COMPLETED throws `InvalidStateTransitionError`
3. Invalid transition PENDING → FAILED throws `InvalidStateTransitionError`
4. Valid transition PROCESSING → COMPLETED via `markCompleted()` succeeds
5. Valid transition PROCESSING → FAILED via `markFailed()` succeeds
6. Invalid transition PROCESSING → PENDING throws error
7. Invalid transition COMPLETED → any state throws error
8. Invalid transition FAILED → any state throws error
9. Version increments on every successful state change

**Integration Tests (Optimistic Locking):**

1. Concurrent update attempt detects version mismatch and throws `OptimisticLockError`
2. Concurrent `claimReadyEvents()` calls do not claim same event twice
3. Version increments correctly through full event lifecycle (1 → 2 → 3)
4. Error message includes event ID and expected version for debugging

[Source: docs/architecture/test-strategy.md#Test-Scenarios]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-25 | 1.0 | Created Story 2.8 for Event State Machine Enforcement verification | Bob (Scrum Master) |
| 2025-10-25 | 1.1 | Story approved - ready for development | Bob (Scrum Master) |

---

## Dev Agent Record

_To be populated by dev agent_

---

## QA Results

_To be populated by QA agent_
