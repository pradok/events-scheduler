# Story 1.10: Refactor Create User Use Case with Domain Events

---

## Status

Todo

**Note:** This story refactors the existing CreateUserUseCase (originally Story 1.8) to use bounded context architecture with domain events. The old implementation creates Events directly (tight coupling); this refactoring publishes UserCreated domain events instead.

**Dependencies:** Stories 1.8 (Domain Event Bus) and 1.9 (UserCreated Event Handler) must be completed first.

---

## Story

**As a** developer,
**I want** to refactor CreateUserUseCase to publish UserCreated domain events instead of directly creating Events,
**so that** User Context is completely decoupled from Event Scheduling Context via domain events.

---

## Acceptance Criteria

**Refactored for Bounded Contexts Architecture:**

1. CreateUserUseCase refactored in `src/modules/user/application/use-cases/CreateUserUseCase.ts`
2. Use case constructor ONLY receives:
   - `IUserRepository` (User Context dependency)
   - `IDomainEventBus` (Shared infrastructure)
3. Use case constructor REMOVES:
   - ❌ `IEventRepository` (Event Scheduling Context dependency - VIOLATES bounded contexts)
   - ❌ `TimezoneService` (Event Scheduling Context service - VIOLATES bounded contexts)
   - ❌ `EventHandlerRegistry` (Event Scheduling Context service - VIOLATES bounded contexts)
4. Use case creates User domain entity from validated DTO (existing behavior preserved)
5. Use case saves User to database via IUserRepository (existing behavior preserved)
6. Use case publishes `UserCreatedEvent` to `IDomainEventBus` after successful user creation
7. `UserCreatedEvent` includes all data needed by Event Scheduling Context:
   - `eventType: 'UserCreated'`
   - `context: 'user'`
   - `occurredAt: string` (ISO 8601 timestamp)
   - `aggregateId: string` (User ID)
   - `userId: string`, `firstName: string`, `lastName: string`, `dateOfBirth: string`, `timezone: string`
8. Use case does NOT create Event entities or call `IEventRepository` (decoupled via events)
9. Unit tests verify:
   - User created and saved to repository
   - UserCreatedEvent published to event bus with correct payload
   - Event bus called AFTER user persisted (ordering matters)
   - NO calls to IEventRepository or Event Scheduling services
10. All existing tests updated to remove Event Scheduling dependencies

---

## Tasks / Subtasks

- [ ] **Task 1: Refactor CreateUserUseCase constructor** (AC: 1, 2, 3)
  - [ ] Open existing file `src/modules/user/application/use-cases/CreateUserUseCase.ts`
  - [ ] REMOVE constructor parameters:
    - ❌ `private readonly eventRepository: IEventRepository`
    - ❌ `private readonly timezoneService: TimezoneService`
    - ❌ `private readonly eventHandlerRegistry: EventHandlerRegistry`
  - [ ] KEEP constructor parameters:
    - ✅ `private readonly userRepository: IUserRepository`
  - [ ] ADD constructor parameter:
    - ✅ `private readonly eventBus: IDomainEventBus`
  - [ ] Update imports to remove Event Scheduling Context dependencies
  - [ ] Add import: `import { IDomainEventBus } from '@shared/events/IDomainEventBus';`
  - [ ] Add import: `import { UserCreatedEvent } from '../../domain/events/UserCreatedEvent';`

- [ ] **Task 2: Remove Event creation logic from execute() method** (AC: 4, 5, 8)
  - [ ] DELETE all code related to:
    - Birthday calculation (`handler.calculateNextOccurrence()`)
    - Timezone conversion (`timezoneService.convertToUTC()`)
    - Event entity creation (`new Event({...})`)
    - Event repository calls (`eventRepository.create()`)
  - [ ] KEEP existing code for:
    - Input validation (`CreateUserSchema.parse(dto)`)
    - User entity creation
    - User repository persistence (`userRepository.create(user)`)
  - [ ] Simplify execute() method to focus ONLY on User Context responsibilities

- [ ] **Task 3: Publish UserCreatedEvent after user persistence** (AC: 6, 7)
  - [ ] After successful `await this.userRepository.create(user)`, add event publishing logic
  - [ ] Create `UserCreatedEvent` object with payload:
    ```typescript
    const userCreatedEvent: UserCreatedEvent = {
      eventType: 'UserCreated',
      context: 'user',
      occurredAt: DateTime.now().toISO(),
      aggregateId: user.id,
      userId: user.id,
      firstName: user.firstName,
      lastName: user.lastName,
      dateOfBirth: user.dateOfBirth.toString(),
      timezone: user.timezone.toString()
    };
    ```
  - [ ] Publish event: `await this.eventBus.publish(userCreatedEvent);`
  - [ ] Ensure event published AFTER user persisted (correct ordering)
  - [ ] Wrap in try-catch to handle event bus failures gracefully

- [ ] **Task 4: Update unit tests to remove Event Scheduling dependencies** (AC: 9, 10)
  - [ ] Open `src/modules/user/application/use-cases/CreateUserUseCase.test.ts`
  - [ ] REMOVE mocks for:
    - ❌ `IEventRepository`
    - ❌ `TimezoneService`
    - ❌ `EventHandlerRegistry`
    - ❌ `BirthdayEventHandler`
  - [ ] ADD mock for:
    - ✅ `IDomainEventBus` with `publish` method
  - [ ] Update test setup to instantiate use case with only 2 dependencies:
    ```typescript
    const mockUserRepository = createMockUserRepository();
    const mockEventBus = createMockEventBus();
    const useCase = new CreateUserUseCase(mockUserRepository, mockEventBus);
    ```

- [ ] **Task 5: Rewrite unit tests for event-driven architecture** (AC: 9)
  - [ ] Test: "should create user and publish UserCreatedEvent"
    - Arrange: Valid CreateUserDTO
    - Act: Call `useCase.execute(dto)`
    - Assert:
      - `userRepository.create` called once with User entity
      - `eventBus.publish` called once with UserCreatedEvent payload
      - Event payload contains correct user data (firstName, lastName, dateOfBirth, timezone)
      - Event has `eventType: 'UserCreated'` and `context: 'user'`
  - [ ] Test: "should publish event AFTER user persisted (correct ordering)"
    - Arrange: Track call order using jest.spyOn
    - Act: Call `useCase.execute(dto)`
    - Assert: `userRepository.create` called before `eventBus.publish`
  - [ ] Test: "should NOT publish event if user creation fails"
    - Arrange: Mock userRepository.create to throw error
    - Act & Assert: Expect error to propagate
    - Assert: `eventBus.publish` NOT called
  - [ ] Test: "should throw InvalidTimezoneError for invalid timezone"
    - Arrange: DTO with invalid timezone
    - Act & Assert: Expect InvalidTimezoneError
    - Assert: No repository or event bus methods called
  - [ ] Test: "should throw InvalidDateOfBirthError for future date"
    - Arrange: DTO with future dateOfBirth
    - Act & Assert: Expect InvalidDateOfBirthError
    - Assert: No repository or event bus methods called
  - [ ] DELETE tests related to:
    - ❌ Event entity creation
    - ❌ Birthday calculation
    - ❌ Timezone conversion
    - ❌ Event repository calls
  - [ ] Achieve 100% coverage for refactored `execute()` method

- [ ] **Task 6: Verify ESLint and TypeScript compilation** (AC: 10)
  - [ ] Run `npx eslint src/modules/user/application/use-cases/CreateUserUseCase.ts` and fix errors
  - [ ] Run `npx tsc --noEmit` and verify strict mode passes
  - [ ] Ensure no imports from Event Scheduling Context (`@modules/event-scheduling/*`)
  - [ ] Ensure only allowed imports:
    - ✅ User Context (`@modules/user/*` or relative paths)
    - ✅ Shared infrastructure (`@shared/*`)
  - [ ] Run full test suite: `npm test`

---

## Dev Notes

This story **refactors** the existing CreateUser use case to implement **Bounded Context** architecture with **Domain Events**. The refactoring removes tight coupling between User Context and Event Scheduling Context by replacing direct Event creation with event publishing.

### Architecture Context

**[Source: architecture/bounded-contexts.md, architecture/source-tree.md]**

This refactored use case belongs in:

- **Location:** `src/modules/user/application/use-cases/CreateUserUseCase.ts`
- **Bounded Context:** User Context
- **Layer:** Application layer (orchestrates User domain logic)
- **Allowed Dependencies:**
  - ✅ User domain entities (`@modules/user/domain/entities/User`)
  - ✅ User value objects (`@modules/user/domain/value-objects/DateOfBirth`)
  - ✅ Shared value objects (`@shared/value-objects/Timezone`)
  - ✅ User application ports (`@modules/user/application/ports/IUserRepository`)
  - ✅ Shared event bus (`@shared/events/IDomainEventBus`)
  - ✅ User domain events (`@modules/user/domain/events/UserCreatedEvent`)
- **FORBIDDEN Dependencies (VIOLATE Bounded Contexts):**
  - ❌ Event Scheduling entities (`@modules/event-scheduling/domain/entities/Event`)
  - ❌ Event Scheduling ports (`@modules/event-scheduling/application/ports/IEventRepository`)
  - ❌ Event Scheduling services (`@modules/event-scheduling/domain/services/TimezoneService`)
  - ❌ Infrastructure adapters (`src/adapters/*`, Prisma, Fastify, AWS SDK)

**Import Path Example (After Refactoring):**

```typescript
// src/modules/user/application/use-cases/CreateUserUseCase.ts
import { DateTime } from 'luxon';
import { v4 as uuidv4 } from 'uuid';
import { CreateUserSchema, CreateUserDTO } from '@shared/validation/schemas';
import { User } from '../../domain/entities/User';
import { DateOfBirth } from '../../domain/value-objects/DateOfBirth';
import { Timezone } from '@shared/value-objects/Timezone';
import { IUserRepository } from '../ports/IUserRepository';
import { IDomainEventBus } from '@shared/events/IDomainEventBus';
import { UserCreatedEvent } from '../../domain/events/UserCreatedEvent';
// ❌ NO IMPORTS from @modules/event-scheduling/*
```

---

### Zod Schema-First Approach

**[Source: architecture/coding-standards.md#zod-schemas-as-single-source-of-truth]**

**Critical Pattern:** Define Zod schemas as the **single source of truth** for all data structures. Use `z.infer<>` to derive TypeScript types.

**Why this matters:**
- Schema changes automatically propagate throughout the codebase
- TypeScript compiler detects breaking changes across all layers
- Eliminates drift between validation rules and type definitions
- Provides both runtime validation AND compile-time type checking

**Example Pattern for CreateUserSchema:**

```typescript
// src/shared/validation/schemas.ts
import { z } from 'zod';

export const CreateUserSchema = z.object({
  firstName: z.string().min(1).max(100),
  lastName: z.string().min(1).max(100),
  dateOfBirth: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  timezone: z.string()
});

// Derive type from schema - NEVER manually define this type!
export type CreateUserDTO = z.infer<typeof CreateUserSchema>;
```

**Benefits:**
- Single location to update when requirements change
- Fastify routes will use this schema for automatic validation (Story 1.9)
- Type safety from API endpoint → use case → domain layer

---

### Domain Entities and Value Objects

**[Source: architecture/data-models.md#user, architecture/data-models.md#event]**

#### User Entity

**Key Attributes:**
- `id: string` - UUID generated on creation
- `firstName: string` - 1-100 characters (validated by Zod schema)
- `lastName: string` - 1-100 characters (validated by Zod schema)
- `dateOfBirth: DateOfBirth` - Value object (YYYY-MM-DD format, must be in past)
- `timezone: Timezone` - Value object (IANA timezone, validated)
- `createdAt: DateTime` - Timestamp when user created (UTC)
- `updatedAt: DateTime` - Timestamp when user last modified (UTC)

**Business Invariants:**
- First name and last name cannot be empty strings
- Date of birth must be a valid date in the past
- Timezone must be a valid IANA timezone identifier

#### Event Entity

**Key Attributes for Birthday Events:**
- `id: string` - UUID
- `userId: string` - Foreign key to User
- `eventType: string` - Hardcoded to `"BIRTHDAY"` for Phase 1
- `status: EventStatus` - Enum: PENDING, PROCESSING, COMPLETED, FAILED (initial: PENDING)
- `targetTimestampUTC: DateTime` - When event should execute (UTC, indexed for scheduler queries)
- `targetTimestampLocal: DateTime` - When event should execute in user's local time (9:00 AM)
- `targetTimezone: string` - Timezone used for calculation (user's timezone at event creation)
- `idempotencyKey: string` - Unique key for preventing duplicate deliveries on retry
- `deliveryPayload: object` - Message payload: `{ message: "Hey, ${firstName} ${lastName} it's your birthday" }`
- `version: number` - Optimistic locking version (start at 1)
- `retryCount: number` - Number of execution attempts (default 0, max 3)
- `executedAt: DateTime | null` - Actual execution timestamp (null until executed)
- `failureReason: string | null` - Error message if status is FAILED (null initially)
- `createdAt: DateTime` - Timestamp when event created (UTC)
- `updatedAt: DateTime` - Timestamp when event last modified (UTC)

---

### Refactoring Pattern: From Tight Coupling to Domain Events

**[Source: architecture/bounded-contexts.md#communication-pattern-domain-events]**

**OLD Implementation (WRONG - Tight Coupling):**

```typescript
// ❌ User Context directly depends on Event Scheduling Context
export class CreateUserUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly eventRepository: IEventRepository,      // ❌ Cross-context
    private readonly timezoneService: TimezoneService,       // ❌ Cross-context
    private readonly eventHandlerRegistry: EventHandlerRegistry  // ❌ Cross-context
  ) {}

  async execute(dto: CreateUserDTO): Promise<User> {
    // Create user
    const user = this.createUserEntity(dto);
    await this.userRepository.create(user);

    // ❌ Directly calculate birthday and create Event
    const handler = this.eventHandlerRegistry.getHandler('BIRTHDAY');
    const nextBirthday = handler.calculateNextOccurrence(user);
    const event = this.createEventEntity(user, nextBirthday);
    await this.eventRepository.create(event);

    return user;
  }
}
```

**NEW Implementation (CORRECT - Decoupled via Events):**

```typescript
// ✅ User Context publishes domain events, Event Scheduling Context subscribes
export class CreateUserUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly eventBus: IDomainEventBus  // ✅ Generic abstraction
  ) {}

  async execute(dto: CreateUserDTO): Promise<User> {
    // Create user
    const user = this.createUserEntity(dto);
    await this.userRepository.create(user);

    // ✅ Publish domain event (async, non-blocking)
    await this.eventBus.publish({
      eventType: 'UserCreated',
      context: 'user',
      occurredAt: DateTime.now().toISO(),
      aggregateId: user.id,
      userId: user.id,
      firstName: user.firstName,
      lastName: user.lastName,
      dateOfBirth: user.dateOfBirth.toString(),
      timezone: user.timezone.toString()
    });

    return user;  // ✅ Event creation happens asynchronously in Event Scheduling Context
  }
}
```

**Why This Refactoring Matters:**

1. **Bounded Context Isolation:** User Context has ZERO knowledge of Events, birthday calculations, or timezone conversions
2. **Single Responsibility:** User Context creates users, Event Scheduling Context creates events
3. **Testability:** Mock event bus instead of entire Event Scheduling infrastructure
4. **Future-Proof:** When migrating to microservices, same pattern works with EventBridge/SNS/SQS
5. **Extensibility:** Adding new event types (Anniversary, Reminder) requires ZERO changes to this use case

---

### Event Publishing Pattern

**[Source: architecture/bounded-contexts.md#event-publishing]**

**After Refactoring, Use Case Responsibilities:**

1. **Create User Entity:** Validate input and create User domain entity
2. **Persist User:** Save user via IUserRepository
3. **Publish Domain Event:** Notify other contexts that user was created
4. **Return User:** Return created user to caller

**Event Publishing Implementation:**

```typescript
async execute(dto: CreateUserDTO): Promise<User> {
  // 1. Validate and create User
  const validatedDto = CreateUserSchema.parse(dto);
  const user = new User({
    id: uuidv4(),
    firstName: validatedDto.firstName,
    lastName: validatedDto.lastName,
    dateOfBirth: new DateOfBirth(validatedDto.dateOfBirth),
    timezone: new Timezone(validatedDto.timezone),
    createdAt: DateTime.now(),
    updatedAt: DateTime.now()
  });

  // 2. Persist User
  const savedUser = await this.userRepository.create(user);

  // 3. Publish UserCreatedEvent
  await this.eventBus.publish({
    eventType: 'UserCreated',
    context: 'user',
    occurredAt: DateTime.now().toISO(),
    aggregateId: savedUser.id,
    userId: savedUser.id,
    firstName: savedUser.firstName,
    lastName: savedUser.lastName,
    dateOfBirth: savedUser.dateOfBirth.toString(),
    timezone: savedUser.timezone.toString()
  });

  // 4. Return created user
  return savedUser;
}
```

**Key Points:**

- ✅ NO birthday calculation (belongs in Event Scheduling Context)
- ✅ NO Event entity creation (belongs in Event Scheduling Context)
- ✅ NO timezone conversions (belongs in Event Scheduling Context)
- ✅ Event published AFTER user persisted (ensures data consistency)
- ✅ Event contains all data needed by subscribers (self-contained payload)

---

### Error Handling

**[Source: architecture/error-handling.md#business-logic-errors]**

**Error Types to Handle:**

1. **Domain Errors** (from value object creation):
   - `InvalidTimezoneError` - Thrown by Timezone value object constructor
   - `InvalidDateOfBirthError` - Thrown by DateOfBirth value object if date is in future
   - Propagate these errors directly to caller (don't catch)

2. **Validation Errors** (from Zod schema):
   - `ZodError` - Thrown by `CreateUserSchema.parse(dto)`
   - Catch and convert to user-friendly error format (or let Fastify handle in Story 1.9)

3. **Repository Errors** (from infrastructure):
   - Database connection failures
   - Unique constraint violations (if email uniqueness added later)
   - Wrap in try-catch, log error, rethrow as ApplicationError

**Refactored Error Handling Pattern:**

```typescript
public async execute(dto: CreateUserDTO): Promise<User> {
  try {
    // Validate input
    const validatedDto = CreateUserSchema.parse(dto);

    // Create User entity (may throw domain errors)
    const user = new User({ ... });

    // Persist user (may throw infrastructure errors)
    const savedUser = await this.userRepository.create(user);

    // Publish domain event (may throw event bus errors)
    await this.eventBus.publish(userCreatedEvent);

    return savedUser;

  } catch (error) {
    if (error instanceof InvalidTimezoneError || error instanceof InvalidDateOfBirthError) {
      // Domain errors - propagate directly
      throw error;
    }
    if (error instanceof ZodError) {
      // Validation errors - propagate directly (Fastify will handle)
      throw error;
    }
    // Infrastructure errors (repository or event bus) - log and rethrow
    this.logger.error({ error }, 'Failed to create user');
    throw new ApplicationError('Failed to create user', error);
  }
}
```

**What if Event Bus Fails?**

- User is ALREADY persisted to database ✅
- UserCreatedEvent NOT published ❌
- System temporarily inconsistent (eventual consistency model)
- **Self-Healing:** Story 3.x implements reconciliation job that detects users without birthday events and publishes missing events

**Logging Standards:**
**[Source: architecture/error-handling.md#logging-standards]**

- Use Pino logger (injected via constructor)
- Log level ERROR for failures
- Include correlation ID if available
- NO `console.log` (enforced by ESLint)

---

### Coding Standards

**[Source: architecture/coding-standards.md]**

#### Critical Rules:

1. **No `any` Types**
   - TypeScript strict mode enabled
   - Use `unknown` if type truly unknown
   - Explicit typing required for all function signatures

2. **Explicit Accessibility Modifiers**
   - All class members MUST have `public`, `private`, or `protected`
   - Enforced as ESLint error
   ```typescript
   export class CreateUserUseCase {
     public constructor(
       private readonly userRepository: IUserRepository,
       private readonly eventRepository: IEventRepository,
       private readonly timezoneService: TimezoneService,
       private readonly eventHandlerRegistry: EventHandlerRegistry
     ) {}

     public async execute(dto: CreateUserDTO): Promise<User> {
       // ...
     }

     private async saveUserAndEvent(user: User, event: Event): Promise<User> {
       // ...
     }
   }
   ```

3. **Async/Await Only**
   - No callbacks or raw promises
   - Proper error handling with try/catch

4. **No Console.log**
   - Use Pino logger exclusively
   - Forbidden in `src/` (enforced by ESLint)

5. **Repository Pattern Required**
   - All database access through repository interfaces
   - Never direct Prisma calls from use cases

---

### Previous Story Insights

**[Source: docs/stories/1.7.prisma-repository-implementations.md#dev-agent-record]**

**Key Learnings from Story 1.7:**

1. **Testcontainers Setup:**
   - Helper exists at `tests/integration/helpers/testDatabase.ts`
   - PostgreSQL container setup with Prisma migrations
   - Container lifecycle managed (start before all tests, stop after all tests)

2. **Value Object Factory Methods:**
   - `DateOfBirth.fromString(string)` - For converting from Prisma string format
   - `EventStatus.fromString(string)` - For converting from Prisma enum
   - `IdempotencyKey.generate(userId, timestamp)` - For generating keys

3. **Type Safety Patterns:**
   - Added TypeScript type checking (`tsc --noEmit`) to pre-commit hook
   - ESLint enforces explicit accessibility modifiers as error
   - Avoid unsafe `any` assignments

4. **Testing Patterns:**
   - Integration tests use Testcontainers for real PostgreSQL
   - Unit tests mock all external dependencies
   - 100% coverage achieved for repository methods
   - Follow AAA pattern (Arrange, Act, Assert)

---

### Testing

**[Source: architecture/test-strategy.md]**

#### Test-Driven Development (TDD) Recommended

This story is **ideal for TDD** because:
- ✅ Use case interface is well-defined
- ✅ Clear acceptance criteria
- ✅ Following established patterns (dependency injection, port interfaces)
- ✅ Repository interfaces already exist from Story 1.6

**TDD Workflow (Red-Green-Refactor):**

1. **RED**: Write failing test defining desired behavior
2. **GREEN**: Write minimal code to pass the test
3. **REFACTOR**: Clean up while keeping tests green
4. **REPEAT**: Continue until all acceptance criteria are met

#### Unit Test Requirements (After Refactoring)

**Location:** `src/modules/user/application/use-cases/CreateUserUseCase.test.ts`

**Framework:** Jest 29.7.0

**Refactored Mocking Strategy:**

- ✅ Mock IUserRepository using `jest.fn()` for all methods
- ✅ Mock IDomainEventBus using `jest.fn()` for `publish` method
- ❌ REMOVE mocks for IEventRepository, TimezoneService, EventHandlerRegistry, BirthdayEventHandler

**Coverage Requirements:**

- Minimum 90% coverage overall
- 100% coverage for refactored `execute()` method (critical path)

**Refactored Test Cases:**

1. **Happy Path:**
   - "should create user and publish UserCreatedEvent"
   - Verify `userRepository.create` called once
   - Verify `eventBus.publish` called once with UserCreatedEvent payload
   - Verify event payload contains correct user data

2. **Event Publishing Order:**
   - "should publish event AFTER user persisted"
   - Track call order using jest.spyOn
   - Verify `userRepository.create` called before `eventBus.publish`

3. **Repository Failure:**
   - "should NOT publish event if user creation fails"
   - Mock `userRepository.create` to throw error
   - Verify `eventBus.publish` NOT called

4. **Invalid Timezone:**
   - "should throw InvalidTimezoneError for invalid timezone"
   - Verify no repository or event bus methods called

5. **Invalid Date of Birth:**
   - "should throw InvalidDateOfBirthError for future date"
   - Verify no repository or event bus methods called

6. **Invalid Input Format:**
   - "should throw ZodError for invalid input format"
   - Test missing required fields

**AAA Pattern Example (Refactored):**

```typescript
it('should create user and publish UserCreatedEvent', async () => {
  // Arrange
  const dto: CreateUserDTO = {
    firstName: 'John',
    lastName: 'Doe',
    dateOfBirth: '1990-01-15',
    timezone: 'America/New_York'
  };

  const mockUser = new User({
    id: 'user-123',
    firstName: dto.firstName,
    lastName: dto.lastName,
    dateOfBirth: new DateOfBirth(dto.dateOfBirth),
    timezone: new Timezone(dto.timezone),
    createdAt: DateTime.now(),
    updatedAt: DateTime.now()
  });

  mockUserRepository.create.mockResolvedValue(mockUser);
  mockEventBus.publish.mockResolvedValue(undefined);

  // Act
  const result = await useCase.execute(dto);

  // Assert
  expect(mockUserRepository.create).toHaveBeenCalledTimes(1);
  expect(mockEventBus.publish).toHaveBeenCalledTimes(1);
  expect(mockEventBus.publish).toHaveBeenCalledWith(
    expect.objectContaining({
      eventType: 'UserCreated',
      context: 'user',
      userId: mockUser.id,
      firstName: 'John',
      lastName: 'Doe'
    })
  );
  expect(result.firstName).toBe(dto.firstName);
});
```

#### Integration Tests

**Not required for this story** - CreateUserUseCase is application layer orchestration. Integration tests will be added in Story 1.9 when Fastify API endpoints are implemented, testing end-to-end from HTTP request through use case to database.

---

### File Locations (After Refactoring)

**[Source: architecture/source-tree.md, docs/stories/1.7b.reorganize-bounded-context-folder-structure.md]**

**Files to Refactor:**

1. **Use Case (EXISTING):**
   - `src/modules/user/application/use-cases/CreateUserUseCase.ts` (refactor constructor and execute method)

2. **Unit Tests (EXISTING):**
   - `src/modules/user/application/use-cases/CreateUserUseCase.test.ts` (rewrite tests)

3. **Validation Schema (EXISTING):**
   - `src/shared/validation/schemas.ts` (no changes needed)

**New File to Create:**

1. **UserCreatedEvent (NEW):**
   - `src/modules/user/domain/events/UserCreatedEvent.ts` (created in Story 1.9)

**Existing Files to Import From (With Updated Paths):**

1. **User Domain Entities:**
   - `src/modules/user/domain/entities/User.ts`

2. **User Value Objects:**
   - `src/modules/user/domain/value-objects/DateOfBirth.ts`

3. **Shared Value Objects:**
   - `src/shared/value-objects/Timezone.ts`

4. **User Application Ports:**
   - `src/modules/user/application/ports/IUserRepository.ts`

5. **Shared Event Bus:**
   - `src/shared/events/IDomainEventBus.ts` (created in Story 1.8)

6. **User Domain Events:**
   - `src/modules/user/domain/events/UserCreatedEvent.ts` (created in Story 1.9)

7. **Domain Errors:**
   - Location TBD (likely `src/modules/user/domain/errors/` or `src/shared/errors/`)

**Files/Imports to REMOVE:**

- ❌ `src/modules/event-scheduling/domain/entities/Event.ts`
- ❌ `src/modules/event-scheduling/application/ports/IEventRepository.ts`
- ❌ `src/modules/event-scheduling/domain/services/TimezoneService.ts`
- ❌ `src/modules/event-scheduling/domain/services/EventHandlerRegistry.ts`
- ❌ `src/modules/event-scheduling/domain/value-objects/EventStatus.ts`
- ❌ `src/modules/event-scheduling/domain/value-objects/IdempotencyKey.ts`

---

### Project Structure Notes (After Refactoring)

**[Source: architecture/source-tree.md#hexagonal-separation, architecture/bounded-contexts.md]**

**User Context Application Layer Characteristics:**

- Orchestrates User domain logic ONLY
- Contains user-related use cases
- Depends ONLY on User domain entities and User application ports
- Can depend on Shared infrastructure (event bus, validation)
- NEVER imports from Event Scheduling Context (`@modules/event-scheduling/*`)
- NEVER imports from adapters (`src/adapters/`, Prisma, Fastify)
- Receives dependencies via constructor injection

**Refactored Dependency Flow (Bounded Contexts):**

```text
HTTP Request (Fastify - Future Story)
    ↓
CreateUserUseCase (User Context)
    ↓
User Entity (User Context)
    ↓
IUserRepository Port (User Context)
    ↓
PrismaUserRepository (User Context Adapter)
    ↓
PostgreSQL Database
    ↓
UserCreatedEvent Published (Shared Event Bus)
    ↓
InMemoryEventBus Routes Event (Shared Infrastructure)
    ↓
CreateBirthdayEventOnUserCreatedHandler (Event Scheduling Context)
    ↓
Event Entity (Event Scheduling Context)
    ↓
IEventRepository Port (Event Scheduling Context)
    ↓
PrismaEventRepository (Event Scheduling Context Adapter)
    ↓
PostgreSQL Database
```

**Key Architectural Changes:**

- ✅ User Context → Event Bus → Event Scheduling Context (decoupled)
- ❌ ~~User Context → Event Scheduling Context directly~~ (old tight coupling REMOVED)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story draft created from Epic 1.8 with comprehensive technical context | Bob (Scrum Master) |
| 2025-10-23 | 1.1 | Fixed AC #1 file path to include `/user/` subdirectory; Clarified transaction handling pattern | Bob (Scrum Master) |
| 2025-10-23 | 2.0 | **COMPLETE REWRITE** for bounded context architecture after Story 1.7b folder reorganization. Refactored from "Create User Use Case" to "Refactor Create User Use Case with Domain Events". Changed constructor to use IDomainEventBus instead of Event Scheduling dependencies. Updated all file paths to `src/modules/user/*` structure. Rewrote all tasks, dev notes, and test requirements to reflect event-driven architecture. | Bob (Scrum Master) |

---

## Dev Agent Record

### Status

**NOT YET IMPLEMENTED** - This story requires refactoring the existing CreateUserUseCase implementation.

### Prerequisites

- ✅ Story 1.7b: Bounded Context folder reorganization (COMPLETED)
- ⏳ Story 1.8: Domain Event Bus Infrastructure (TODO)
- ⏳ Story 1.9: UserCreated Event Handler (TODO)

### Implementation Notes

**This story CANNOT be implemented until:**

1. Story 1.8 is complete (`IDomainEventBus`, `InMemoryEventBus` exist)
2. Story 1.9 is complete (`UserCreatedEvent` interface exists)

**Current State:**

The existing CreateUserUseCase (from original Story 1.8) is tightly coupled to Event Scheduling Context. It directly creates Event entities and depends on `IEventRepository`, `TimezoneService`, and `EventHandlerRegistry`.

**Refactoring Goal:**

Remove all Event Scheduling dependencies and replace with domain event publishing pattern.

---

## QA Results

_To be filled by QA Agent after refactoring implementation_
