# Story 1.5: Timezone Service

---

## Status

**Draft**

---

## Story

**As a** developer,
**I want** a domain service that handles timezone conversions using Luxon,
**so that** birthday events are correctly scheduled at 9:00 AM local time.

---

## Acceptance Criteria

1. TimezoneService created in `src/domain/services/TimezoneService.ts`
2. Method `calculateNextBirthday(dateOfBirth, timezone)` returns next birthday at 9:00 AM local time
3. Method `convertToUTC(localTimestamp, timezone)` converts local time to UTC
4. Service correctly handles DST transitions (spring forward, fall back)
5. Service validates timezone against IANA timezone database
6. Unit tests cover timezones: America/New_York, Europe/London, Asia/Tokyo, Australia/Sydney
7. Unit tests cover DST transition edge cases (e.g., March 10, 2024 in New York)
8. Unit tests achieve 100% coverage for TimezoneService

---

## Tasks / Subtasks

- [ ] **Task 1: Create TimezoneService domain service** (AC: 1)
  - [ ] Create `src/domain/services/` directory if it doesn't exist
  - [ ] Create `src/domain/services/TimezoneService.ts` file
  - [ ] Import Luxon DateTime for timezone calculations
  - [ ] Import Timezone and DateOfBirth value objects from domain layer
  - [ ] Define TimezoneService class with constructor (no dependencies)
  - [ ] Ensure zero imports from infrastructure layers (Fastify, Prisma, AWS, adapters)

- [ ] **Task 2: Implement calculateNextBirthday method** (AC: 2, 4)
  - [ ] Define method signature: `calculateNextBirthday(dateOfBirth: DateOfBirth, timezone: Timezone, referenceDate?: DateTime): DateTime`
  - [ ] Use referenceDate parameter (defaults to DateTime.now()) for testability
  - [ ] Extract month and day from DateOfBirth value object
  - [ ] Create DateTime in user's timezone with extracted month/day at 9:00 AM local time
  - [ ] If calculated birthday is in the past relative to referenceDate, add 1 year
  - [ ] Handle leap year birthdays (Feb 29): Use Feb 28 in non-leap years
  - [ ] Handle DST transitions: Ensure 9:00 AM local time is correct even during spring forward/fall back
  - [ ] Return DateTime representing next birthday at 9:00 AM in user's local timezone

- [ ] **Task 3: Implement convertToUTC method** (AC: 3, 4)
  - [ ] Define method signature: `convertToUTC(localTimestamp: DateTime, timezone: Timezone): DateTime`
  - [ ] Set localTimestamp to specified timezone using Luxon `.setZone()`
  - [ ] Convert to UTC using `.toUTC()`
  - [ ] Handle DST transitions automatically via Luxon (no manual offset calculation)
  - [ ] Return UTC DateTime
  - [ ] Add validation: throw error if localTimestamp is invalid

- [ ] **Task 4: Implement timezone validation** (AC: 5)
  - [ ] Create private method `validateTimezone(timezone: Timezone): boolean`
  - [ ] Use Luxon to validate IANA timezone string
  - [ ] Leverage existing Timezone value object validation (already validates in constructor)
  - [ ] Document that Timezone value object handles validation, service methods can trust input

- [ ] **Task 5: Create comprehensive unit tests** (AC: 6, 7, 8)
  - [ ] Create `src/domain/services/TimezoneService.test.ts`
  - [ ] Setup test suite with AAA pattern (Arrange, Act, Assert)
  - [ ] Mock DateTime.now() for deterministic testing using Luxon's mock capabilities or fixed referenceDate
  - [ ] Test calculateNextBirthday with America/New_York timezone
  - [ ] Test calculateNextBirthday with Europe/London timezone
  - [ ] Test calculateNextBirthday with Asia/Tokyo timezone
  - [ ] Test calculateNextBirthday with Australia/Sydney timezone
  - [ ] Test DST spring forward edge case (March 10, 2024 2:00 AM → 3:00 AM in New York)
  - [ ] Test DST fall back edge case (November 3, 2024 2:00 AM → 1:00 AM in New York)
  - [ ] Test leap year birthday (Feb 29) in leap year: returns Feb 29
  - [ ] Test leap year birthday (Feb 29) in non-leap year: returns Feb 28
  - [ ] Test birthday today: should return next year's birthday
  - [ ] Test birthday tomorrow: should return this year's birthday
  - [ ] Test convertToUTC with various timezones (positive and negative UTC offsets)
  - [ ] Test convertToUTC during DST transition periods
  - [ ] Verify 100% code coverage using Jest coverage report

- [ ] **Task 6: Verify domain layer purity** (AC: All)
  - [ ] Run linting to ensure no infrastructure imports
  - [ ] Verify TimezoneService has zero dependencies on Fastify, Prisma, AWS SDK, or adapters
  - [ ] Confirm only Luxon and domain value objects are imported
  - [ ] Run TypeScript compilation in strict mode with zero errors

---

## Dev Notes

### Previous Story Insights

**[Source: Story 1.4 - Dev Agent Record & QA Results]**

Key learnings from Story 1.4 (Domain Layer - User & Event Entities):

1. **Domain Layer Purity Achieved**: Story 1.4 achieved perfect domain purity (10/10) with zero infrastructure dependencies. TimezoneService must maintain this standard.

2. **Immutability Pattern**: All value objects use `readonly` fields and entities return new instances on state changes. TimezoneService should follow this pattern for any internal state.

3. **Timezone Value Object Already Exists**: Story 1.4 created `Timezone` value object with IANA validation using Luxon's `.setZone()` method. TimezoneService can trust Timezone input is already validated.

4. **DateOfBirth Value Object**: Story 1.4 created `DateOfBirth` with method `calculateNextOccurrence(timezone, referenceDate)` that calculates next birthday. **IMPORTANT**: Review if this overlaps with TimezoneService.calculateNextBirthday - consider consolidating logic or clarifying separation of concerns.

5. **Test Coverage Excellence**: Story 1.4 achieved 99.2% coverage with 82 tests. TimezoneService should aim for 100% coverage with similar thoroughness (edge cases, DST, leap years).

6. **Luxon DateTime Usage**: Story 1.4 extensively uses Luxon DateTime for timezone-aware calculations. Follow established patterns from DateOfBirth and Timezone value objects.

---

### Technology Stack

**[Source: architecture/tech-stack.md]**

- **Date/Time Library**: Luxon 3.4.4 (timezone handling)
- **Language**: TypeScript 5.3.3 (strict mode required)
- **Testing Framework**: Jest 29.7.0

**Luxon Capabilities:**
- Native IANA timezone database support
- Automatic DST handling (spring forward, fall back)
- Immutable DateTime objects (all operations return new instances)
- `.setZone(timezone)` for timezone conversion
- `.toUTC()` for UTC conversion

---

### Project Structure

**[Source: architecture/source-tree.md]**

File location for this story:
```
src/domain/services/
├── TimezoneService.ts          # Domain service for timezone calculations
└── TimezoneService.test.ts     # Unit tests (100% coverage required)
```

TimezoneService is a **domain service** because:
- Encapsulates business logic that doesn't naturally fit in a single entity
- Operates on multiple value objects (DateOfBirth, Timezone)
- Pure domain logic with zero infrastructure dependencies

---

### Coding Standards

**[Source: architecture/coding-standards.md]**

#### Domain Layer Purity Requirements
- `src/domain/` must have zero imports from `src/adapters/` or `src/shared/`
- Enforced by linting and architecture tests
- Only allowed imports: Luxon, Node.js built-ins, other domain files

#### Critical Rules for TimezoneService
1. **No `any` Types**: Use explicit typing for all method signatures
2. **No console.log**: Use proper error throwing (no logging in domain layer)
3. **Immutability**: All methods should be pure functions (no side effects)
4. **Explicit Return Types**: All public methods must have explicit return type annotations

#### Naming Conventions
- Class: `TimezoneService` (PascalCase)
- File: `TimezoneService.ts` (PascalCase for domain files)
- Methods: `calculateNextBirthday`, `convertToUTC` (camelCase)
- Test file: `TimezoneService.test.ts`

---

### Domain Service Pattern

**[Source: architecture/coding-standards.md#architecture-principles]**

TimezoneService is a **stateless domain service**:
- No instance state (all methods can be static or instance methods with no fields)
- Pure functions that operate on value objects
- Encapsulates complex timezone calculation logic
- Independent of application use cases or infrastructure

**Design Pattern:**
```typescript
export class TimezoneService {
  // Stateless service - no constructor dependencies needed

  calculateNextBirthday(
    dateOfBirth: DateOfBirth,
    timezone: Timezone,
    referenceDate: DateTime = DateTime.now()
  ): DateTime {
    // Pure function - deterministic output from inputs
  }

  convertToUTC(
    localTimestamp: DateTime,
    timezone: Timezone
  ): DateTime {
    // Pure function - no side effects
  }
}
```

---

### DST Handling Requirements

**[Source: Epic 1 - Story 1.5 AC]**

The service must correctly handle Daylight Saving Time transitions:

**Spring Forward (March 10, 2024 in America/New_York):**
- 2:00 AM local time jumps to 3:00 AM
- If birthday at 9:00 AM, must be correctly scheduled despite clock shift
- Luxon handles this automatically via `.setZone()` and `.toUTC()`

**Fall Back (November 3, 2024 in America/New_York):**
- 2:00 AM local time falls back to 1:00 AM (hour repeats)
- 9:00 AM birthday is unambiguous (after transition)
- Luxon handles this automatically

**Testing Strategy:**
- Use fixed reference dates near DST transitions
- Verify 9:00 AM local time converts to correct UTC during DST and non-DST periods
- Test both positive and negative UTC offset timezones

---

### Leap Year Handling

**[Source: Epic 1 - Story 1.5 AC]**

Birthday on February 29 (leap year birthday):
- **Leap year**: Celebrate on Feb 29
- **Non-leap year**: Celebrate on Feb 28 (NOT March 1)

Implementation approach:
```typescript
const { month, day } = dateOfBirth.getMonthDay(); // { month: 2, day: 29 }
let nextBirthday = referenceDate.set({ month, day, hour: 9, minute: 0 });

// Luxon automatically adjusts invalid dates (Feb 29 in non-leap year → Feb 28)
// OR manually check: if (day === 29 && month === 2 && !nextBirthday.isInLeapYear)
```

---

### Testing

**[Source: architecture/test-strategy.md]**

#### Test File Location
`src/domain/services/TimezoneService.test.ts` (colocated with source)

#### Testing Framework
Jest 29.7.0 with TypeScript support

#### Coverage Requirements
- **100% coverage required** for TimezoneService (critical path)
- All branches, functions, lines, statements must be covered
- Jest configuration enforces critical path coverage thresholds

#### Test Pattern (AAA - Arrange, Act, Assert)
```typescript
describe('TimezoneService', () => {
  describe('calculateNextBirthday', () => {
    it('should calculate next birthday at 9:00 AM local time', () => {
      // Arrange
      const service = new TimezoneService();
      const dateOfBirth = new DateOfBirth('1990-03-15');
      const timezone = new Timezone('America/New_York');
      const referenceDate = DateTime.fromISO('2025-01-01T12:00:00', { zone: 'UTC' });

      // Act
      const nextBirthday = service.calculateNextBirthday(dateOfBirth, timezone, referenceDate);

      // Assert
      expect(nextBirthday.toISODate()).toBe('2025-03-15');
      expect(nextBirthday.hour).toBe(9); // 9:00 AM local
      expect(nextBirthday.zoneName).toBe('America/New_York');
    });
  });
});
```

#### Required Test Scenarios
1. **Multiple Timezones**: America/New_York, Europe/London, Asia/Tokyo, Australia/Sydney
2. **DST Edge Cases**: Spring forward, fall back (March/November 2024 in New York)
3. **Leap Year**: Feb 29 birthday in leap year and non-leap year
4. **Boundary Conditions**: Birthday today, tomorrow, last year, next year
5. **UTC Conversion**: Verify convertToUTC maintains correct moment in time across DST

#### Mocking Strategy
- Use fixed `referenceDate` parameter instead of `DateTime.now()` for deterministic tests
- No need to mock Luxon - use real timezone calculations for accuracy
- Mock-free testing ensures real-world correctness

---

### IMPORTANT: DateOfBirth.calculateNextOccurrence() Co-Existence Strategy

**[Source: Story 1.4 Implementation & Product Owner Decision]**

Story 1.4 created a `DateOfBirth` value object with method:
```typescript
calculateNextOccurrence(timezone: Timezone, referenceDate: DateTime): DateTime
```

**Product Owner Decision (2025-01-21):**

- **Keep both implementations** for now (parallel implementation)
- TimezoneService.calculateNextBirthday() will be implemented independently
- Compare both approaches in practice before making architectural decision
- TimezoneService approach may be more generic for repeatable event occurrences beyond birthdays

**Developer Action Required:**

1. Implement `TimezoneService.calculateNextBirthday()` as specified in Task 2
2. **DO NOT** delegate to or depend on `DateOfBirth.calculateNextOccurrence()`
3. Implement independently to allow comparison
4. Add comparison note in completion notes for future architectural review

#### CRITICAL: Leap Year Discrepancy to Address

Current `DateOfBirth.calculateNextOccurrence()` implementation:

- Feb 29 in non-leap year → **March 1** ❌ (incorrect per Epic requirements)

Epic 1 requirement (Story 1.5 AC):

- Feb 29 in non-leap year → **Feb 28** ✅ (correct)

**Developer Must:**

- Implement TimezoneService.calculateNextBirthday() using **Feb 28** (per Epic)
- Document discrepancy in Dev Agent Record completion notes
- Flag for Product Owner review: Should DateOfBirth.calculateNextOccurrence() be updated to Feb 28?

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-21 | 1.0 | Initial story draft created | Bob (Scrum Master) |
| 2025-01-21 | 1.1 | Updated with PO decision: Keep both calculateNextBirthday implementations for comparison; flagged Feb 29 leap year discrepancy (March 1 vs Feb 28) | Bob (Scrum Master) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

---

## QA Results

*This section will be populated by QA Agent after story completion.*
