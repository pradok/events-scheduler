# Story 2.1: Event Scheduler - Polling & Query Logic

---

## Status

Ready for Review

---

## Story

**As a** developer,
**I want** a scheduler that polls the database every minute for ready events,
**so that** events are detected and processed as soon as they're due.

---

## Acceptance Criteria

1. ClaimReadyEventsUseCase created in `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.ts`
2. Use case queries events where `targetTimestampUTC <= NOW() AND status = 'PENDING'`
3. Query uses `FOR UPDATE SKIP LOCKED` to prevent concurrent scheduler instances from claiming same events
4. Query limits results to 100 events per run to prevent overwhelming the system
5. Use case uses optimistic locking (version field) as secondary safeguard
6. Use case updates claimed events to `PROCESSING` status atomically
7. Unit tests verify query logic with mocked repository
8. Integration tests verify atomic claiming works with real database

---

## Tasks / Subtasks

- [x] **Task 1: Create ClaimReadyEventsUseCase** (AC: 1, 2)
  - [x] Create `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.ts`
  - [x] Implement constructor with DI: `IEventRepository`
  - [x] Implement `execute()` method that calls `eventRepository.claimReadyEvents(100)`
  - [x] Handle empty result case (no events ready)
  - [x] Return array of claimed Event entities
  - [x] Add structured logging using Pino logger

- [x] **Task 2: Implement Atomic Event Claiming Logic** (AC: 2, 3, 4, 5, 6)
  - [x] Verify `IEventRepository.claimReadyEvents()` method exists (already defined)
  - [x] Implementation already exists in `PrismaEventRepository` from Story 1.7
  - [x] Verify implementation uses `FOR UPDATE SKIP LOCKED` in transaction
  - [x] Verify implementation updates status to `PROCESSING` atomically
  - [x] Verify implementation increments `version` field (optimistic locking)
  - [x] Confirm limit parameter is respected (max 100 events)

- [x] **Task 3: Add Error Handling and Logging** (AC: 1)
  - [x] Wrap `claimReadyEvents()` call in try-catch
  - [x] Log start of scheduler execution with timestamp
  - [x] Log number of events claimed
  - [x] Log errors with structured context (error message, stack trace)
  - [x] Rethrow errors (let Lambda handler decide retry strategy)
  - [x] Use `logger.error()` for failures, `logger.info()` for success

- [x] **Task 4: Create Unit Tests for ClaimReadyEventsUseCase** (AC: 7)
  - [x] Create `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.test.ts`
  - [x] Test: should claim ready events from repository
  - [x] Test: should return empty array when no events ready
  - [x] Test: should respect limit parameter (100 events max)
  - [x] Test: should log start, end, and event count
  - [x] Test: should rethrow repository errors
  - [x] Mock `IEventRepository` using Jest
  - [x] Achieve 100% code coverage for ClaimReadyEventsUseCase

- [x] **Task 5: Verify Integration Tests for Atomic Claiming** (AC: 8)
  - [x] Verify integration tests exist in `PrismaEventRepository.integration.test.ts`
  - [x] Confirm test: "should prevent duplicate claims when called concurrently"
  - [x] Confirm test verifies no duplicate event IDs across concurrent calls
  - [x] Confirm test verifies all events transition to PROCESSING status
  - [x] Confirm test uses real PostgreSQL via Testcontainers
  - [x] Run integration tests to verify atomic claiming works correctly

---

## Dev Notes

### Previous Story Insights

**From Story 1.11c (Structured Logging):**
- Pino logger infrastructure is available at `src/shared/logger.ts`
- Use `logger.info()`, `logger.error()`, `logger.warn()` for structured logging
- All error logs must include structured context (userId, eventType, error, stack)
- Console.log/console.error forbidden by ESLint (use logger instead)

**From Story 1.7 (Prisma Repository Implementations):**
- `PrismaEventRepository.claimReadyEvents()` already implemented
- Uses `FOR UPDATE SKIP LOCKED` in PostgreSQL transaction
- Updates events to PROCESSING status atomically
- Increments version field for optimistic locking
- Integration tests verify concurrent claiming works correctly

### Architecture Context

**Bounded Context:**

- This use case belongs to **Event Scheduling Context**
- Located in `src/modules/event-scheduling/application/use-cases/`
- Has NO dependencies on User Context
- Uses only `IEventRepository` port interface (no direct Prisma imports)

**File Location:**

- Use case: `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.ts`
- Unit test: `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.test.ts`
- [Source: architecture/source-tree.md#Event-Scheduling-Context]

### Data Model - Event Entity

**Relevant Event Fields:**
- `status: EventStatus` - PENDING → PROCESSING → COMPLETED/FAILED state machine
- `targetTimestampUTC: DateTime` - When event should execute (UTC timezone)
- `version: number` - Optimistic locking version (incremented on each update)
- `userId: string` - Foreign key to User (for context, not used in scheduler query)
- `eventType: string` - Type of event (BIRTHDAY for Phase 1)

**Status Transitions:**
- PENDING → PROCESSING: Atomic claim by scheduler (this story)
- PROCESSING → COMPLETED: Successful delivery (Story 2.5)
- PROCESSING → FAILED: Permanent failure after retries (Story 2.5)

[Source: architecture/data-models.md#Event]

### Port Interface - IEventRepository

**Method Used in This Story:**

```typescript
claimReadyEvents(limit: number): Promise<Event[]>
```

**What It Does:**
- Queries events where `targetTimestampUTC <= NOW() AND status = 'PENDING'`
- Uses database-specific locking (`FOR UPDATE SKIP LOCKED`) to prevent race conditions
- Atomically updates claimed events to `PROCESSING` status
- Increments `version` field (optimistic locking)
- Limits results to prevent overwhelming system during recovery

**Dual Purpose:**
1. **Normal Operation:** Scheduler polls every minute to claim events ready NOW
2. **Recovery Mode:** After downtime, claims ALL backlogged events from the past

[Source: architecture/port-interfaces.md#IEventRepository, architecture/design-patterns.md#Distributed-Scheduler-Pattern]

### Distributed Scheduler Pattern

**Critical Implementation Detail:**
- `FOR UPDATE SKIP LOCKED` enables multiple scheduler instances to run concurrently
- Each instance claims DIFFERENT events (no duplicates)
- No waiting/deadlocks between instances
- Enables horizontal scaling (add more Lambda instances = more throughput)

**How It Works:**
```sql
-- PostgreSQL row-level locking (already implemented in PrismaEventRepository)
SELECT * FROM events
WHERE status = 'PENDING'
  AND target_timestamp_utc <= NOW()
ORDER BY target_timestamp_utc ASC
LIMIT 100
FOR UPDATE SKIP LOCKED
```

**Transaction Wrapper Required:**
- Locks held from SELECT until UPDATE completes
- Prevents race conditions between concurrent scheduler instances
- Already implemented in `PrismaEventRepository.$transaction()`

[Source: architecture/design-patterns.md#Distributed-Scheduler-Pattern]

### Coding Standards

**TypeScript Requirements:**
- Strict mode enabled (no `any` types)
- Explicit accessibility modifiers (`public`, `private`, `protected`)
- Use async/await (no callbacks or raw promises)
- Repository Pattern required (no direct Prisma calls from use cases)

**Logging Requirements:**
- Use Pino logger exclusively (`src/shared/logger.ts`)
- Structure logs with context fields (eventsClaimed, timestamp, error)
- Log levels: ERROR (failures), INFO (success/metrics), DEBUG (detailed flow)
- Never use `console.log` or `console.error` (ESLint will fail)

**Error Handling:**
- Never swallow errors silently
- Always log and rethrow errors with context
- Use custom error classes where applicable (DomainError, ApplicationError)
- Let Lambda handler decide retry strategy (don't catch and suppress)

[Source: architecture/coding-standards.md]

### Project Structure Alignment

**Use Case Location:**
```
src/modules/event-scheduling/
├── application/
│   └── use-cases/
│       ├── ClaimReadyEventsUseCase.ts          # NEW - This story
│       ├── ClaimReadyEventsUseCase.test.ts     # NEW - This story
│       └── CreateBirthdayEventUseCase.ts       # Existing
```

**Import Rules for Application Layer:**
- ✅ Can import: Domain entities, value objects, domain services
- ✅ Can import: Port interfaces (IEventRepository, ILogger)
- ❌ Cannot import: Adapters (PrismaEventRepository, Pino directly)
- ❌ Cannot import: External frameworks (Prisma, AWS SDK)

[Source: architecture/source-tree.md#Import-Rules]

### Testing

**Unit Test Requirements:**

- Test file location: `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.test.ts`
- Use Jest as testing framework
- Mock `IEventRepository` using Jest mocks
- Follow AAA pattern (Arrange, Act, Assert)
- Achieve 100% code coverage for ClaimReadyEventsUseCase
- Test all edge cases: empty results, errors, successful claiming

**Integration Test Requirements:**
- Integration tests already exist in `PrismaEventRepository.integration.test.ts`
- Verify atomic claiming with concurrent calls using `Promise.all()`
- Use Testcontainers for real PostgreSQL database
- Test verifies no duplicate event IDs claimed
- Test verifies all events transition to PROCESSING status
- Test verifies version field incremented correctly

**Test Naming Convention:**
- File: `{ClassName}.test.ts` or `{ClassName}.integration.test.ts`
- Describe: Use class/method names
- It: Descriptive test names explaining behavior
  - Good: "should claim ready events and return array"
  - Bad: "test scheduler" or "should work"

[Source: architecture/test-strategy.md]

### Expected ClaimReadyEventsUseCase Implementation Skeleton

```typescript
// src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.ts
import { IEventRepository } from '../ports/IEventRepository';
import { Event } from '../../domain/entities/Event';
import { logger } from '../../../../shared/logger';

/**
 * Use case that polls for ready events and claims them atomically.
 *
 * This use case is invoked every minute by EventBridge (Story 2.3).
 * It queries the database for events that are ready to execute
 * (targetTimestampUTC <= now) and atomically claims them by updating
 * their status to PROCESSING.
 *
 * The atomic claiming logic is implemented in PrismaEventRepository
 * using PostgreSQL FOR UPDATE SKIP LOCKED to prevent race conditions
 * when multiple scheduler instances run concurrently.
 */
export class ClaimReadyEventsUseCase {
  public constructor(
    private readonly eventRepository: IEventRepository
  ) {}

  /**
   * Claims ready events from the database atomically.
   *
   * @returns Array of claimed Event entities (status = PROCESSING)
   */
  public async execute(): Promise<Event[]> {
    const startTime = Date.now();

    logger.info('ClaimReadyEvents execution started');

    try {
      // Claim up to 100 ready events atomically
      const claimedEvents = await this.eventRepository.claimReadyEvents(100);

      const duration = Date.now() - startTime;

      logger.info({
        msg: 'ClaimReadyEvents execution completed',
        eventsClaimed: claimedEvents.length,
        durationMs: duration,
      });

      return claimedEvents;
    } catch (error) {
      logger.error({
        msg: 'ClaimReadyEvents execution failed',
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
      });

      // Rethrow error - let Lambda handler decide retry strategy
      throw error;
    }
  }
}
```

### Dependencies

**Required Imports:**
- `IEventRepository` from `../ports/IEventRepository` (port interface)
- `Event` from `../../domain/entities/Event` (domain entity)
- `logger` from `../../../../shared/logger` (Pino logger singleton)

**Injected Dependencies (Constructor):**
- `IEventRepository` - For claiming ready events (already implemented)

**No Additional Ports Needed:**
- This story does NOT require SQS integration (Story 2.2)
- This story does NOT require Lambda handler (Story 2.3)
- Focus is purely on the use case logic and unit tests

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Created story for Event Scheduler service | Bob (Scrum Master) |
| 2025-10-24 | 1.1 | Renamed SchedulerService to ClaimReadyEventsUseCase for consistency with codebase naming conventions | Bob (Scrum Master) |
| 2025-10-24 | 1.2 | Implemented ClaimReadyEventsUseCase with TDD, 100% coverage, all tests passing | James (Dev Agent) |

---

## Dev Agent Record

### Agent Model Used

Claude 3.5 Sonnet (claude-sonnet-4-5-20250929)

### Debug Log References

No debugging required - implementation completed successfully on first attempt following TDD workflow.

### Completion Notes

**Implementation Summary:**

- ✅ Created ClaimReadyEventsUseCase following TDD (Red-Green-Refactor)
- ✅ Achieved 100% code coverage with 10 comprehensive unit tests
- ✅ All 302 tests passing (including existing integration tests)
- ✅ ESLint passed with zero violations
- ✅ Proper error handling and structured logging with Pino
- ✅ Followed hexagonal architecture (dependency injection via IEventRepository port)
- ✅ No direct Prisma imports in use case (clean architecture boundaries)

**TDD Workflow:**

1. **Red Phase:** Wrote failing tests first (10 test cases covering all scenarios)
2. **Green Phase:** Implemented minimal code to pass all tests
3. **Refactor Phase:** N/A - implementation was clean on first pass

**Key Implementation Details:**

- Constructor accepts `IEventRepository` (port interface, not concrete implementation)
- `execute()` method calls `claimReadyEvents(100)` with hardcoded limit
- Structured logging with `logger.info()` and `logger.error()`
- Error handling: logs and rethrows (Lambda retry strategy preserved)
- Proper TypeScript types (no `any`, explicit accessibility modifiers)

**Testing:**

- Unit tests: 10 tests, 100% coverage
- Integration tests: Verified existing test "should prevent duplicate claims when called concurrently" passes
- Test scenarios: happy path, empty results, error handling, logging verification

**Atomic Claiming Verification:**

- Confirmed `PrismaEventRepository.claimReadyEvents()` uses `FOR UPDATE SKIP LOCKED`
- Confirmed transaction wrapper holds locks from SELECT to UPDATE
- Confirmed version field increments atomically
- Confirmed limit parameter respected (100 events max)

### File List

**Created:**

- `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.ts` (66 lines)
- `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.test.ts` (230 lines)

**Modified:**

- None (no existing files modified)

**Verified (No changes needed):**

- `src/modules/event-scheduling/application/ports/IEventRepository.ts` (method exists at line 86)
- `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.ts` (implementation verified at line 128)
- `src/modules/event-scheduling/adapters/persistence/PrismaEventRepository.integration.test.ts` (integration test verified at line 349)

---

## QA Results

### Review Date: 2025-10-24

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Rating: EXEMPLARY** ⭐⭐⭐⭐⭐

This implementation represents a gold standard for use case development in this codebase. The developer (James) has delivered a textbook example of:

- **Hexagonal Architecture:** Perfect dependency inversion via `IEventRepository` port
- **TDD Excellence:** Red-Green-Refactor workflow with 100% coverage
- **Clean Code:** Self-documenting with appropriate comments
- **Test Design:** Comprehensive AAA-pattern tests covering all scenarios

**Key Strengths:**

1. **Architecture Compliance:**
   - Zero violations of bounded context rules
   - No direct adapter imports (Prisma isolated)
   - Proper dependency injection
   - Single Responsibility Principle

2. **Test Coverage:**
   - 10 unit tests with 100% code coverage
   - Integration test reuse (atomic claiming verified)
   - Edge cases: empty results, Error/non-Error exceptions
   - Observability: logging behavior verified

3. **Documentation:**
   - Comprehensive JSDoc with @see references
   - Inline comments explain business logic
   - Test names clearly describe behavior

4. **Error Handling:**
   - Structured logging with Pino (no console.log)
   - Log-and-rethrow pattern preserves Lambda retry
   - Handles both Error and non-Error exceptions

### Refactoring Performed

**No refactoring needed.** Implementation is production-ready as-is.

### Compliance Check

- **Coding Standards:** ✅ PASS
  - TypeScript strict mode (no `any` types)
  - Explicit accessibility modifiers
  - Async/await (no callbacks)
  - Pino logging (ESLint enforced)

- **Project Structure:** ✅ PASS
  - Correct location: `src/modules/event-scheduling/application/use-cases/`
  - Test co-located with implementation
  - Follows module organization

- **Testing Strategy:** ✅ PASS
  - TDD workflow followed
  - 100% coverage achieved
  - AAA pattern applied consistently
  - Proper test pyramid (unit + integration)

- **All ACs Met:** ✅ PASS (8/8)
  - AC1-8 fully implemented and tested
  - See Requirements Traceability Matrix in gate file

### Requirements Traceability (Given-When-Then)

All 8 Acceptance Criteria mapped to tests:

**AC1: ClaimReadyEventsUseCase created**

- **Given:** Project structure requires use cases in application layer
- **When:** Developer creates ClaimReadyEventsUseCase.ts
- **Then:** File exists at correct path
- **Coverage:** ✅ Verified via file system

**AC2: Query events where targetTimestampUTC <= NOW() AND status = PENDING**

- **Given:** Repository interface defines claimReadyEvents(limit)
- **When:** execute() is called
- **Then:** eventRepository.claimReadyEvents(100) is invoked
- **Coverage:** ✅ Test line 42-59, 74-87

**AC3: FOR UPDATE SKIP LOCKED prevents concurrent claiming**

- **Given:** Multiple scheduler instances run concurrently
- **When:** Instances call claimReadyEvents simultaneously
- **Then:** Each claims different events (no duplicates)
- **Coverage:** ✅ Integration test line 349-418

**AC4: Query limits results to 100 events**

- **Given:** System may have thousands of backlogged events
- **When:** execute() is called
- **Then:** Maximum 100 events claimed
- **Coverage:** ✅ Test line 74-87, hardcoded limit line 44

**AC5: Optimistic locking (version field)**

- **Given:** Database uses optimistic locking
- **When:** Events claimed atomically
- **Then:** Version field incremented
- **Coverage:** ✅ PrismaEventRepository.ts:172, integration test:418

**AC6: Atomic status update to PROCESSING**

- **Given:** Events start as PENDING
- **When:** claimReadyEvents() executes
- **Then:** Events transition to PROCESSING in transaction
- **Coverage:** ✅ PrismaEventRepository.ts:166-174, integration test:417

**AC7: Unit tests with mocked repository**

- **Given:** Use case depends on IEventRepository
- **When:** Tests execute
- **Then:** Repository mocked, all scenarios covered
- **Coverage:** ✅ 10 tests, 100% coverage

**AC8: Integration tests verify atomic claiming**

- **Given:** Real PostgreSQL via Testcontainers
- **When:** Concurrent instances claim events
- **Then:** No duplicates, all PROCESSING
- **Coverage:** ✅ Integration test line 349-418

### Security Review

**Status: PASS** ✅

**Findings:**

- ✅ No sensitive data logged (error messages exclude PII)
- ✅ Port-based architecture prevents SQL injection (parameterized queries in adapter)
- ✅ No hardcoded secrets or credentials
- ✅ Error handling doesn't leak internal implementation details

**Observations:**

- Atomic claiming prevents unauthorized access to events
- Optimistic locking protects against concurrent modification
- Clean separation of concerns enhances security auditability

### Performance Considerations

**Status: PASS** ✅

**Findings:**

- ✅ Hardcoded limit of 100 events prevents overwhelming system
- ✅ Atomic claiming reduces lock contention (FOR UPDATE SKIP LOCKED)
- ✅ Structured logging includes duration metrics for monitoring
- ✅ Minimal memory footprint (single method, no state)

**Observations:**

- Duration logging (line 46-52) enables performance monitoring
- Limit of 100 is appropriate for initial deployment
- Future: May need parameterization for production tuning

**Future Optimization Opportunities:**

1. Consider parameterizing limit via configuration (environment variable)
2. Add correlation ID for distributed tracing (Story 2.3+)
3. Monitor execution duration metrics in production for tuning

### Reliability Assessment

**Status: PASS** ✅

**Findings:**

- ✅ Error handling with rethrow preserves Lambda retry strategy
- ✅ Atomic operations prevent partial state corruption
- ✅ Optimistic locking provides double-check safety
- ✅ Empty result case handled gracefully

**Observations:**

- Log-and-rethrow pattern (line 55-64) is correct for Lambda
- Transaction guarantees in PrismaEventRepository ensure atomicity
- Integration test verifies reliability under concurrent load

### Maintainability Assessment

**Status: PASS** ✅

**Findings:**

- ✅ Self-documenting code with clear intent
- ✅ Comprehensive documentation (class + method JSDoc)
- ✅ Clean separation of concerns
- ✅ Consistent naming conventions
- ✅ AAA test pattern consistently applied

**Observations:**

- Code is easy to understand for new developers
- Test names clearly explain behavior ("should claim ready events")
- Helper function `createMockEvent()` improves test maintainability
- Cross-references to architecture docs (@see tags) aid navigation

### Test Architecture Assessment

**Unit Tests: EXCELLENT** (10 tests, 100% coverage)

- AAA pattern consistently applied
- Proper mock isolation (IEventRepository, logger)
- Comprehensive edge cases:
  - Empty results
  - Error vs non-Error exceptions
  - Logging behavior verification
- Helper function for test data generation

**Integration Tests: EXCELLENT** (reused from Story 1.7)

- Real PostgreSQL via Testcontainers
- Concurrent execution via Promise.all()
- Verifies critical property: no duplicate claims
- Validates atomic transitions and version increments

**Test Pyramid Compliance: EXCELLENT**

- Perfect balance: 10 fast unit tests + 1 integration test
- No E2E tests needed (not exposed via API yet)
- Total execution time < 1 second (unit tests)

### Files Modified During Review

**None.** No refactoring or improvements needed.

### Gate Status

**Gate: PASS** → [docs/qa/gates/2.1-event-scheduler-polling-query.yml](../qa/gates/2.1-event-scheduler-polling-query.yml)

**Quality Score: 100/100**

**Risk Level: LOW** (Overall risk score: 1.2/10)

**Risk Breakdown:**

- Concurrency risk: 1/10 (mitigated by FOR UPDATE SKIP LOCKED)
- Data corruption risk: 1/10 (atomic transactions)
- Performance risk: 2/10 (limit prevents overload)
- Testability risk: 1/10 (excellent test coverage)
- Maintainability risk: 1/10 (clean architecture)

**NFR Validation:**

- Security: PASS ✅
- Performance: PASS ✅
- Reliability: PASS ✅
- Maintainability: PASS ✅

### Recommendations

**Immediate Actions:** None required.

**Future Enhancements (Optional):**

1. **Parameterize event limit** (line 44)
   - Current: Hardcoded 100
   - Suggested: Environment variable for production tuning
   - Rationale: Different environments may need different batch sizes

2. **Add correlation ID** (Story 2.3+)
   - Current: Logs lack distributed tracing context
   - Suggested: Include correlationId in log context
   - Rationale: Enables end-to-end request tracing

These are nice-to-have improvements, not blockers.

### Recommended Status

**✅ READY FOR DONE**

**Justification:**

- All 8 acceptance criteria fully met
- 100% test coverage with comprehensive scenarios
- Zero technical debt introduced
- Exemplary code quality and documentation
- All NFRs validated (security, performance, reliability, maintainability)
- No refactoring needed

**Summary:**

This story sets a high bar for quality in Epic 2. The implementation is production-ready and requires no changes before deployment. Excellent work by the development team.

---

**Review Completed by Quinn (Test Architect)**
**Gate Decision: PASS**
**Quality Score: 100/100**
