# Story 2.1: Event Scheduler - Polling & Query Logic

---

## Status

Draft

---

## Story

**As a** developer,
**I want** a scheduler that polls the database every minute for ready events,
**so that** events are detected and processed as soon as they're due.

---

## Acceptance Criteria

1. ClaimReadyEventsUseCase created in `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.ts`
2. Use case queries events where `targetTimestampUTC <= NOW() AND status = 'PENDING'`
3. Query uses `FOR UPDATE SKIP LOCKED` to prevent concurrent scheduler instances from claiming same events
4. Query limits results to 100 events per run to prevent overwhelming the system
5. Use case uses optimistic locking (version field) as secondary safeguard
6. Use case updates claimed events to `PROCESSING` status atomically
7. Unit tests verify query logic with mocked repository
8. Integration tests verify atomic claiming works with real database

---

## Tasks / Subtasks

- [ ] **Task 1: Create ClaimReadyEventsUseCase** (AC: 1, 2)
  - [ ] Create `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.ts`
  - [ ] Implement constructor with DI: `IEventRepository`
  - [ ] Implement `execute()` method that calls `eventRepository.claimReadyEvents(100)`
  - [ ] Handle empty result case (no events ready)
  - [ ] Return array of claimed Event entities
  - [ ] Add structured logging using Pino logger

- [ ] **Task 2: Implement Atomic Event Claiming Logic** (AC: 2, 3, 4, 5, 6)
  - [ ] Verify `IEventRepository.claimReadyEvents()` method exists (already defined)
  - [ ] Implementation already exists in `PrismaEventRepository` from Story 1.7
  - [ ] Verify implementation uses `FOR UPDATE SKIP LOCKED` in transaction
  - [ ] Verify implementation updates status to `PROCESSING` atomically
  - [ ] Verify implementation increments `version` field (optimistic locking)
  - [ ] Confirm limit parameter is respected (max 100 events)

- [ ] **Task 3: Add Error Handling and Logging** (AC: 1)
  - [ ] Wrap `claimReadyEvents()` call in try-catch
  - [ ] Log start of scheduler execution with timestamp
  - [ ] Log number of events claimed
  - [ ] Log errors with structured context (error message, stack trace)
  - [ ] Rethrow errors (let Lambda handler decide retry strategy)
  - [ ] Use `logger.error()` for failures, `logger.info()` for success

- [ ] **Task 4: Create Unit Tests for ClaimReadyEventsUseCase** (AC: 7)
  - [ ] Create `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.test.ts`
  - [ ] Test: should claim ready events from repository
  - [ ] Test: should return empty array when no events ready
  - [ ] Test: should respect limit parameter (100 events max)
  - [ ] Test: should log start, end, and event count
  - [ ] Test: should rethrow repository errors
  - [ ] Mock `IEventRepository` using Jest
  - [ ] Achieve 100% code coverage for ClaimReadyEventsUseCase

- [ ] **Task 5: Verify Integration Tests for Atomic Claiming** (AC: 8)
  - [ ] Verify integration tests exist in `PrismaEventRepository.integration.test.ts`
  - [ ] Confirm test: "should prevent duplicate claims when called concurrently"
  - [ ] Confirm test verifies no duplicate event IDs across concurrent calls
  - [ ] Confirm test verifies all events transition to PROCESSING status
  - [ ] Confirm test uses real PostgreSQL via Testcontainers
  - [ ] Run integration tests to verify atomic claiming works correctly

---

## Dev Notes

### Previous Story Insights

**From Story 1.11c (Structured Logging):**
- Pino logger infrastructure is available at `src/shared/logger.ts`
- Use `logger.info()`, `logger.error()`, `logger.warn()` for structured logging
- All error logs must include structured context (userId, eventType, error, stack)
- Console.log/console.error forbidden by ESLint (use logger instead)

**From Story 1.7 (Prisma Repository Implementations):**
- `PrismaEventRepository.claimReadyEvents()` already implemented
- Uses `FOR UPDATE SKIP LOCKED` in PostgreSQL transaction
- Updates events to PROCESSING status atomically
- Increments version field for optimistic locking
- Integration tests verify concurrent claiming works correctly

### Architecture Context

**Bounded Context:**

- This use case belongs to **Event Scheduling Context**
- Located in `src/modules/event-scheduling/application/use-cases/`
- Has NO dependencies on User Context
- Uses only `IEventRepository` port interface (no direct Prisma imports)

**File Location:**

- Use case: `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.ts`
- Unit test: `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.test.ts`
- [Source: architecture/source-tree.md#Event-Scheduling-Context]

### Data Model - Event Entity

**Relevant Event Fields:**
- `status: EventStatus` - PENDING → PROCESSING → COMPLETED/FAILED state machine
- `targetTimestampUTC: DateTime` - When event should execute (UTC timezone)
- `version: number` - Optimistic locking version (incremented on each update)
- `userId: string` - Foreign key to User (for context, not used in scheduler query)
- `eventType: string` - Type of event (BIRTHDAY for Phase 1)

**Status Transitions:**
- PENDING → PROCESSING: Atomic claim by scheduler (this story)
- PROCESSING → COMPLETED: Successful delivery (Story 2.5)
- PROCESSING → FAILED: Permanent failure after retries (Story 2.5)

[Source: architecture/data-models.md#Event]

### Port Interface - IEventRepository

**Method Used in This Story:**

```typescript
claimReadyEvents(limit: number): Promise<Event[]>
```

**What It Does:**
- Queries events where `targetTimestampUTC <= NOW() AND status = 'PENDING'`
- Uses database-specific locking (`FOR UPDATE SKIP LOCKED`) to prevent race conditions
- Atomically updates claimed events to `PROCESSING` status
- Increments `version` field (optimistic locking)
- Limits results to prevent overwhelming system during recovery

**Dual Purpose:**
1. **Normal Operation:** Scheduler polls every minute to claim events ready NOW
2. **Recovery Mode:** After downtime, claims ALL backlogged events from the past

[Source: architecture/port-interfaces.md#IEventRepository, architecture/design-patterns.md#Distributed-Scheduler-Pattern]

### Distributed Scheduler Pattern

**Critical Implementation Detail:**
- `FOR UPDATE SKIP LOCKED` enables multiple scheduler instances to run concurrently
- Each instance claims DIFFERENT events (no duplicates)
- No waiting/deadlocks between instances
- Enables horizontal scaling (add more Lambda instances = more throughput)

**How It Works:**
```sql
-- PostgreSQL row-level locking (already implemented in PrismaEventRepository)
SELECT * FROM events
WHERE status = 'PENDING'
  AND target_timestamp_utc <= NOW()
ORDER BY target_timestamp_utc ASC
LIMIT 100
FOR UPDATE SKIP LOCKED
```

**Transaction Wrapper Required:**
- Locks held from SELECT until UPDATE completes
- Prevents race conditions between concurrent scheduler instances
- Already implemented in `PrismaEventRepository.$transaction()`

[Source: architecture/design-patterns.md#Distributed-Scheduler-Pattern]

### Coding Standards

**TypeScript Requirements:**
- Strict mode enabled (no `any` types)
- Explicit accessibility modifiers (`public`, `private`, `protected`)
- Use async/await (no callbacks or raw promises)
- Repository Pattern required (no direct Prisma calls from use cases)

**Logging Requirements:**
- Use Pino logger exclusively (`src/shared/logger.ts`)
- Structure logs with context fields (eventsClaimed, timestamp, error)
- Log levels: ERROR (failures), INFO (success/metrics), DEBUG (detailed flow)
- Never use `console.log` or `console.error` (ESLint will fail)

**Error Handling:**
- Never swallow errors silently
- Always log and rethrow errors with context
- Use custom error classes where applicable (DomainError, ApplicationError)
- Let Lambda handler decide retry strategy (don't catch and suppress)

[Source: architecture/coding-standards.md]

### Project Structure Alignment

**Use Case Location:**
```
src/modules/event-scheduling/
├── application/
│   └── use-cases/
│       ├── ClaimReadyEventsUseCase.ts          # NEW - This story
│       ├── ClaimReadyEventsUseCase.test.ts     # NEW - This story
│       └── CreateBirthdayEventUseCase.ts       # Existing
```

**Import Rules for Application Layer:**
- ✅ Can import: Domain entities, value objects, domain services
- ✅ Can import: Port interfaces (IEventRepository, ILogger)
- ❌ Cannot import: Adapters (PrismaEventRepository, Pino directly)
- ❌ Cannot import: External frameworks (Prisma, AWS SDK)

[Source: architecture/source-tree.md#Import-Rules]

### Testing

**Unit Test Requirements:**

- Test file location: `src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.test.ts`
- Use Jest as testing framework
- Mock `IEventRepository` using Jest mocks
- Follow AAA pattern (Arrange, Act, Assert)
- Achieve 100% code coverage for ClaimReadyEventsUseCase
- Test all edge cases: empty results, errors, successful claiming

**Integration Test Requirements:**
- Integration tests already exist in `PrismaEventRepository.integration.test.ts`
- Verify atomic claiming with concurrent calls using `Promise.all()`
- Use Testcontainers for real PostgreSQL database
- Test verifies no duplicate event IDs claimed
- Test verifies all events transition to PROCESSING status
- Test verifies version field incremented correctly

**Test Naming Convention:**
- File: `{ClassName}.test.ts` or `{ClassName}.integration.test.ts`
- Describe: Use class/method names
- It: Descriptive test names explaining behavior
  - Good: "should claim ready events and return array"
  - Bad: "test scheduler" or "should work"

[Source: architecture/test-strategy.md]

### Expected ClaimReadyEventsUseCase Implementation Skeleton

```typescript
// src/modules/event-scheduling/application/use-cases/ClaimReadyEventsUseCase.ts
import { IEventRepository } from '../ports/IEventRepository';
import { Event } from '../../domain/entities/Event';
import { logger } from '../../../../shared/logger';

/**
 * Use case that polls for ready events and claims them atomically.
 *
 * This use case is invoked every minute by EventBridge (Story 2.3).
 * It queries the database for events that are ready to execute
 * (targetTimestampUTC <= now) and atomically claims them by updating
 * their status to PROCESSING.
 *
 * The atomic claiming logic is implemented in PrismaEventRepository
 * using PostgreSQL FOR UPDATE SKIP LOCKED to prevent race conditions
 * when multiple scheduler instances run concurrently.
 */
export class ClaimReadyEventsUseCase {
  public constructor(
    private readonly eventRepository: IEventRepository
  ) {}

  /**
   * Claims ready events from the database atomically.
   *
   * @returns Array of claimed Event entities (status = PROCESSING)
   */
  public async execute(): Promise<Event[]> {
    const startTime = Date.now();

    logger.info('ClaimReadyEvents execution started');

    try {
      // Claim up to 100 ready events atomically
      const claimedEvents = await this.eventRepository.claimReadyEvents(100);

      const duration = Date.now() - startTime;

      logger.info({
        msg: 'ClaimReadyEvents execution completed',
        eventsClaimed: claimedEvents.length,
        durationMs: duration,
      });

      return claimedEvents;
    } catch (error) {
      logger.error({
        msg: 'ClaimReadyEvents execution failed',
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
      });

      // Rethrow error - let Lambda handler decide retry strategy
      throw error;
    }
  }
}
```

### Dependencies

**Required Imports:**
- `IEventRepository` from `../ports/IEventRepository` (port interface)
- `Event` from `../../domain/entities/Event` (domain entity)
- `logger` from `../../../../shared/logger` (Pino logger singleton)

**Injected Dependencies (Constructor):**
- `IEventRepository` - For claiming ready events (already implemented)

**No Additional Ports Needed:**
- This story does NOT require SQS integration (Story 2.2)
- This story does NOT require Lambda handler (Story 2.3)
- Focus is purely on the use case logic and unit tests

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Created story for Event Scheduler service | Bob (Scrum Master) |
| 2025-10-24 | 1.1 | Renamed SchedulerService to ClaimReadyEventsUseCase for consistency with codebase naming conventions | Bob (Scrum Master) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

*To be completed by dev agent*

### Debug Log References

*To be completed by dev agent*

### Completion Notes

*To be completed by dev agent*

### File List

*To be completed by dev agent*

---

## QA Results

*This section will be populated by the QA agent after story completion.*
