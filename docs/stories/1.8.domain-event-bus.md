# Story 1.8: Domain Event Bus Infrastructure

---

## Status

Todo

---

## Story

**As a** developer,
**I want** an event bus abstraction for in-process domain event communication,
**so that** bounded contexts can communicate without direct dependencies.

---

## Acceptance Criteria

1. IDomainEventBus interface created in `src/shared/events/IDomainEventBus.ts`
2. Interface defines:
   - `publish<T extends DomainEvent>(event: T): Promise<void>`
   - `subscribe<T extends DomainEvent>(eventType: string, handler: (event: T) => Promise<void>): void`
3. Base DomainEvent interface created with common properties (eventType, context, occurredAt, aggregateId)
4. InMemoryEventBus implementation created in `src/shared/events/InMemoryEventBus.ts`
5. InMemoryEventBus stores handlers in Map<eventType, handler[]>
6. InMemoryEventBus executes handlers sequentially (preserves ordering)
7. InMemoryEventBus logs errors but continues processing other handlers (resilient)
8. Unit tests achieve 100% coverage for InMemoryEventBus
9. All code passes ESLint with 0 errors and strict TypeScript compilation

---

## Tasks / Subtasks

- [ ] **Task 1: Define IDomainEventBus interface** (AC: 1, 2)
  - [ ] Create `src/shared/events/IDomainEventBus.ts`
  - [ ] Define `IDomainEventBus` interface with generic type parameter `<T extends DomainEvent>`
  - [ ] Define `publish()` method signature:
    - Input: `event: T` (generic domain event)
    - Output: `Promise<void>`
    - Purpose: Publish domain event to all registered handlers
  - [ ] Define `subscribe()` method signature:
    - Input: `eventType: string` (e.g., "UserCreated")
    - Input: `handler: (event: T) => Promise<void>` (async event handler)
    - Output: `void`
    - Purpose: Register event handler for specific event type
  - [ ] Add JSDoc comments explaining interface purpose and usage

- [ ] **Task 2: Create base DomainEvent interface** (AC: 3)
  - [ ] Create `src/shared/events/DomainEvent.ts`
  - [ ] Define `DomainEvent` interface with required properties:
    - `eventType: string` - Event type identifier (e.g., "UserCreated")
    - `context: string` - Bounded context name (e.g., "user", "event-scheduling")
    - `occurredAt: string` - ISO 8601 timestamp when event occurred
    - `aggregateId: string` - ID of aggregate root that emitted event
  - [ ] Add JSDoc comments explaining each property
  - [ ] Export interface for use across contexts

- [ ] **Task 3: Implement InMemoryEventBus** (AC: 4, 5)
  - [ ] Create `src/shared/events/InMemoryEventBus.ts`
  - [ ] Define `InMemoryEventBus` class implementing `IDomainEventBus`
  - [ ] Add private field: `handlers: Map<string, Array<(event: any) => Promise<void>>>`
  - [ ] Initialize empty Map in constructor
  - [ ] Implement `subscribe()` method:
    - Check if eventType key exists in Map
    - If not, initialize empty array for eventType
    - Push handler function to array
  - [ ] Follow coding standards: explicit types, no `any` types, PascalCase class name

- [ ] **Task 4: Implement publish() with sequential execution** (AC: 6, 7)
  - [ ] Implement `publish()` method:
    - Get handlers array for `event.eventType` from Map
    - If no handlers registered, return early (no-op)
    - Iterate through handlers array sequentially (NOT parallel)
    - Use `for...of` loop with `await` (preserves execution order)
    - Wrap each handler call in try-catch block
    - On error: Log error with event details, continue to next handler
    - Return after all handlers complete
  - [ ] Add error logging with structured format:
    - Event type, handler index, error message, stack trace
  - [ ] Ensure errors in one handler don't block other handlers

- [ ] **Task 5: Write comprehensive unit tests** (AC: 8)
  - [ ] Create `src/shared/events/InMemoryEventBus.test.ts`
  - [ ] Test: "should register event handler for event type"
    - Arrange: Create event bus, mock handler
    - Act: Call `eventBus.subscribe('TestEvent', mockHandler)`
    - Assert: Handler registered internally (use test spy)
  - [ ] Test: "should publish event to all registered handlers"
    - Arrange: Create event bus, register 2 handlers for same event type
    - Act: Publish event
    - Assert: Both handlers called with event payload
  - [ ] Test: "should execute handlers sequentially (not parallel)"
    - Arrange: Create event bus, register 3 handlers with delays
    - Act: Publish event
    - Assert: Handlers executed in order (use execution timestamps)
  - [ ] Test: "should continue processing handlers if one throws error"
    - Arrange: Register 3 handlers, make 2nd handler throw error
    - Act: Publish event
    - Assert: Handlers 1 and 3 executed, error logged
  - [ ] Test: "should handle multiple event types independently"
    - Arrange: Register handlers for "UserCreated" and "UserDeleted"
    - Act: Publish "UserCreated" event
    - Assert: Only UserCreated handlers called
  - [ ] Test: "should do nothing if no handlers registered for event type"
    - Arrange: Create event bus (no handlers)
    - Act: Publish event
    - Assert: No errors thrown
  - [ ] Achieve 100% code coverage (branches, statements, lines)

- [ ] **Task 6: Add example domain event for testing** (AC: 3)
  - [ ] Create `src/shared/events/TestEvent.ts` (for tests only)
  - [ ] Define `TestEvent` interface extending `DomainEvent`:
    - All base properties (eventType, context, occurredAt, aggregateId)
    - Example payload property: `testData: string`
  - [ ] Use this event in unit tests
  - [ ] Document as example for future domain events

- [ ] **Task 7: Verify ESLint and TypeScript compilation** (AC: 9)
  - [ ] Run `npx eslint src/shared/events/` and fix all errors
  - [ ] Run `npx tsc --noEmit` and verify strict mode passes
  - [ ] Ensure no `any` types (use generics or explicit types)
  - [ ] Ensure all async functions have proper error handling

---

## Dev Notes

This story implements the **Domain Event Bus** foundation for bounded context communication. It enables User Context and Event Scheduling Context to communicate via domain events without direct dependencies.

### Architecture Context

**[Source: architecture/bounded-contexts.md]**

This implementation belongs in:
- **Location:** `src/shared/events/`
- **Layer:** Shared infrastructure (cross-cutting concern)
- **Purpose:** Enable bounded contexts to publish/subscribe to domain events

**Why In-Memory Event Bus?**
- **Phase 1 (MVP):** In-process communication is fast (<1ms), simple to debug, and sufficient for monolith
- **Phase 2 (10K-100K users):** Swap to EventBridge for microservices (zero code changes in use cases)

---

### Design Pattern: Publish-Subscribe (Pub/Sub)

**Pattern Overview:**
- **Publishers** (User Context) publish domain events to event bus
- **Subscribers** (Event Scheduling Context) register handlers for specific event types
- **Event Bus** routes events to all registered handlers for that event type

**Key Benefits:**
- **Decoupling:** Publishers don't know about subscribers
- **Extensibility:** Add new subscribers without changing publishers
- **Testability:** Mock event bus in unit tests

---

### Implementation Strategy: Sequential Execution

**Why Sequential (not Parallel)?**

```typescript
// ❌ WRONG: Parallel execution (race conditions)
await Promise.all(handlers.map(handler => handler(event)));

// ✅ CORRECT: Sequential execution (predictable order)
for (const handler of handlers) {
  await handler(event);
}
```

**Rationale:**
1. **Predictable ordering:** Handlers execute in registration order
2. **Easier debugging:** Event handler failures are isolated
3. **Database consistency:** If multiple handlers update DB, sequential prevents conflicts
4. **Future-proof:** When migrating to EventBridge, ordering is preserved

**Performance Impact:**
- MVP: 2-3 handlers per event × 1-2ms = 3-6ms overhead (negligible)
- 10K users: Still negligible (in-process is fast)
- 100K users: Switch to EventBridge (async by default)

---

### Error Handling Strategy

**Philosophy: Resilient Event Processing**

```typescript
async publish<T extends DomainEvent>(event: T): Promise<void> {
  const handlers = this.handlers.get(event.eventType) || [];

  for (const handler of handlers) {
    try {
      await handler(event);
    } catch (error) {
      // ✅ Log error but CONTINUE processing other handlers
      console.error('Event handler failed', {
        eventType: event.eventType,
        aggregateId: event.aggregateId,
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      });
      // DO NOT rethrow - continue to next handler
    }
  }
}
```

**Why Continue on Error?**
- If UserCreated handler #1 (create birthday event) fails, handler #2 (send welcome email) should still run
- Failed handlers can be retried by recovery job (self-healing)
- Prevents cascading failures

---

### Testing Strategy

**Unit Test Coverage Requirements:**

1. **Happy Path:**
   - Single handler receives event
   - Multiple handlers all receive same event
   - Handler receives correct event payload

2. **Edge Cases:**
   - No handlers registered (no-op, no error)
   - Multiple event types (isolated execution)
   - Handler throws error (other handlers still run)

3. **Ordering:**
   - Handlers execute sequentially
   - Registration order preserved

4. **Error Scenarios:**
   - Handler throws synchronous error
   - Handler rejects Promise (async error)
   - Error logged correctly

**Example Test:**

```typescript
describe('InMemoryEventBus', () => {
  it('should execute handlers sequentially (not parallel)', async () => {
    const eventBus = new InMemoryEventBus();
    const executionOrder: number[] = [];

    eventBus.subscribe('TestEvent', async () => {
      await delay(10);
      executionOrder.push(1);
    });

    eventBus.subscribe('TestEvent', async () => {
      await delay(5);
      executionOrder.push(2);
    });

    await eventBus.publish({
      eventType: 'TestEvent',
      context: 'test',
      occurredAt: DateTime.now().toISO(),
      aggregateId: 'test-123'
    });

    expect(executionOrder).toEqual([1, 2]); // NOT [2, 1]
  });
});
```

---

### Future Extensibility: EventBridge Adapter

**Phase 2 Migration (10K-100K users):**

```typescript
// src/adapters/secondary/messaging/EventBridgeEventBus.ts
class EventBridgeEventBus implements IDomainEventBus {
  constructor(private client: EventBridgeClient) {}

  async publish<T extends DomainEvent>(event: T): Promise<void> {
    await this.client.putEvents({
      Entries: [{
        Source: `bday.${event.context}`,
        DetailType: event.eventType,
        Detail: JSON.stringify(event),
        EventBusName: 'bday-event-bus'
      }]
    });
  }

  subscribe() {
    throw new Error('Use Lambda event sources for subscriptions');
  }
}
```

**Zero Code Changes in Use Cases:**
```typescript
// src/application/use-cases/user/CreateUserUseCase.ts
constructor(
  private readonly userRepository: IUserRepository,
  private readonly eventBus: IDomainEventBus  // ✅ Same interface
) {}

// Works with InMemoryEventBus OR EventBridgeEventBus
await this.eventBus.publish(userCreatedEvent);
```

---

## Dependencies

- **Depends on:** None (foundation story)
- **Blocks:** Story 1.9 (UserCreated Event Handler), Story 1.10 (Refactored CreateUserUseCase)

---

## Effort Estimate

**4-6 hours**

- Task 1-2 (Interfaces): 1 hour
- Task 3-4 (Implementation): 2 hours
- Task 5 (Tests): 2 hours
- Task 6-7 (Verification): 1 hour

---

## Definition of Done

- [ ] IDomainEventBus interface defined with publish/subscribe methods
- [ ] DomainEvent base interface defined with required properties
- [ ] InMemoryEventBus implements IDomainEventBus with sequential execution
- [ ] Error handling logs failures but continues processing handlers
- [ ] Unit tests achieve 100% coverage
- [ ] All tests pass (`npm test`)
- [ ] ESLint passes with 0 errors (`npx eslint src/shared/events/`)
- [ ] TypeScript strict mode compilation succeeds (`npx tsc --noEmit`)
- [ ] Code reviewed and approved

---

## References

- **Architecture Decision:** [Bounded Contexts & Eventual Consistency](../architecture/bounded-contexts.md#communication-pattern-domain-events)
- **Scalability Analysis:** [Event Bus Migration Path](../architecture/scalability-analysis.md#when-to-extract-microservices)
- **Impact Assessment:** [Story 1.9 Prerequisites](../architecture/bounded-contexts-impact-assessment.md#change-2-new-story-19---domain-event-bus-infrastructure)
