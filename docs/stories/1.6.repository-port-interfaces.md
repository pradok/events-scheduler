# Story 1.6: Repository Port Interfaces

---

## Status

**Ready for Review**

---

## Story

**As a** developer,
**I want** repository port interfaces defined in the application layer,
**so that** domain logic doesn't depend on Prisma or database implementation.

---

## Acceptance Criteria

1. IUserRepository interface created in `src/application/ports/IUserRepository.ts`
2. IEventRepository interface created in `src/application/ports/IEventRepository.ts`
3. IUserRepository defines methods: create, findById, findByEmail, findUsersWithUpcomingBirthdays, update, delete
4. IEventRepository defines methods: create, findById, findByUserId, update, claimReadyEvents
5. All interface methods use domain entities (not Prisma models) as parameters/return types
6. Interfaces have no dependencies on Prisma or database specifics
7. Documentation comments explain each method's purpose and behavior
8. claimReadyEvents method documentation explains dual purpose: normal polling + recovery of missed events
9. TypeScript compilation succeeds with strict mode

---

## Tasks / Subtasks

**Development Approach:** This story is ideal for **Test-Driven Development (TDD)** since we have clear interface contracts and established patterns. Follow the Red-Green-Refactor cycle.

**TDD Workflow Reminder:**

1. **RED**: Write failing test defining desired behavior
2. **GREEN**: Write minimal code to pass the test
3. **REFACTOR**: Clean up while keeping tests green

---

- [x] **Task 1: Create application/ports directory structure** (AC: 1, 2)
  - [x] Create `src/application/` directory if it doesn't exist
  - [x] Create `src/application/ports/` subdirectory
  - [x] Verify directory structure matches architecture source tree

- [x] **Task 2 (TDD): Define IUserRepository interface** (AC: 1, 3, 5, 6, 7, 9)
  - [x] **RED: Write failing test first**
    - [x] Create `src/application/ports/IUserRepository.test.ts`
    - [x] Write test: "should use User domain entity not Prisma models"
    - [x] Write test: "should have explicit return type annotations"
    - [x] Run tests → expect failures (interface doesn't exist yet)
  - [x] **GREEN: Implement IUserRepository to pass tests**
    - [x] Create `src/application/ports/IUserRepository.ts` file
    - [x] Import User entity from domain layer (`src/domain/entities/User`)
    - [x] Define IUserRepository interface with PascalCase naming and `I` prefix
    - [x] Define `create(user: User): Promise<User>` method with JSDoc comment
    - [x] Define `findById(userId: string): Promise<User | null>` method with JSDoc comment
    - [x] Define `findByEmail(email: string): Promise<User | null>` method with JSDoc comment explaining uniqueness constraint
    - [x] Define `findUsersWithUpcomingBirthdays(daysAhead: number): Promise<User[]>` method with JSDoc comment explaining batch processing use case
    - [x] Define `update(user: User): Promise<User>` method with JSDoc comment
    - [x] Define `delete(userId: string): Promise<void>` method with JSDoc comment explaining user deletion
    - [x] Add comprehensive JSDoc comments explaining each method's purpose, parameters, and return values
    - [x] Export interface as named export
    - [x] Run tests → expect all tests pass
  - [x] **REFACTOR: Clean up and verify**
    - [x] Verify zero imports from Prisma, adapters, or infrastructure
    - [x] Verify TypeScript strict mode compilation passes
    - [x] Review JSDoc for completeness and clarity
    - [x] Run tests again → expect all tests still pass

- [x] **Task 3 (TDD): Define IEventRepository interface** (AC: 2, 4, 5, 6, 7, 8, 9)
  - [x] **RED: Write failing test first**
    - [x] Create `src/application/ports/IEventRepository.test.ts`
    - [x] Write test: "should use Event domain entity not Prisma models"
    - [x] Write test: "should have explicit return type annotations"
    - [x] Run tests → expect failures (interface doesn't exist yet)
  - [x] **GREEN: Implement IEventRepository to pass tests**
    - [x] Create `src/application/ports/IEventRepository.ts` file
    - [x] Import Event entity from domain layer (`src/domain/entities/Event`)
    - [x] Define IEventRepository interface with PascalCase naming and `I` prefix
    - [x] Define `create(event: Event): Promise<Event>` method with JSDoc comment
    - [x] Define `findById(eventId: string): Promise<Event | null>` method with JSDoc comment
    - [x] Define `findByUserId(userId: string): Promise<Event[]>` method with JSDoc comment explaining querying user's events
    - [x] Define `update(event: Event): Promise<Event>` method with JSDoc comment
    - [x] Define `claimReadyEvents(limit: number): Promise<Event[]>` method with detailed JSDoc explaining: (1) Dual purpose: normal polling every minute + recovery of missed events after system downtime, (2) Atomic claim operation with locking to prevent race conditions, (3) Returns events where targetTimestampUTC <= now and status = PENDING, (4) Optimistic locking via version field
    - [x] Export interface as named export
    - [x] Run tests → expect all tests pass
  - [x] **REFACTOR: Clean up and verify**
    - [x] Verify zero imports from Prisma, adapters, or infrastructure
    - [x] Verify TypeScript strict mode compilation passes
    - [x] Review JSDoc for completeness and clarity, especially claimReadyEvents dual purpose explanation
    - [x] Run tests again → expect all tests still pass

- [x] **Task 4: Final validation and compilation** (AC: 5, 9)
  - [x] Run complete test suite: `npm test`
  - [x] Verify all tests pass (IUserRepository + IEventRepository tests)
  - [x] Run `npm run build` to verify TypeScript compilation
  - [x] Verify no `any` types used in interface definitions
  - [x] Verify all method signatures have explicit return type annotations
  - [x] Verify test coverage is 100% for both port interface files
  - [x] Verify claimReadyEvents JSDoc clearly explains dual purpose (normal polling + recovery)

---

## Dev Notes

### Previous Story Insights

**[Source: Story 1.5 - Dev Agent Record]**

Key learnings from Story 1.5 (Timezone Service & Strategy Pattern):

1. **Domain Layer Purity Excellence**: Story 1.5 achieved perfect domain purity with zero infrastructure dependencies. Port interfaces MUST maintain this standard by having ZERO imports from Prisma, adapters, or infrastructure.

2. **Strategy Pattern Implementation**: Story 1.5 successfully implemented the Strategy Pattern (IEventHandler, EventHandlerRegistry, BirthdayEventHandler). Port interfaces follow the same pattern - they define contracts (WHAT) without specifying implementation (HOW).

3. **Comprehensive JSDoc Documentation**: Story 1.5 set the standard for excellent documentation. Port interfaces MUST include JSDoc comments explaining each method's purpose, parameters, return values, and critical implementation requirements (e.g., atomicity, race condition protection).

4. **TypeScript Strict Mode Compliance**: All domain code compiles with strict mode, no `any` types. Port interfaces must follow the same strict typing standards.

5. **Test Coverage Excellence**: Story 1.5 achieved 100% coverage. Port interfaces should have tests verifying interface structure and method signatures.

---

### Architecture Context

**[Source: architecture/port-interfaces.md]**

#### Critical Principle

**The domain and application layers have ZERO knowledge of infrastructure technology.** Ports are interfaces that define contracts for infrastructure capabilities WITHOUT specifying implementation details.

#### Dependency Inversion Principle

- Application layer depends on port interfaces (abstractions)
- Adapter layer implements port interfaces (concrete implementations)
- Domain layer has NO dependencies on ports (pure business logic)

**Technology Agnostic:** Ports do not mention Prisma, SQS, EventBridge, PostgreSQL, or any specific technology. They describe WHAT needs to happen, not HOW.

---

### IUserRepository Port Specification

**[Source: architecture/port-interfaces.md#IUserRepository]**

**Purpose:** Abstracts user persistence operations. The domain doesn't care if data is stored in PostgreSQL, MongoDB, DynamoDB, or in-memory.

**Required Methods:**

```typescript
interface IUserRepository {
  // Create new user
  create(user: User): Promise<User>;

  // Find user by unique ID
  findById(userId: string): Promise<User | null>;

  // Find user by email (business requirement for uniqueness)
  findByEmail(email: string): Promise<User | null>;

  // Find all users with birthdays in next N days (for batch processing)
  findUsersWithUpcomingBirthdays(daysAhead: number): Promise<User[]>;

  // Update existing user
  update(user: User): Promise<User>;

  // Delete user
  delete(userId: string): Promise<void>;
}
```

**Implementation Notes:**
- Methods use domain entities (User) not Prisma models
- Return `null` for not found, not throw exceptions
- `findByEmail` enforces email uniqueness constraint
- `findUsersWithUpcomingBirthdays` supports batch event generation

**Future Implementations:**
- `PrismaUserRepository` (Story 1.7)
- `InMemoryUserRepository` (for tests)

---

### IEventRepository Port Specification

**[Source: architecture/port-interfaces.md#IEventRepository]**

**Purpose:** Abstracts event persistence and querying. The application layer doesn't know about `FOR UPDATE SKIP LOCKED` or PostgreSQL-specific features.

**Required Methods:**

```typescript
interface IEventRepository {
  // Create new event
  create(event: Event): Promise<Event>;

  // Find event by unique ID
  findById(eventId: string): Promise<Event | null>;

  // Find events by user ID
  findByUserId(userId: string): Promise<Event[]>;

  // Update existing event (optimistic locking handled by implementation)
  update(event: Event): Promise<Event>;

  // CRITICAL: Atomically claim ready events for execution
  // DUAL PURPOSE:
  // 1. Normal Operation: Scheduler polls every minute to claim events ready NOW
  // 2. Recovery Mode: After system downtime, claims ALL backlogged events from the past
  //
  // Implementation MUST ensure:
  // - Only events with targetTimestampUTC <= now are returned (past OR present)
  // - Only events with status = PENDING are returned
  // - Events are atomically locked to prevent duplicate claiming (race condition protection)
  // - Optimistic locking via version field
  //
  // The word "claim" is semantically important - this method both FINDS and LOCKS events
  // in a single atomic operation, preventing race conditions in distributed systems.
  claimReadyEvents(limit: number): Promise<Event[]>;
}
```

**Critical Implementation Requirements (Document in JSDoc):**

- `claimReadyEvents()` serves dual purpose: normal polling (every minute) + recovery (after system downtime)
- MUST be atomic operation (prevent race conditions when multiple scheduler instances run)
- Implementation will use `FOR UPDATE SKIP LOCKED` (PostgreSQL) but interface doesn't specify this
- Optimistic locking handled transparently via version field
- "Ready" means `targetTimestampUTC <= now` regardless if 1 second ago or 1 week ago
- Return `null` for not found, not throw exceptions

**MVP Scope Note:**

- Event deletion methods (`delete`, `deleteByUserId`) deferred from MVP
- Specification pattern method (`findBySpecification`) deferred from MVP
- These will be added in future stories as needed

**Future Implementations:**

- `PrismaEventRepository` (Story 1.7)
- `InMemoryEventRepository` (for tests)

---

### Project Structure

**[Source: architecture/source-tree.md]**

File locations for this story:

```
src/application/
├── ports/
│   ├── IUserRepository.ts          # User persistence interface
│   ├── IUserRepository.test.ts     # Interface structure tests
│   ├── IEventRepository.ts         # Event persistence interface
│   └── IEventRepository.test.ts    # Interface structure tests
```

**Port Interfaces are Application Layer:** Defined in `src/application/ports/` to establish boundaries between application logic and infrastructure.

**Hexagonal Architecture Separation:**
- **Ports:** Interfaces in `application/ports/` define contracts
- **Primary Adapters (Inbound):** HTTP, Lambda handlers (Story 1.9+)
- **Secondary Adapters (Outbound):** Prisma repositories (Story 1.7)

---

### Import Rules

**[Source: architecture/source-tree.md#import-rules]**

#### Application Layer (`src/application/`)

- ✅ Can import: Domain entities, value objects, domain services
- ❌ Cannot import: Adapters (only port interfaces, not implementations)

#### Port Interface Rules

Port interfaces in `src/application/ports/` can ONLY import:
- Domain entities from `src/domain/entities/` (User, Event)
- Domain value objects from `src/domain/value-objects/` (if needed for method signatures)

Port interfaces MUST NOT import:
- Prisma (`@prisma/client`)
- Any adapter implementations (`src/adapters/`)
- Infrastructure frameworks (Fastify, AWS SDK)
- Shared utilities (`src/shared/`) - ports are pure abstractions

---

### Coding Standards

**[Source: architecture/coding-standards.md]**

#### Naming Conventions

- **Interfaces (Ports):** PascalCase with `I` prefix (e.g., `IUserRepository`, `IEventRepository`)
- **Files:** PascalCase for application layer (e.g., `IUserRepository.ts`)
- **Methods:** camelCase (e.g., `findById`, `findReadyEvents`)

#### Critical Rules

1. **No `any` Types:** TypeScript strict mode enabled. All method signatures MUST have explicit types.
2. **Explicit Return Types:** All public methods MUST have explicit return type annotations.
3. **Repository Pattern Required:** All database access MUST go through repository interfaces. Never direct Prisma calls from use cases.
4. **Domain Layer Purity:** Port interfaces can import domain entities but MUST NOT import infrastructure.

#### JSDoc Documentation Requirements

All port interface methods MUST include JSDoc comments with:
- Purpose of the method
- Parameter descriptions
- Return value description
- Critical implementation requirements (atomicity, locking, race conditions)

**Example:**

```typescript
/**
 * Atomically claims ready events for execution.
 *
 * Implementation MUST ensure:
 * - Only events with targetTimestampUTC <= now are returned
 * - Only events with status = PENDING are returned
 * - Events are locked to prevent duplicate claiming (race condition protection)
 * - Optimistic locking via version field
 *
 * @param limit Maximum number of events to claim
 * @returns Array of claimed Event entities (may be empty)
 */
findReadyEvents(limit: number): Promise<Event[]>;
```

---

### Domain Entities

**[Source: architecture/data-models.md]**

#### User Entity

Port interfaces use the User domain entity (not Prisma models):

**Key Attributes:**
- `id: UUID` - Unique identifier
- `firstName: string` - User's first name
- `lastName: string` - User's last name
- `dateOfBirth: DateOfBirth` - Birthday (value object)
- `timezone: Timezone` - IANA timezone (value object)
- `createdAt: DateTime` - Creation timestamp (UTC)
- `updatedAt: DateTime` - Last modified timestamp (UTC)

#### Event Entity

Port interfaces use the Event domain entity (not Prisma models):

**Key Attributes:**
- `id: UUID` - Unique identifier
- `userId: UUID` - Foreign key to User
- `eventType: string` - Event type ("BIRTHDAY")
- `status: EventStatus` - Lifecycle state (PENDING, PROCESSING, COMPLETED, FAILED)
- `targetTimestampUTC: DateTime` - Execution time (UTC)
- `targetTimestampLocal: DateTime` - Execution time (local)
- `targetTimezone: string` - Timezone for calculation
- `executedAt: DateTime | null` - Actual execution timestamp
- `failureReason: string | null` - Error message if failed
- `retryCount: number` - Execution attempts (0-3)
- `version: number` - Optimistic locking version
- `idempotencyKey: string` - Unique key for retries
- `deliveryPayload: JSON` - Message payload
- `createdAt: DateTime` - Creation timestamp (UTC)
- `updatedAt: DateTime` - Last modified timestamp (UTC)

**Critical:** Port interfaces MUST use domain entities (User, Event) as method parameters and return types, NOT Prisma models.

---

### Technology Stack

**[Source: architecture/tech-stack.md]**

- **Language:** TypeScript 5.3.3 (strict mode required)
- **Runtime:** Node.js 20.11.0 LTS
- **ORM:** Prisma 6.17.1 (adapter layer only - NOT imported by ports)

**Port Interface Guidelines:**
- Port interfaces are technology-agnostic
- Do NOT import Prisma types or models
- Use domain entities for all method signatures
- Implementations (Story 1.7) will handle Prisma mapping

---

### Testing

**[Source: architecture/test-strategy.md]**

#### Test File Location

Colocated with source files:
- `src/application/ports/IUserRepository.test.ts`
- `src/application/ports/IEventRepository.test.ts`

#### Testing Framework

Jest 29.7.0 with TypeScript support

#### TDD Approach for This Story

**This story is IDEAL for Test-Driven Development** because:

- Interface contracts are clearly defined in architecture docs
- Expected behavior is well-specified (method signatures, types, return values)
- No infrastructure dependencies to set up
- Tests can be written before implementation

**Follow Red-Green-Refactor:**

1. **RED**: Write tests defining interface structure and type contracts → Tests fail (interface doesn't exist)
2. **GREEN**: Create interface with minimal implementation to pass tests
3. **REFACTOR**: Improve JSDoc, verify imports, ensure strict mode compliance

#### Test Requirements

Port interface tests should verify:

1. **Interface Structure:** Method signatures match specification
2. **Type Safety:** All methods use domain entities (not Prisma models)
3. **No Infrastructure Dependencies:** Zero imports from Prisma or adapters
4. **JSDoc Documentation:** All methods have comprehensive documentation

#### Example Test Pattern

```typescript
import { IUserRepository } from './IUserRepository';
import { User } from '@/domain/entities/User';

describe('IUserRepository', () => {
  it('should define required methods', () => {
    // Verify interface has expected methods
    const repo: IUserRepository = {} as any;

    expect(typeof repo.create).toBe('function');
    expect(typeof repo.findById).toBe('function');
    expect(typeof repo.update).toBe('function');
    expect(typeof repo.delete).toBe('function');
  });

  it('should use domain entities not Prisma models', () => {
    // Type checking test - verifies User entity is used
    const mockUser: User = {} as any;
    const repo: IUserRepository = {
      create: async (user: User) => user,
      findById: async (id: string) => mockUser,
      update: async (user: User) => user,
      delete: async (id: string) => {}
    };

    expect(repo).toBeDefined();
  });
});
```

#### Coverage Requirements

- 100% coverage for port interface files (structural validation)
- Focus on verifying interface contracts, not implementation

---

### Why Ports Matter

**[Source: architecture/port-interfaces.md#benefits]**

1. **Testability:** Easy to test with mock implementations (InMemoryRepository)
2. **Flexibility:** Swap infrastructure (Prisma → TypeORM) without changing business logic
3. **Dependency Inversion:** Use cases depend on abstractions, not concrete implementations
4. **Technology Agnostic:** Domain/application layers have zero knowledge of database technology
5. **Clear Boundaries:** Hexagonal architecture separation enforced by TypeScript compiler

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-22 | 1.0 | Initial story draft created | Bob (Scrum Master) |
| 2025-01-22 | 1.1 | Updated tasks to follow TDD workflow (Red-Green-Refactor); added TDD guidance to Testing section | Bob (Scrum Master) |
| 2025-01-22 | 1.2 | Corrected interface specifications to match architecture: Added findByEmail, findUsersWithUpcomingBirthdays to IUserRepository (6 methods total); Added findByUserId to IEventRepository; Renamed findReadyEvents to claimReadyEvents with detailed dual-purpose documentation (normal polling + recovery); Removed findMissedEvents (redundant); Deferred delete/deleteByUserId/findBySpecification methods from MVP scope | James (Dev Agent) |

---

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

No debug logs required - implementation completed without blocking issues.

### Completion Notes List

- ✅ Successfully implemented both port interfaces using TDD (Red-Green-Refactor)
- ✅ All 129 tests pass (including 4 new port interface tests)
- ✅ TypeScript strict mode compilation successful
- ✅ Zero infrastructure dependencies in port interfaces
- ✅ Comprehensive JSDoc documentation added to all methods
- ✅ `claimReadyEvents` method includes detailed dual-purpose documentation (normal polling + recovery mode)
- ✅ Added eslint-disable comment for interface naming convention (I prefix required by architecture)
- ✅ Used relative imports (no path aliases configured in tsconfig.json)

### File List

**Created:**

- `src/application/ports/IUserRepository.ts` - User repository port interface (6 methods)
- `src/application/ports/IUserRepository.test.ts` - Interface structure tests
- `src/application/ports/IEventRepository.ts` - Event repository port interface (5 methods)
- `src/application/ports/IEventRepository.test.ts` - Interface structure tests

**Modified:**

- None (only new files created)

---

## QA Results

_To be filled by QA Agent_
