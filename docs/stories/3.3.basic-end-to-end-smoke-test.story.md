# Story 3.3: Basic End-to-End Smoke Test

---

## Status

Approved

---

## Story

**As a** developer,
**I want** one end-to-end test proving the complete system works,
**so that** I can confidently demo the MVP and know all components integrate correctly.

---

## Acceptance Criteria

1. E2E test creates user via API → verifies birthday event generated automatically
2. Test advances time to event execution time → scheduler claims event → sends to SQS
3. Test processes SQS message via worker → webhook delivered to test endpoint
4. Test verifies event status updated to COMPLETED in database
5. Test uses real database (Testcontainers PostgreSQL)
6. Test uses real LocalStack (SQS for worker, EventBridge for scheduler)
7. Test uses real mock webhook server to verify delivery
8. Test passes consistently without flaky behavior

---

## Tasks / Subtasks

- [ ] **Task 1: Create E2E Test File** (AC: 1)
  - [ ] Create `tests/e2e/complete-birthday-flow.e2e.test.ts`
  - [ ] Set up test timeout: `jest.setTimeout(120000)` (2 minutes for full flow)
  - [ ] Import all required dependencies (Prisma, SQS client, Lambda invoke, Axios)
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#E2E-Tests]

- [ ] **Task 2: Set Up Test Infrastructure** (AC: 5, 6, 7)
  - [ ] Start Testcontainers PostgreSQL in `beforeAll`
  - [ ] Verify LocalStack running (SQS, Lambda, EventBridge)
  - [ ] Start mock webhook server on random port (use express or http server)
  - [ ] Store webhook server URL in test variable
  - [ ] Clean up all infrastructure in `afterAll`
  - [ ] Reference: [Source: docs/stories/2.10.end-to-end-scheduling-flow-test.story.md]

- [ ] **Task 3: Implement Happy Path E2E Test** (AC: 1, 2, 3, 4)
  - [ ] **Step 1: Create User**
    ```typescript
    // Create user with birthday tomorrow at current time
    const tomorrow = DateTime.now().plus({ days: 1 });
    const user = await prisma.user.create({
      data: {
        firstName: 'John',
        lastName: 'Doe',
        email: 'john@example.com',
        dateOfBirth: tomorrow.toISODate(),
        timezone: 'America/New_York'
      }
    });
    ```
  - [ ] **Step 2: Verify Event Generated**
    ```typescript
    const event = await prisma.event.findFirst({
      where: { userId: user.id, status: 'PENDING' }
    });
    expect(event).toBeDefined();
    expect(event.eventType).toBe('BIRTHDAY');
    ```
  - [ ] **Step 3: Advance Time & Trigger Scheduler**
    ```typescript
    // Update event to be ready (past target time)
    await prisma.event.update({
      where: { id: event.id },
      data: { targetTimestampUTC: DateTime.now().minus({ minutes: 5 }).toJSDate() }
    });

    // Invoke scheduler Lambda
    await lambdaClient.send(new InvokeCommand({
      FunctionName: 'event-scheduler',
      Payload: '{}'
    }));
    ```
  - [ ] **Step 4: Verify Event Sent to SQS**
    ```typescript
    const messages = await sqsClient.send(new ReceiveMessageCommand({
      QueueUrl: process.env.SQS_QUEUE_URL,
      MaxNumberOfMessages: 10,
      WaitTimeSeconds: 5
    }));
    expect(messages.Messages).toHaveLength(1);
    const payload = JSON.parse(messages.Messages[0].Body);
    expect(payload.eventId).toBe(event.id);
    ```
  - [ ] **Step 5: Invoke Worker Lambda**
    ```typescript
    // Invoke worker with SQS message
    await lambdaClient.send(new InvokeCommand({
      FunctionName: 'event-worker',
      Payload: JSON.stringify({
        Records: [{
          body: messages.Messages[0].Body
        }]
      })
    }));
    ```
  - [ ] **Step 6: Verify Webhook Delivered**
    ```typescript
    // Check mock webhook server received request
    expect(mockWebhookServer.receivedRequests).toHaveLength(1);
    const webhookRequest = mockWebhookServer.receivedRequests[0];
    expect(webhookRequest.body.message).toContain('John Doe');
    expect(webhookRequest.body.message).toContain('birthday');
    ```
  - [ ] **Step 7: Verify Event Status Updated**
    ```typescript
    const completedEvent = await prisma.event.findUnique({
      where: { id: event.id }
    });
    expect(completedEvent.status).toBe('COMPLETED');
    expect(completedEvent.executedAt).toBeDefined();
    ```

- [ ] **Task 4: Create Mock Webhook Server** (AC: 7)
  - [ ] Create `tests/helpers/mock-webhook-server.ts`
  - [ ] Export class `MockWebhookServer`:
    ```typescript
    class MockWebhookServer {
      private server: http.Server;
      public receivedRequests: Array<{ body: any; headers: any }> = [];
      public port: number;

      async start(): Promise<string> {
        // Start HTTP server on random port
        // Store incoming requests in receivedRequests array
        // Return webhook URL: `http://localhost:${port}/webhook`
      }

      async stop(): Promise<void> {
        // Close server
      }

      reset(): void {
        // Clear receivedRequests array
      }
    }
    ```
  - [ ] Server should respond with 200 OK to all requests
  - [ ] Server should parse JSON body and store in receivedRequests

- [ ] **Task 5: Handle Test Flakiness** (AC: 8)
  - [ ] Add retry logic for SQS message polling (poll up to 10 times with 1s delay)
  - [ ] Add wait/retry for webhook delivery (webhook server may receive request async)
  - [ ] Use `waitFor` utility for async assertions:
    ```typescript
    async function waitFor(
      condition: () => Promise<boolean>,
      timeoutMs: number = 30000
    ): Promise<void> {
      const startTime = Date.now();
      while (Date.now() - startTime < timeoutMs) {
        if (await condition()) return;
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      throw new Error('Timeout waiting for condition');
    }
    ```
  - [ ] Use waitFor for: SQS message arrival, webhook delivery, event status update

- [ ] **Task 6: Add Test Cleanup** (AC: 5, 6, 7)
  - [ ] In `afterEach`: Purge SQS queue
  - [ ] In `afterEach`: Delete test user and events from database
  - [ ] In `afterEach`: Reset mock webhook server
  - [ ] In `afterAll`: Stop mock webhook server
  - [ ] In `afterAll`: Stop Testcontainers PostgreSQL
  - [ ] Ensure cleanup happens even if test fails (use try-finally if needed)

- [ ] **Task 7: Add Test Documentation** (AC: 8)
  - [ ] Add JSDoc comment at top of test file explaining:
    - What the test does (complete happy path)
    - How long it takes (~30-60 seconds)
    - Infrastructure requirements (LocalStack, Testcontainers)
    - How to run: `npm run test:e2e`
  - [ ] Add inline comments for each major step (user creation, scheduler, worker, verification)

- [ ] **Task 8: Verify Test Passes Consistently** (AC: 8)
  - [ ] Run test 10 times locally: `for i in {1..10}; do npm run test:e2e; done`
  - [ ] Verify all 10 runs pass
  - [ ] If any flakiness, add retries or waits
  - [ ] Document known issues in test comments if any

---

## Dev Notes

### Important Context from Previous Stories

**Story 2.10 - End-to-End Scheduling Flow:**
- Already has E2E test infrastructure set up
- Uses LambdaClient.send(InvokeCommand) to trigger scheduler and worker
- Uses Testcontainers for PostgreSQL
- **THIS STORY EXTENDS:** Add webhook delivery verification

**Story 2.9b - Configurable Event Delivery Times:**
- Events created with 9 AM delivery time by default
- Can override delivery time in test by updating targetTimestampUTC

**Story 2.6 - Worker Lambda:**
- Worker processes SQS messages
- Calls ExecuteEventUseCase
- Delivers webhook via WebhookAdapter

### Why This Test is Critical

**What it proves:**
1. ✅ User API creates events automatically (domain event handler works)
2. ✅ Scheduler finds and claims ready events (polling works)
3. ✅ Scheduler sends events to SQS (message queue integration works)
4. ✅ Worker receives and processes SQS messages (Lambda integration works)
5. ✅ Webhook gets delivered to external endpoint (HTTP adapter works)
6. ✅ Event status updates to COMPLETED (state machine works)

**What it catches:**
- Configuration errors (wrong queue URL, missing env vars)
- Integration bugs (scheduler → SQS → worker flow)
- Timing issues (event not claimed when expected)
- Webhook delivery failures
- Database transaction issues

### Test Flow Diagram

```
┌─────────────────────────────────────────────────────────────┐
│ E2E Test: Complete Birthday Event Flow                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. Create User (API)                                       │
│     └─> Birthday Event Generated (PENDING)                 │
│                                                             │
│  2. Update Event Target Time (make ready)                   │
│                                                             │
│  3. Invoke Scheduler Lambda                                 │
│     └─> Event Claimed (PENDING → PROCESSING)               │
│     └─> Event Sent to SQS                                   │
│                                                             │
│  4. Receive Message from SQS                                │
│     └─> Verify: eventId, eventType, idempotencyKey         │
│                                                             │
│  5. Invoke Worker Lambda                                    │
│     └─> Webhook Delivered to Mock Server                    │
│                                                             │
│  6. Verify Webhook Request                                  │
│     └─> Body contains: "John Doe", "birthday"              │
│     └─> Headers contain: X-Idempotency-Key                 │
│                                                             │
│  7. Verify Event Status in Database                         │
│     └─> Status: COMPLETED                                   │
│     └─> executedAt: defined                                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Mock Webhook Server Pattern

**Why mock server instead of webhook.site?**
- ✅ **No external dependencies** - test runs offline
- ✅ **Fast** - no network latency
- ✅ **Deterministic** - no rate limits or availability issues
- ✅ **Inspectable** - can assert on exact request details

**Implementation:**
```typescript
class MockWebhookServer {
  private server: http.Server;
  public receivedRequests: Array<{ body: any; headers: any }> = [];
  public port: number;

  async start(): Promise<string> {
    return new Promise((resolve) => {
      this.server = http.createServer((req, res) => {
        let body = '';
        req.on('data', chunk => body += chunk);
        req.on('end', () => {
          this.receivedRequests.push({
            body: JSON.parse(body),
            headers: req.headers
          });
          res.writeHead(200);
          res.end('OK');
        });
      });

      this.server.listen(0, () => {
        this.port = (this.server.address() as any).port;
        resolve(`http://localhost:${this.port}/webhook`);
      });
    });
  }
}
```

### Handling Async Timing

**Problem:** Worker Lambda processes message asynchronously
**Solution:** Poll/wait for expected state

```typescript
// Wait for webhook delivery
await waitFor(async () => {
  return mockWebhookServer.receivedRequests.length > 0;
}, 30000);

// Wait for event status update
await waitFor(async () => {
  const event = await prisma.event.findUnique({ where: { id: eventId } });
  return event?.status === 'COMPLETED';
}, 30000);
```

### Environment Configuration

**Required Environment Variables:**
```bash
AWS_ENDPOINT_URL=http://localhost:4566
SQS_QUEUE_URL=http://localhost:4566/000000000000/events-queue
DATABASE_URL=postgresql://test:test@localhost:5432/bday_test
NODE_ENV=test
```

**Set in test file:**
```typescript
beforeAll(() => {
  process.env.WEBHOOK_URL = webhookServerUrl; // Set dynamically
});
```

### File Locations

**Files to Create:**
- `tests/e2e/complete-birthday-flow.e2e.test.ts` (NEW)
- `tests/helpers/mock-webhook-server.ts` (NEW)
- `tests/helpers/wait-for.ts` (NEW - utility function)

### Technology Stack

**Test Infrastructure:**
- **Jest 29.7.0** - Test runner
- **Testcontainers PostgreSQL** - Real database
- **LocalStack** - SQS, Lambda, EventBridge
- **AWS SDK** - Lambda invoke, SQS receive
- **Node.js http** - Mock webhook server

**No new dependencies needed!**

---

## Testing

### Test File Location

**E2E Test:**
- `tests/e2e/complete-birthday-flow.e2e.test.ts`

### Running the Test

```bash
# Run all E2E tests
npm run test:e2e

# Run this specific test
npm run test:e2e -- complete-birthday-flow

# Run with verbose output
npm run test:e2e -- --verbose
```

### Expected Output

```
 PASS  tests/e2e/complete-birthday-flow.e2e.test.ts (45.2s)
  Complete Birthday Event Flow
    ✓ should create user, schedule event, deliver webhook, and mark complete (42310ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Time:        45.2s
```

### Debugging Failed Tests

**If test fails, check:**
1. LocalStack running: `docker ps | grep localstack`
2. Lambdas deployed: `npm run lambda:all`
3. SQS queue exists: `aws --endpoint-url=http://localhost:4566 sqs list-queues`
4. Database accessible: `psql $DATABASE_URL`
5. Check test logs for specific failure point

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-26 | 1.0 | Initial draft created for MVP smoke test | Bob (Scrum Master) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used

*TBD by dev agent*

### Debug Log References

*TBD by dev agent*

### Completion Notes

*TBD by dev agent*

### File List

*TBD by dev agent*

---

## QA Results

*This section will be populated by QA agent after implementation*
