# Story 2.2: SQS Queue Integration

---

## Status

Approved

---

## Story

**As a** developer,
**I want** an SQS adapter that sends claimed events to a queue,
**so that** scheduling is decoupled from execution for better scalability.

---

## Acceptance Criteria

1. Zod schema defined for SQS message payload (eventId, eventType, idempotencyKey, metadata)
2. TypeScript types derived from schema using `z.infer<typeof SQSMessageSchema>`
3. ISQSClient port interface created using derived types in `src/application/ports/ISQSClient.ts`
4. SQSAdapter implementation created in `src/adapters/secondary/messaging/SQSAdapter.ts`
5. Adapter configured to use LocalStack SQS for local development
6. Adapter validates outgoing messages against schema before sending
7. Adapter sends event details as JSON message to queue with message attributes
8. Adapter handles SQS errors gracefully with logging
9. LocalStack SQS queue created automatically on startup
10. Integration tests verify messages are sent to queue successfully with correct schema

---

## Tasks / Subtasks

- [ ] **Task 1: Define SQS Message Payload Schema with Zod** (AC: 1, 2)
  - [ ] Create `src/shared/validation/schemas.ts` if not exists (already exists from Story 1.8)
  - [ ] Define `SQSMessagePayloadSchema` in schemas.ts with required fields:
    - `eventId: z.string().uuid()` (UUID of the event)
    - `eventType: z.string()` (e.g., "BIRTHDAY")
    - `idempotencyKey: z.string()` (for duplicate detection)
    - `metadata: z.object()` (additional context like userId, timestamp)
  - [ ] Derive TypeScript type using `z.infer<typeof SQSMessagePayloadSchema>`
  - [ ] Export both schema and type from schemas.ts
  - [ ] Add JSDoc comments explaining each field's purpose
  - [ ] Reference: [Source: architecture/coding-standards.md#Zod-Schemas-as-Single-Source-of-Truth]

- [ ] **Task 2: Create ISQSClient Port Interface** (AC: 3)
  - [ ] Create `src/modules/event-scheduling/application/ports/ISQSClient.ts`
  - [ ] Define interface with method: `sendMessage(payload: SQSMessagePayload): Promise<string>`
    - Return type: string (SQS MessageId for tracking)
    - Throws: InfrastructureError for SQS failures
  - [ ] Import derived type from SQSMessagePayloadSchema (NOT manual type definition)
  - [ ] Add JSDoc explaining port purpose and contract
  - [ ] Follow hexagonal architecture pattern (no AWS SDK imports in port)
  - [ ] Reference: [Source: architecture/port-interfaces.md#IMessageSender]

- [ ] **Task 3: Implement SQSAdapter** (AC: 4, 5, 6, 7, 8)
  - [ ] Create `src/adapters/secondary/messaging/SQSAdapter.ts`
  - [ ] Implement `ISQSClient` interface
  - [ ] Inject dependencies via constructor:
    - AWS SQS client (`SQSClient` from `@aws-sdk/client-sqs`)
    - Queue URL (string, from environment variable `SQS_QUEUE_URL`)
    - Logger (`ILogger` port interface)
  - [ ] Implement `sendMessage()` method:
    - Validate payload against `SQSMessagePayloadSchema` (throw ValidationError if invalid)
    - Convert payload to JSON string using `JSON.stringify()`
    - Call SQS `SendMessageCommand` with MessageBody
    - Add message attributes: `eventType`, `idempotencyKey` (for SQS filtering)
    - Catch SQS errors, log with structured context, rethrow as InfrastructureError
    - Return SQS MessageId on success
  - [ ] Configure SQS client for LocalStack:
    - Use `endpoint: process.env.AWS_ENDPOINT_URL || 'http://localhost:4566'` for local dev
    - Use `region: 'us-east-1'` (LocalStack default)
    - Use `credentials: { accessKeyId: 'test', secretAccessKey: 'test' }` for LocalStack
  - [ ] Add structured logging:
    - Log message sent (INFO level) with eventId, messageId
    - Log errors (ERROR level) with error details, eventId
  - [ ] Reference: [Source: architecture/tech-stack.md#AWS-Services]

- [ ] **Task 4: Create LocalStack SQS Queue** (AC: 9)
  - [ ] Verify `docker/localstack/init-aws.sh` exists (created in earlier stories)
  - [ ] Add SQS queue creation command to init-aws.sh:
    ```bash
    awslocal sqs create-queue --queue-name event-queue
    ```
  - [ ] Export queue URL as environment variable in script
  - [ ] Update `.env.example` with `SQS_QUEUE_URL=http://localhost:4566/000000000000/event-queue`
  - [ ] Verify queue creation in LocalStack after Docker Compose startup
  - [ ] Reference: [Source: architecture/tech-stack.md#LocalStack]

- [ ] **Task 5: Write Unit Tests for SQSAdapter** (AC: 6, 8)
  - [ ] Create `src/adapters/secondary/messaging/SQSAdapter.test.ts`
  - [ ] Mock SQS client using Jest mocks
  - [ ] Test: should validate payload against schema before sending
    - Arrange: invalid payload (missing eventId)
    - Act: call sendMessage()
    - Assert: throws ValidationError
  - [ ] Test: should send valid message to SQS queue
    - Arrange: valid SQSMessagePayload
    - Act: call sendMessage()
    - Assert: SQS SendMessageCommand called with correct MessageBody
    - Assert: returns SQS MessageId
  - [ ] Test: should include message attributes (eventType, idempotencyKey)
    - Assert: SendMessageCommand includes MessageAttributes
  - [ ] Test: should handle SQS errors gracefully
    - Arrange: mock SQS client to throw error
    - Act: call sendMessage()
    - Assert: throws InfrastructureError
    - Assert: logger.error called with error context
  - [ ] Test: should log message sent successfully
    - Assert: logger.info called with eventId, messageId
  - [ ] Achieve 100% code coverage for SQSAdapter
  - [ ] Follow AAA pattern (Arrange, Act, Assert)
  - [ ] Reference: [Source: architecture/test-strategy.md#Unit-Tests]

- [ ] **Task 6: Write Integration Tests** (AC: 10)
  - [ ] Create `src/adapters/secondary/messaging/SQSAdapter.integration.test.ts`
  - [ ] Use LocalStack SQS (not mocked SQS client)
  - [ ] Setup: Create test queue in LocalStack before tests
  - [ ] Teardown: Purge queue and delete after tests
  - [ ] Test: should send message to LocalStack SQS queue
    - Arrange: Create SQSAdapter with LocalStack endpoint
    - Arrange: Create valid SQSMessagePayload
    - Act: Call sendMessage()
    - Assert: Message appears in SQS queue (use ReceiveMessage to verify)
    - Assert: Message body matches sent payload (JSON parse and compare)
  - [ ] Test: should include message attributes in sent message
    - Assert: ReceiveMessage returns MessageAttributes (eventType, idempotencyKey)
  - [ ] Test: should validate schema and reject invalid payloads
    - Arrange: Invalid payload (wrong type for eventId)
    - Act: call sendMessage()
    - Assert: throws ValidationError
    - Assert: no message in queue
  - [ ] Clean up: Purge queue between tests to avoid pollution
  - [ ] Reference: [Source: architecture/test-strategy.md#Integration-Tests]

- [ ] **Task 7: Error Handling and Logging** (AC: 8)
  - [ ] Wrap SQS SendMessageCommand in try-catch
  - [ ] Catch SQS-specific errors (`SQSServiceException`)
  - [ ] Log error with structured context:
    - `error.message` (AWS error message)
    - `error.name` (AWS error type)
    - `eventId` (from payload)
    - `queueUrl` (for debugging)
  - [ ] Rethrow as `InfrastructureError` (application-level error)
  - [ ] Use Pino logger exclusively (no console.log)
  - [ ] Reference: [Source: architecture/error-handling.md#Infrastructure-Errors]

---

## Dev Notes

### Previous Story Insights

**From Story 2.1 (ClaimReadyEventsUseCase):**
- Pino logger available at `src/shared/logger.ts`
- Use `logger.info()` and `logger.error()` for structured logging
- No `console.log` or `console.error` (ESLint will fail)
- TDD workflow with 100% code coverage achieved
- Clean hexagonal architecture with port interfaces (IEventRepository)
- Integration tests verify end-to-end behavior with real infrastructure

**From Story 1.11c (Structured Logging):**
- All logs must include structured context fields (eventId, messageId, error, etc.)
- Use `logger.error()` for failures with error object
- Use `logger.info()` for success with metrics (duration, eventId)

### Architecture Context

**Bounded Context:**
- This adapter belongs to **Event Scheduling Context**
- Located in `src/adapters/secondary/messaging/` (NOT in modules folder)
- Messaging adapters are infrastructure-level (cross-cutting concern)
- Port interface located in `src/modules/event-scheduling/application/ports/ISQSClient.ts`
- Uses only `ISQSClient` port interface (no direct SQS imports in use cases)

**File Locations:**

```
src/
├── modules/
│   └── event-scheduling/
│       └── application/
│           └── ports/
│               └── ISQSClient.ts                    # NEW - Port interface (Task 2)
├── adapters/
│   └── secondary/
│       └── messaging/
│           ├── SQSAdapter.ts                        # NEW - Implementation (Task 3)
│           ├── SQSAdapter.test.ts                   # NEW - Unit tests (Task 5)
│           └── SQSAdapter.integration.test.ts       # NEW - Integration tests (Task 6)
└── shared/
    └── validation/
        └── schemas.ts                                # EXISTING - Add SQS schema (Task 1)
```

[Source: architecture/source-tree.md#Project-Structure, architecture/port-interfaces.md#Implementation-Guidelines]

### Data Model - SQS Message Payload

**Message Schema (Zod):**

```typescript
export const SQSMessagePayloadSchema = z.object({
  eventId: z.string().uuid(),           // Event UUID from database
  eventType: z.string(),                // "BIRTHDAY" for Phase 1
  idempotencyKey: z.string(),           // For duplicate detection (from Event entity)
  metadata: z.object({
    userId: z.string().uuid(),          // User UUID
    targetTimestampUTC: z.string(),     // ISO 8601 timestamp
    deliveryPayload: z.record(z.any()), // JSON payload for webhook
  }),
});

export type SQSMessagePayload = z.infer<typeof SQSMessagePayloadSchema>;
```

**Why this structure?**
- `eventId`: Worker needs to fetch full Event entity from database
- `eventType`: SQS message filtering (future: route to different queues by type)
- `idempotencyKey`: Worker passes to webhook for duplicate prevention
- `metadata`: Additional context to avoid extra database queries

[Source: architecture/data-models.md#Event, architecture/coding-standards.md#Zod-Schemas-as-Single-Source-of-Truth]

### Port Interface - ISQSClient

**Interface Definition:**

```typescript
export interface ISQSClient {
  /**
   * Sends an event message to the SQS queue for asynchronous processing.
   *
   * @param payload - The SQS message payload (validated against SQSMessagePayloadSchema)
   * @returns Promise<string> - SQS MessageId for tracking
   * @throws ValidationError - If payload fails schema validation
   * @throws InfrastructureError - If SQS operation fails
   *
   * @see SQSAdapter for concrete implementation using AWS SDK
   * @see docs/architecture/port-interfaces.md#IMessageSender
   */
  sendMessage(payload: SQSMessagePayload): Promise<string>;
}
```

**Dependency Injection:**
- Use cases depend on `ISQSClient` interface (NOT `SQSAdapter` concrete class)
- Adapter implementations injected at application startup
- Easy to swap SQS for RabbitMQ, Kafka, or in-memory queue

[Source: architecture/port-interfaces.md#IMessageSender]

### AWS SQS Integration

**LocalStack Configuration:**

LocalStack simulates AWS services locally. SQS configuration:

- **Endpoint URL:** `http://localhost:4566` (LocalStack default)
- **Region:** `us-east-1` (LocalStack default)
- **Credentials:** `accessKeyId: 'test', secretAccessKey: 'test'` (LocalStack doesn't validate)
- **Queue Name:** `event-queue`
- **Queue URL:** `http://localhost:4566/000000000000/event-queue`

**SQS Client Setup:**

```typescript
import { SQSClient, SendMessageCommand } from '@aws-sdk/client-sqs';

const sqsClient = new SQSClient({
  region: 'us-east-1',
  endpoint: process.env.AWS_ENDPOINT_URL || 'http://localhost:4566',
  credentials: {
    accessKeyId: 'test',
    secretAccessKey: 'test',
  },
});
```

**Message Attributes:**

SQS supports key-value metadata attached to messages (separate from message body):

```typescript
MessageAttributes: {
  eventType: {
    DataType: 'String',
    StringValue: payload.eventType
  },
  idempotencyKey: {
    DataType: 'String',
    StringValue: payload.idempotencyKey
  }
}
```

**Why use message attributes?**
- Filtering: Future SQS filters can route messages by eventType
- Visibility: CloudWatch metrics can group by eventType
- Debugging: Inspect messages in AWS Console without parsing JSON body

[Source: architecture/tech-stack.md#AWS-Services]

### Zod Schema Validation Strategy

**Schema-First Approach:**

1. Define Zod schema as single source of truth
2. Derive TypeScript types using `z.infer<>`
3. Validate at runtime using `schema.parse()` or `schema.safeParse()`
4. Schema changes automatically propagate to all type references

**Validation Example:**

```typescript
export class SQSAdapter implements ISQSClient {
  public async sendMessage(payload: SQSMessagePayload): Promise<string> {
    // Runtime validation
    const validationResult = SQSMessagePayloadSchema.safeParse(payload);

    if (!validationResult.success) {
      throw new ValidationError(
        'Invalid SQS message payload',
        validationResult.error.errors
      );
    }

    // TypeScript already ensures compile-time type safety
    const validated = validationResult.data;

    // ... send to SQS
  }
}
```

**Benefits:**
- Catches bugs at runtime (e.g., external API sends wrong type)
- Single schema definition for both validation and types
- Compile-time errors when schema changes
- Self-documenting code (schema shows expected structure)

[Source: architecture/coding-standards.md#Zod-Schemas-as-Single-Source-of-Truth, architecture/tech-stack.md#Zod-Over-Joi]

### Coding Standards

**TypeScript Requirements:**
- Strict mode enabled (no `any` types except for `deliveryPayload: z.record(z.any())` due to dynamic nature)
- Explicit accessibility modifiers (`public`, `private`, `protected`)
- Use async/await (no callbacks or raw promises)
- Repository Pattern required (no direct AWS SDK calls from use cases)

**Logging Requirements:**
- Use Pino logger exclusively (`src/shared/logger.ts`)
- Structure logs with context fields (eventId, messageId, error, queueUrl)
- Log levels: ERROR (failures), INFO (success/metrics), DEBUG (detailed flow)
- Never use `console.log` or `console.error` (ESLint will fail)

**Error Handling:**
- Never swallow errors silently
- Always log and rethrow errors with context
- Use custom error classes: `ValidationError`, `InfrastructureError`
- Catch SQS-specific errors and rethrow as application-level errors

**Dependency Injection:**
- Inject SQS client, queue URL, and logger via constructor
- Use interface types for dependencies (ILogger, not Pino directly)
- Enable easy testing with mock implementations

[Source: architecture/coding-standards.md#Core-Standards]

### Project Structure Alignment

**Adapter Location:**
```
src/adapters/secondary/messaging/
├── SQSAdapter.ts          # NEW - This story
├── SQSAdapter.test.ts     # NEW - This story
└── SQSAdapter.integration.test.ts  # NEW - This story
```

**Port Location:**
```
src/modules/event-scheduling/application/ports/
└── ISQSClient.ts          # NEW - This story
```

**Schema Location:**
```
src/shared/validation/
└── schemas.ts             # EXISTING - Add SQSMessagePayloadSchema
```

**Import Rules for Adapter Layer:**
- ✅ Can import: Port interfaces (ISQSClient, ILogger)
- ✅ Can import: Shared schemas (SQSMessagePayloadSchema)
- ✅ Can import: External frameworks (AWS SDK, Zod)
- ✅ Can import: Shared utilities (logger, config)
- ❌ Cannot import: Domain entities directly (use types from schemas instead)
- ❌ Cannot import: Use cases (adapters are called BY use cases, not the reverse)

[Source: architecture/source-tree.md#Import-Rules]

### Error Handling Strategy

**SQS Error Types:**

AWS SQS can throw various errors:

1. **QueueDoesNotExist** - Queue URL is invalid or queue was deleted
2. **InvalidMessageContents** - Message body exceeds 256KB or contains invalid characters
3. **RequestThrottledException** - Too many requests (rate limiting)
4. **ServiceUnavailable** - AWS SQS is temporarily unavailable

**Error Handling Pattern:**

```typescript
try {
  const command = new SendMessageCommand({ /* ... */ });
  const response = await this.sqsClient.send(command);
  return response.MessageId!;
} catch (error) {
  this.logger.error({
    msg: 'Failed to send SQS message',
    error: error instanceof Error ? error.message : String(error),
    eventId: payload.eventId,
    queueUrl: this.queueUrl,
  });

  throw new InfrastructureError(
    `SQS send failed: ${error instanceof Error ? error.message : String(error)}`
  );
}
```

**Why rethrow as InfrastructureError?**
- Abstracts AWS-specific errors from application layer
- Use cases don't need to know about SQS error types
- Easier to test (mock InfrastructureError, not AWS SDK errors)
- Consistent error handling across all adapters

[Source: architecture/error-handling.md#Infrastructure-Errors, architecture/error-handling.md#External-API-Errors]

### Testing

**Unit Test Requirements:**

- **Test file location:** `src/adapters/secondary/messaging/SQSAdapter.test.ts`
- **Testing framework:** Jest
- **Mocking:** Mock AWS SQS client using Jest mocks
- **Pattern:** AAA (Arrange, Act, Assert)
- **Coverage goal:** 100% code coverage for SQSAdapter
- **Test scenarios:**
  - Happy path: valid payload → message sent
  - Schema validation: invalid payload → ValidationError
  - SQS errors: SQS failure → InfrastructureError
  - Logging: verify logger.info and logger.error called
  - Message attributes: verify eventType and idempotencyKey included

**Integration Test Requirements:**

- **Test file location:** `src/adapters/secondary/messaging/SQSAdapter.integration.test.ts`
- **Infrastructure:** Real LocalStack SQS (not mocked)
- **Setup:** Create test queue before tests
- **Teardown:** Purge and delete queue after tests
- **Test scenarios:**
  - Send message to LocalStack → verify message received via ReceiveMessage
  - Verify message body matches sent payload
  - Verify message attributes present
  - Invalid payload → no message in queue
- **Cleanup:** Purge queue between tests to avoid pollution

**Test Naming Convention:**
- File: `{ClassName}.test.ts` or `{ClassName}.integration.test.ts`
- Describe: Use class/method names
- It: Descriptive test names explaining behavior
  - Good: "should send valid message to SQS queue"
  - Bad: "test SQS" or "should work"

[Source: architecture/test-strategy.md#Unit-Tests, architecture/test-strategy.md#Integration-Tests]

### LocalStack Setup

**Queue Creation Script:**

LocalStack requires explicit resource creation via AWS CLI commands. The init script runs on container startup:

**File:** `docker/localstack/init-aws.sh`

```bash
#!/bin/bash
# Create SQS queue for event processing
awslocal sqs create-queue --queue-name event-queue

# Get queue URL and export for application
QUEUE_URL=$(awslocal sqs get-queue-url --queue-name event-queue --query 'QueueUrl' --output text)
echo "SQS Queue created: $QUEUE_URL"
```

**Environment Variables:**

Add to `.env.example`:

```
AWS_ENDPOINT_URL=http://localhost:4566
SQS_QUEUE_URL=http://localhost:4566/000000000000/event-queue
AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=test
AWS_SECRET_ACCESS_KEY=test
```

**Docker Compose Integration:**

LocalStack container is already configured in `docker/docker-compose.yml` (from earlier stories). Verify:

```yaml
localstack:
  image: localstack/localstack:3.1.0
  ports:
    - "4566:4566"
  environment:
    - SERVICES=sqs,eventbridge,lambda
  volumes:
    - ./localstack/init-aws.sh:/etc/localstack/init/ready.d/init-aws.sh
```

[Source: architecture/tech-stack.md#LocalStack]

### Expected SQSAdapter Implementation Skeleton

```typescript
// src/adapters/secondary/messaging/SQSAdapter.ts
import { SQSClient, SendMessageCommand } from '@aws-sdk/client-sqs';
import { ISQSClient } from '../../../modules/event-scheduling/application/ports/ISQSClient';
import { SQSMessagePayload, SQSMessagePayloadSchema } from '../../../shared/validation/schemas';
import { logger } from '../../../shared/logger';
import { ValidationError } from '../../../domain/errors/ValidationError';
import { InfrastructureError } from '../../../domain/errors/InfrastructureError';

/**
 * AWS SQS adapter for sending event messages to the queue.
 *
 * This adapter implements the ISQSClient port interface and uses
 * the AWS SDK for Node.js v3 to interact with SQS.
 *
 * For local development, it connects to LocalStack SQS endpoint.
 * For production, it connects to AWS SQS in us-east-1 region.
 *
 * @see ISQSClient port interface
 * @see docs/architecture/port-interfaces.md#IMessageSender
 */
export class SQSAdapter implements ISQSClient {
  public constructor(
    private readonly sqsClient: SQSClient,
    private readonly queueUrl: string
  ) {}

  /**
   * Sends an event message to the SQS queue.
   *
   * @param payload - The event message payload (validated against schema)
   * @returns SQS MessageId for tracking
   * @throws ValidationError if payload fails schema validation
   * @throws InfrastructureError if SQS operation fails
   */
  public async sendMessage(payload: SQSMessagePayload): Promise<string> {
    // Validate payload against schema
    const validationResult = SQSMessagePayloadSchema.safeParse(payload);

    if (!validationResult.success) {
      throw new ValidationError(
        'Invalid SQS message payload',
        validationResult.error.errors
      );
    }

    try {
      const command = new SendMessageCommand({
        QueueUrl: this.queueUrl,
        MessageBody: JSON.stringify(payload),
        MessageAttributes: {
          eventType: {
            DataType: 'String',
            StringValue: payload.eventType,
          },
          idempotencyKey: {
            DataType: 'String',
            StringValue: payload.idempotencyKey,
          },
        },
      });

      const response = await this.sqsClient.send(command);

      logger.info({
        msg: 'SQS message sent successfully',
        eventId: payload.eventId,
        messageId: response.MessageId,
        queueUrl: this.queueUrl,
      });

      return response.MessageId!;
    } catch (error) {
      logger.error({
        msg: 'Failed to send SQS message',
        error: error instanceof Error ? error.message : String(error),
        eventId: payload.eventId,
        queueUrl: this.queueUrl,
      });

      throw new InfrastructureError(
        `SQS send failed: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
}
```

### Dependencies

**Required Imports:**
- `@aws-sdk/client-sqs` - AWS SDK for SQS operations (`SQSClient`, `SendMessageCommand`)
- `ISQSClient` from `../../../modules/event-scheduling/application/ports/ISQSClient` (port interface)
- `SQSMessagePayload`, `SQSMessagePayloadSchema` from `../../../shared/validation/schemas` (Zod schema and type)
- `logger` from `../../../shared/logger` (Pino logger singleton)
- `ValidationError` from `../../../domain/errors/ValidationError` (custom error class)
- `InfrastructureError` from `../../../domain/errors/InfrastructureError` (custom error class)

**Injected Dependencies (Constructor):**
- `SQSClient` - AWS SQS client (configured for LocalStack or AWS)
- `queueUrl: string` - SQS queue URL (from environment variable)

**No Additional Ports Needed:**
- This story does NOT require IEventRepository (Story 1.7)
- This story does NOT require ClaimReadyEventsUseCase (Story 2.1)
- Focus is purely on the SQS adapter, port interface, and tests

**Integration with Use Cases (Future):**
- Story 2.3 (EventBridge Scheduler) will use `ISQSClient` to send claimed events to queue
- SchedulerHandler will inject `SQSAdapter` as implementation of `ISQSClient`

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Created story for SQS Queue Integration | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used

(To be filled by Dev Agent)

### Debug Log References

(To be filled by Dev Agent)

### Completion Notes

(To be filled by Dev Agent)

### File List

(To be filled by Dev Agent)

---

## QA Results

(To be filled by QA Agent)
