# Story 1.9: UserCreated Event Handler

---

## Status

Todo

---

## Story

**As a** developer,
**I want** an event handler that listens to UserCreated events and generates birthday events,
**so that** User and Event contexts are decoupled via domain events.

---

## Acceptance Criteria

1. UserCreatedEvent interface created in `src/modules/user/domain/events/UserCreated.ts`
2. Event schema includes: eventType, context, occurredAt, aggregateId, userId, firstName, lastName, dateOfBirth, timezone
3. CreateBirthdayEventOnUserCreatedHandler created in `src/modules/event-scheduling/application/event-handlers/`
4. Handler depends on: IEventRepository, TimezoneService, EventHandlerRegistry (NO User dependencies)
5. Handler reconstructs User value objects from UserCreatedEvent payload
6. Handler calculates next birthday using BirthdayEventHandler.calculateNextOccurrence()
7. Handler creates Event entity with correct timestamps (9:00 AM local, converted to UTC)
8. Handler persists Event to database via IEventRepository
9. Handler is registered with IDomainEventBus at application startup
10. Unit tests achieve 100% coverage for event handler
11. Integration test verifies end-to-end flow: UserCreated event → Birthday event created

---

## Tasks / Subtasks

- [ ] **Task 1: Define UserCreatedEvent interface** (AC: 1, 2)
  - [ ] Create directory `src/modules/user/domain/events/` (if not exists)
  - [ ] Create `src/modules/user/domain/events/UserCreated.ts`
  - [ ] Define `UserCreatedEvent` interface extending `DomainEvent`:
    - `eventType: 'UserCreated'` (literal type)
    - `context: 'user'` (literal type)
    - `occurredAt: string` (ISO 8601 timestamp)
    - `aggregateId: string` (User ID)
    - `userId: string` (User ID, same as aggregateId for clarity)
    - `firstName: string`
    - `lastName: string`
    - `dateOfBirth: string` (ISO 8601 date, YYYY-MM-DD)
    - `timezone: string` (IANA timezone identifier)
  - [ ] Add JSDoc comments explaining event purpose and usage
  - [ ] Export interface for use in User Context and Event Scheduling Context

- [ ] **Task 2: Create event handler directory structure** (AC: 3)
  - [ ] Create directory `src/modules/event-scheduling/application/event-handlers/`
  - [ ] Create `CreateBirthdayEventOnUserCreatedHandler.ts` in this directory
  - [ ] Note: This mirrors the bounded context structure documented in architecture

- [ ] **Task 3: Implement CreateBirthdayEventOnUserCreatedHandler class** (AC: 3, 4)
  - [ ] Define `CreateBirthdayEventOnUserCreatedHandler` class
  - [ ] Add constructor with dependencies (dependency injection):
    - `private readonly eventRepository: IEventRepository`
    - `private readonly timezoneService: TimezoneService`
    - `private readonly eventHandlerRegistry: EventHandlerRegistry`
  - [ ] DO NOT depend on `IUserRepository` or any User Context ports
  - [ ] All dependencies are from Event Scheduling Context or domain services
  - [ ] Follow coding standards: PascalCase class name, explicit types, no `any`

- [ ] **Task 4: Implement handle() method** (AC: 5, 6, 7, 8)
  - [ ] Define `public async handle(event: UserCreatedEvent): Promise<void>`
  - [ ] Step 1: Reconstruct User value objects from event payload:
    - `const dateOfBirth = new DateOfBirth(event.dateOfBirth)`
    - `const timezone = new Timezone(event.timezone)`
  - [ ] Step 2: Create lightweight User representation (not full entity):
    - Object with `{ id, firstName, lastName, dateOfBirth, timezone }`
    - Only properties needed for event generation
  - [ ] Step 3: Get BirthdayEventHandler from registry:
    - `const handler = this.eventHandlerRegistry.getHandler('BIRTHDAY')`
  - [ ] Step 4: Calculate next birthday at 9:00 AM local time:
    - `const nextBirthdayLocal = handler.calculateNextOccurrence(user)`
  - [ ] Step 5: Convert to UTC:
    - `const nextBirthdayUTC = this.timezoneService.convertToUTC(nextBirthdayLocal, timezone)`
  - [ ] Step 6: Create Event entity:
    - Generate new UUID for event ID
    - Set `eventType: 'BIRTHDAY'`
    - Set `status: EventStatus.PENDING`
    - Set `targetTimestampUTC: nextBirthdayUTC`
    - Set `targetTimestampLocal: nextBirthdayLocal`
    - Set `targetTimezone: timezone.toString()`
    - Generate `idempotencyKey: IdempotencyKey.generate(userId, nextBirthdayUTC)`
    - Format payload: `{ message: handler.formatMessage(user) }`
    - Set `version: 1`, `retryCount: 0`, `executedAt: null`, `failureReason: null`
  - [ ] Step 7: Persist Event:
    - `await this.eventRepository.create(event)`
  - [ ] Add error handling: Catch and log errors with event context

- [ ] **Task 5: Wire up event handler at application startup** (AC: 9)
  - [ ] Create `src/index.ts` (or update existing main file)
  - [ ] Import `InMemoryEventBus`, `CreateBirthdayEventOnUserCreatedHandler`
  - [ ] Instantiate event bus: `const eventBus = new InMemoryEventBus()`
  - [ ] Instantiate event handler with dependencies:
    - `const handler = new CreateBirthdayEventOnUserCreatedHandler(eventRepo, timezoneService, eventHandlerRegistry)`
  - [ ] Register handler with event bus:
    - `eventBus.subscribe('UserCreated', (event) => handler.handle(event))`
  - [ ] Comment explaining this wiring is the "glue" between contexts
  - [ ] Document: In Phase 2, this becomes Lambda event source mapping (EventBridge → Lambda)

- [ ] **Task 6: Write unit tests for event handler** (AC: 10)
  - [ ] Create `CreateBirthdayEventOnUserCreatedHandler.test.ts`
  - [ ] Test: "should create birthday event from UserCreated event"
    - Arrange: Mock repos and services, create UserCreatedEvent payload
    - Act: Call `handler.handle(event)`
    - Assert:
      - `eventRepository.create` called once
      - Event has `eventType: 'BIRTHDAY'`
      - Event has `status: PENDING`
      - Event has correct `userId` from UserCreatedEvent
      - Event has `targetTimestampUTC` at 9:00 AM in user's timezone
  - [ ] Test: "should calculate next birthday correctly for different timezones"
    - Arrange: UserCreatedEvent with timezone "America/New_York"
    - Act: Call handler
    - Assert: Event timestamp is 14:00 UTC (9:00 AM EST converted to UTC)
  - [ ] Test: "should handle leap year birthdays (Feb 29)"
    - Arrange: UserCreatedEvent with dateOfBirth "1992-02-29"
    - Act: Call handler
    - Assert: Event created for Feb 28 in non-leap years
  - [ ] Test: "should generate idempotency key correctly"
    - Arrange: UserCreatedEvent
    - Act: Call handler
    - Assert: Idempotency key = hash(userId + targetTimestampUTC)
  - [ ] Test: "should format birthday message correctly"
    - Arrange: UserCreatedEvent with firstName "John", lastName "Doe"
    - Act: Call handler
    - Assert: Event payload message = "Hey, John Doe it's your birthday"
  - [ ] Test: "should throw error if dateOfBirth is invalid"
    - Arrange: UserCreatedEvent with invalid dateOfBirth
    - Act & Assert: Expect handler to throw InvalidDateOfBirthError
  - [ ] Test: "should throw error if timezone is invalid"
    - Arrange: UserCreatedEvent with invalid timezone
    - Act & Assert: Expect handler to throw InvalidTimezoneError
  - [ ] Achieve 100% code coverage

- [ ] **Task 7: Write integration test for end-to-end flow** (AC: 11)
  - [ ] Create integration test file (or add to existing)
  - [ ] Test: "should create birthday event when UserCreated event published"
    - Arrange:
      - Real InMemoryEventBus
      - Real CreateBirthdayEventOnUserCreatedHandler (with real dependencies)
      - In-memory repositories (or Testcontainers PostgreSQL)
      - Real TimezoneService, real EventHandlerRegistry
    - Act:
      - Wire up handler: `eventBus.subscribe('UserCreated', handler.handle)`
      - Publish UserCreatedEvent: `eventBus.publish(userCreatedEvent)`
      - Wait for async processing (100ms delay)
    - Assert:
      - Birthday event exists in event repository
      - Event has correct userId
      - Event has correct targetTimestampUTC (9:00 AM local → UTC)
      - Event has PENDING status
  - [ ] Use real dependencies (not mocks) to verify integration

---

## Dev Notes

This story implements the **Event Handler** that reacts to `UserCreated` domain events and generates birthday events. It completes the bounded context decoupling by moving Event creation logic OUT of User Context INTO Event Scheduling Context.

### Architecture Context

**[Source: architecture/bounded-contexts.md#event-handler-react-to-usercreated]**

This handler belongs in:

- **Location:** `src/modules/event-scheduling/application/event-handlers/CreateBirthdayEventOnUserCreatedHandler.ts`
- **Bounded Context:** Event Scheduling Context
- **Layer:** Application layer (orchestrates domain logic)
- **Dependencies:**
  - Event Scheduling ports (`@modules/event-scheduling/application/ports/IEventRepository`)
  - Event Scheduling domain services (`@modules/event-scheduling/domain/services/TimezoneService`, `@modules/event-scheduling/domain/services/EventHandlerRegistry`)
  - User domain events (`@modules/user/domain/events/UserCreatedEvent`)
  - Shared domain event bus (`@shared/events/IDomainEventBus`)
- **NEVER depends on:** User Context ports (IUserRepository) or User use cases

**Import Path Example:**

```typescript
// src/modules/event-scheduling/application/event-handlers/CreateBirthdayEventOnUserCreatedHandler.ts
import { UserCreatedEvent } from '@modules/user/domain/events/UserCreatedEvent';
import { IEventRepository } from '../ports/IEventRepository';
import { TimezoneService } from '../../domain/services/TimezoneService';
import { EventHandlerRegistry } from '../../domain/services/EventHandlerRegistry';
import { Event } from '../../domain/entities/Event';
import { Timezone } from '@shared/value-objects/Timezone';
import { DateOfBirth } from '@modules/user/domain/value-objects/DateOfBirth';
```

---

### Why This Pattern Matters

**Before (Tight Coupling):**
```typescript
// ❌ CreateUserUseCase directly creates Event
class CreateUserUseCase {
  constructor(
    private userRepository: IUserRepository,
    private eventRepository: IEventRepository,  // ❌ Cross-context dependency
    private timezoneService: TimezoneService,   // ❌ Event domain service
  ) {}

  async execute(dto: CreateUserDTO): Promise<User> {
    const user = await this.userRepository.create(user);
    const event = this.createEventEntity(user);  // ❌ User context knows Event internals
    await this.eventRepository.create(event);
    return user;
  }
}
```

**After (Decoupled via Domain Events):**
```typescript
// ✅ CreateUserUseCase publishes domain event
class CreateUserUseCase {
  constructor(
    private userRepository: IUserRepository,
    private eventBus: IDomainEventBus  // ✅ Generic abstraction
  ) {}

  async execute(dto: CreateUserDTO): Promise<User> {
    const user = await this.userRepository.create(user);
    await this.eventBus.publish({
      eventType: 'UserCreated',
      userId: user.id,
      // ... user data
    });
    return user;  // ✅ Event creation happens asynchronously
  }
}

// ✅ Event handler creates Event (separate context)
class CreateBirthdayEventOnUserCreatedHandler {
  constructor(
    private eventRepository: IEventRepository,
    private timezoneService: TimezoneService,
  ) {}

  async handle(event: UserCreatedEvent): Promise<void> {
    // Reconstruct User data from event
    const user = { id: event.userId, ... };
    const birthdayEvent = this.createEventEntity(user);
    await this.eventRepository.create(birthdayEvent);
  }
}
```

**Benefits:**
- ✅ User Context has ZERO knowledge of Event Context
- ✅ Easier to test (mock event bus, not entire Event infrastructure)
- ✅ Future-proof for microservices (same pattern works with EventBridge)
- ✅ Single Responsibility: User creates users, Event creates events

---

### Data Flow

```
User API Request
      ↓
CreateUserUseCase.execute(dto)
      ↓
userRepository.create(user)  ← User persisted to DB
      ↓
eventBus.publish(UserCreatedEvent)  ← Domain event published
      ↓
InMemoryEventBus routes event
      ↓
CreateBirthdayEventOnUserCreatedHandler.handle(event)
      ↓
Calculate next birthday (TimezoneService + BirthdayEventHandler)
      ↓
eventRepository.create(birthdayEvent)  ← Event persisted to DB
      ↓
User API returns 201 Created
```

**Timing:**
- User Context: 50ms (create user + publish event)
- Event Handler: 20ms (create event) - **runs asynchronously**
- Total API response time: **50ms** (Event creation doesn't block user creation)

---

### Error Handling Strategy

**Scenario: Event Handler Fails**

```typescript
// User created successfully ✅
await userRepository.create(user);

// Event published successfully ✅
await eventBus.publish(userCreatedEvent);

// Event handler FAILS ❌ (network issue, DB down, etc.)
await handler.handle(event);  // Throws error
```

**What happens?**
1. User exists in database ✅
2. Birthday Event does NOT exist ❌
3. **System is temporarily inconsistent**

**How do we fix it?**
- **Self-Healing Job** (Story 3.1 or 3.2 from Epic 3)
- Job runs every hour, detects users without PENDING birthday events
- Regenerates missing events

**Why this is acceptable:**
- Event is derivable from User (can regenerate anytime)
- Birthday is not time-critical (missing 1 hour doesn't matter)
- User experience: User created successfully, birthday scheduled soon

---

### Testing Strategy

**Unit Tests (Isolated Handler Logic):**
- Mock all dependencies (IEventRepository, TimezoneService, EventHandlerRegistry)
- Test business logic: timezone conversions, date calculations, message formatting
- Test error scenarios: invalid timezone, invalid date of birth

**Integration Tests (Real Event Bus Flow):**
- Real InMemoryEventBus + real handler + real domain services
- Test end-to-end: Publish UserCreatedEvent → Birthday event created in DB
- Test timing: Verify async execution doesn't block

**Example Integration Test:**

```typescript
describe('UserCreated Event Flow (Integration)', () => {
  it('should create birthday event when UserCreated event published', async () => {
    // Arrange: Real dependencies
    const eventBus = new InMemoryEventBus();
    const eventRepo = new InMemoryEventRepository();
    const timezoneService = new TimezoneService();
    const eventHandlerRegistry = new EventHandlerRegistry();
    eventHandlerRegistry.register(new BirthdayEventHandler(timezoneService));

    const handler = new CreateBirthdayEventOnUserCreatedHandler(
      eventRepo,
      timezoneService,
      eventHandlerRegistry
    );

    // Wire up event bus
    eventBus.subscribe('UserCreated', (e) => handler.handle(e));

    // Act: Publish UserCreated event
    await eventBus.publish({
      eventType: 'UserCreated',
      context: 'user',
      occurredAt: DateTime.now().toISO(),
      aggregateId: 'user-123',
      userId: 'user-123',
      firstName: 'John',
      lastName: 'Doe',
      dateOfBirth: '1990-01-15',
      timezone: 'America/New_York'
    });

    // Wait for async handler
    await new Promise(resolve => setTimeout(resolve, 100));

    // Assert: Birthday event created
    const events = await eventRepo.findByUserId('user-123');
    expect(events).toHaveLength(1);
    expect(events[0].eventType).toBe('BIRTHDAY');
    expect(events[0].status).toBe(EventStatus.PENDING);
  });
});
```

---

### Future Extensibility: Add Anniversary Events

**Story 2.X: AnniversaryEventHandler** (Future Epic 2)

```typescript
// Same pattern, different handler
class CreateAnniversaryEventOnUserCreatedHandler {
  async handle(event: UserCreatedEvent): Promise<void> {
    const handler = this.eventHandlerRegistry.getHandler('ANNIVERSARY');
    const nextAnniversary = handler.calculateNextOccurrence(user);
    const anniversaryEvent = new Event({
      eventType: 'ANNIVERSARY',  // Different event type
      // ... same pattern
    });
    await this.eventRepository.create(anniversaryEvent);
  }
}

// Wire up at startup
eventBus.subscribe('UserCreated', (e) => anniversaryHandler.handle(e));
```

**Key Point:** Adding new event types requires ZERO changes to User Context or CreateUserUseCase.

---

## Dependencies

- **Depends on:** Story 1.8 (Domain Event Bus Infrastructure)
- **Blocks:** Story 1.10 (Refactored CreateUserUseCase must publish UserCreated event)

---

## Effort Estimate

**4-6 hours**

- Task 1-2 (Interfaces + Directory): 1 hour
- Task 3-5 (Implementation + Wiring): 2 hours
- Task 6 (Unit Tests): 2 hours
- Task 7 (Integration Test): 1 hour

---

## Definition of Done

- [ ] UserCreatedEvent interface defined with all required properties
- [ ] CreateBirthdayEventOnUserCreatedHandler implements event handling logic
- [ ] Handler calculates next birthday at 9:00 AM local time (converted to UTC)
- [ ] Handler creates Event entity and persists to database
- [ ] Handler registered with event bus at application startup
- [ ] Unit tests achieve 100% coverage
- [ ] Integration test verifies end-to-end UserCreated → Birthday event flow
- [ ] All tests pass (`npm test`)
- [ ] ESLint passes with 0 errors
- [ ] TypeScript strict mode compilation succeeds
- [ ] Code reviewed and approved

---

## References

- **Architecture Decision:** [Bounded Contexts & Eventual Consistency](../architecture/bounded-contexts.md#event-handler-react-to-usercreated)
- **Scalability Analysis:** [Event Scheduling Context](../architecture/scalability-analysis.md#event-scheduling-context-high-scale-critical-path)
- **Impact Assessment:** [Story 1.10 Prerequisites](../architecture/bounded-contexts-impact-assessment.md#change-3-new-story-110---event-handler-for-usercreated)
- **Design Patterns:** [Strategy Pattern (EventHandlerRegistry)](../architecture/design-patterns.md#1-strategy-pattern---event-type-handlers)
