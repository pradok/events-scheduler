# Story 1.11: User CRUD Use Cases & REST API

---

## Status

Approved

---

## Story

**As a** developer,
**I want** complete user CRUD use cases with Fastify REST API endpoints,
**so that** users can be managed via HTTP requests and updated user data triggers appropriate event rescheduling.

---

## Acceptance Criteria

**Core API & Use Cases:**

1. Zod schemas defined for all operations: CreateUserSchema (✅ Done), UpdateUserSchema, GetUserParamsSchema, UserResponseSchema
2. TypeScript types derived from schemas using `z.infer<>` for use across all layers
3. GetUserUseCase, UpdateUserUseCase, DeleteUserUseCase created using derived types
4. DeleteUserUseCase cancels all pending events for deleted user
5. Fastify 4.26.0 server configured with fastify-type-provider-zod in `src/adapters/primary/http/server.ts`
6. POST /user (✅ Done), GET /user/:id, PUT /user/:id, DELETE /user/:id endpoints implemented with schema validation
7. Routes use Fastify schema property with Zod schemas for automatic validation and type inference
8. All endpoints return appropriate HTTP status codes (200, 201, 400, 404, 500)
9. Zod validation errors automatically mapped to HTTP 400 responses by Fastify
10. Response schemas defined for all endpoints with automatic serialization validation
11. Integration tests verify all CRUD operations work end-to-end with real database
12. Tests verify type safety: schema changes cause TypeScript compilation errors in dependent code

**UpdateUserUseCase Event Rescheduling Logic:**

13. When user birthday is updated (dateOfBirth field):
    - Query for PENDING events for this user with eventType='BIRTHDAY'
    - If PENDING event exists:
      - Update targetTimestampUTC to new birthday at 9:00 AM in user's current timezone
      - Update targetTimestampLocal field to reflect new local time
      - Update dateOfBirth reference in event metadata
    - If new birthday date has already passed this year, set targetTimestamp for next year's birthday
    - Do NOT modify events with status PROCESSING, COMPLETED, or FAILED (these are historical)

14. When user timezone is updated (timezone field):
    - Query for PENDING events for this user
    - For each PENDING event:
      - Recalculate targetTimestampUTC to maintain same local time (9:00 AM) in new timezone
      - Update targetTimezone field to new timezone value
      - Keep targetTimestampLocal unchanged (still 9:00 AM local)
    - Do NOT modify events with status PROCESSING, COMPLETED, or FAILED

15. When both birthday AND timezone updated in single request:
    - Apply birthday update logic first (new date)
    - Then apply timezone update logic (new timezone for new date)
    - Ensure atomic transaction (both user update and event reschedule succeed or both fail)

16. Unit tests verify rescheduling logic:
    - Birthday changed before current year's event executes: event updated to new date
    - Birthday changed after current year's event passed: new event created for next year
    - Timezone changed: event time recalculated to maintain 9:00 AM local in new timezone
    - Both birthday and timezone changed: both updates applied atomically
    - Events in PROCESSING/COMPLETED/FAILED status are never modified
    - Edge case: Birthday changed to Feb 29 in non-leap year handled correctly (Mar 1)

17. Integration tests verify database transactions:
    - User update and event reschedule succeed together or fail together
    - No orphaned events after failed user update
    - Concurrent user updates don't create duplicate events (optimistic locking tested)

---

## Tasks / Subtasks

- [ ] **Task 1: Define Zod schemas for all operations** (AC: 1, 2, 10)
  - [ ] Open `src/shared/validation/schemas.ts`
  - [ ] Define `UpdateUserSchema`:
    ```typescript
    export const UpdateUserSchema = z.object({
      firstName: z.string().min(1).max(100).optional(),
      lastName: z.string().min(1).max(100).optional(),
      dateOfBirth: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
      timezone: z.string().optional()
    });
    export type UpdateUserDTO = z.infer<typeof UpdateUserSchema>;
    ```
  - [ ] Define `GetUserParamsSchema`:
    ```typescript
    export const GetUserParamsSchema = z.object({
      id: z.string().uuid()
    });
    export type GetUserParams = z.infer<typeof GetUserParamsSchema>;
    ```
  - [ ] Define `UserResponseSchema`:
    ```typescript
    export const UserResponseSchema = z.object({
      id: z.string().uuid(),
      firstName: z.string(),
      lastName: z.string(),
      dateOfBirth: z.string(),
      timezone: z.string(),
      createdAt: z.string(),
      updatedAt: z.string()
    });
    export type UserResponse = z.infer<typeof UserResponseSchema>;
    ```
  - [ ] Export all schemas and derived types

- [ ] **Task 2: Create GetUserUseCase** (AC: 3)
  - [ ] Create file `src/modules/user/application/use-cases/GetUserUseCase.ts`
  - [ ] Constructor receives `IUserRepository` via DI
  - [ ] Implement `execute(userId: string): Promise<User | null>`
  - [ ] Call `userRepository.findById(userId)`
  - [ ] Return User entity or null if not found
  - [ ] Add JSDoc documentation

- [ ] **Task 3: Create UpdateUserUseCase with event rescheduling** (AC: 3, 13, 14, 15)
  - [ ] Create file `src/modules/user/application/use-cases/UpdateUserUseCase.ts`
  - [ ] Constructor receives:
    - `IUserRepository`
    - `IEventRepository` (from Event Scheduling Context)
    - `TimezoneService` (from Event Scheduling Context)
    - `EventHandlerRegistry` (from Event Scheduling Context)
  - [ ] Implement `execute(userId: string, dto: UpdateUserDTO): Promise<User>`
  - [ ] Fetch existing user from repository
  - [ ] Validate UpdateUserDTO using Zod schema
  - [ ] Track which fields changed (dateOfBirth, timezone)
  - [ ] Update User entity properties
  - [ ] Save updated user to database
  - [ ] If dateOfBirth changed: call `rescheduleEventsForBirthdayChange(user, oldBirthday, newBirthday)`
  - [ ] If timezone changed: call `rescheduleEventsForTimezoneChange(user, oldTimezone, newTimezone)`
  - [ ] Wrap user update + event rescheduling in single database transaction
  - [ ] Return updated User entity

- [ ] **Task 4: Implement birthday reschedule logic** (AC: 13)
  - [ ] In UpdateUserUseCase, create private method `rescheduleEventsForBirthdayChange(user, oldBirthday, newBirthday)`
  - [ ] Query for PENDING events: `eventRepository.findByUserId(user.id)` filter by `status === 'PENDING'` and `eventType === 'BIRTHDAY'`
  - [ ] For each PENDING birthday event:
    - Calculate new next birthday using `BirthdayEventHandler.calculateNextOccurrence(user)`
    - Convert to UTC using `timezoneService.convertToUTC(nextBirthdayLocal, user.timezone)`
    - Update event properties:
      - `targetTimestampUTC = nextBirthdayUTC`
      - `targetTimestampLocal = nextBirthdayLocal`
      - `targetTimezone = user.timezone.toString()`
    - Call `eventRepository.update(event)`
  - [ ] Handle edge case: If new birthday already passed this year, schedule for next year
  - [ ] Handle edge case: Feb 29 birthday in non-leap year (use Feb 28 or Mar 1)
  - [ ] Do NOT modify events with status PROCESSING, COMPLETED, or FAILED

- [ ] **Task 5: Implement timezone reschedule logic** (AC: 14)
  - [ ] In UpdateUserUseCase, create private method `rescheduleEventsForTimezoneChange(user, oldTimezone, newTimezone)`
  - [ ] Query for PENDING events: `eventRepository.findByUserId(user.id)` filter by `status === 'PENDING'`
  - [ ] For each PENDING event:
    - Keep `targetTimestampLocal` unchanged (e.g., still 9:00 AM)
    - Recalculate `targetTimestampUTC` using new timezone: `timezoneService.convertToUTC(event.targetTimestampLocal, newTimezone)`
    - Update event properties:
      - `targetTimestampUTC = recalculatedUTC`
      - `targetTimezone = newTimezone.toString()`
    - Call `eventRepository.update(event)`
  - [ ] Do NOT modify events with status PROCESSING, COMPLETED, or FAILED

- [ ] **Task 6: Create DeleteUserUseCase** (AC: 3, 4)
  - [ ] Create file `src/modules/user/application/use-cases/DeleteUserUseCase.ts`
  - [ ] Constructor receives:
    - `IUserRepository`
    - `IEventRepository` (for cascade delete)
  - [ ] Implement `execute(userId: string): Promise<void>`
  - [ ] Wrap in database transaction:
    - Delete all events for user: `eventRepository.deleteByUserId(userId)`
    - Delete user: `userRepository.delete(userId)`
  - [ ] Ensure cascade delete succeeds or both operations fail
  - [ ] Add JSDoc documentation

- [ ] **Task 7: Configure Fastify server with fastify-type-provider-zod** (AC: 5, 7)
  - [ ] Create file `src/adapters/primary/http/server.ts`
  - [ ] Install and import `fastify-type-provider-zod@2.0.0`
  - [ ] Create Fastify instance:
    ```typescript
    const server = fastify().withTypeProvider<ZodTypeProvider>();
    ```
  - [ ] Register Zod validation plugin:
    ```typescript
    server.setValidatorCompiler(validatorCompiler);
    server.setSerializerCompiler(serializerCompiler);
    ```
  - [ ] Configure error handler to map Zod errors to HTTP 400 (AC: 9)
  - [ ] Export server instance

- [ ] **Task 8: Implement GET /user/:id endpoint** (AC: 6, 7, 8)
  - [ ] Create file `src/adapters/primary/http/routes/user.routes.ts`
  - [ ] Define route:
    ```typescript
    server.get('/user/:id', {
      schema: {
        params: GetUserParamsSchema,
        response: { 200: UserResponseSchema, 404: ErrorSchema }
      }
    }, async (request, reply) => { ... });
    ```
  - [ ] Instantiate GetUserUseCase with dependencies
  - [ ] Call `getUserUseCase.execute(request.params.id)`
  - [ ] If user found: return 200 with UserResponse
  - [ ] If user not found: return 404 with error message
  - [ ] Handle errors: 500 for unexpected errors

- [ ] **Task 9: Implement PUT /user/:id endpoint** (AC: 6, 7, 8)
  - [ ] Define route:
    ```typescript
    server.put('/user/:id', {
      schema: {
        params: GetUserParamsSchema,
        body: UpdateUserSchema,
        response: { 200: UserResponseSchema, 404: ErrorSchema, 400: ErrorSchema }
      }
    }, async (request, reply) => { ... });
    ```
  - [ ] Instantiate UpdateUserUseCase with dependencies
  - [ ] Call `updateUserUseCase.execute(request.params.id, request.body)`
  - [ ] If user found and updated: return 200 with updated UserResponse
  - [ ] If user not found: return 404
  - [ ] If validation fails: return 400 (handled by Fastify + Zod)
  - [ ] Handle errors: 500 for unexpected errors

- [ ] **Task 10: Implement DELETE /user/:id endpoint** (AC: 6, 7, 8)
  - [ ] Define route:
    ```typescript
    server.delete('/user/:id', {
      schema: {
        params: GetUserParamsSchema,
        response: { 204: z.void(), 404: ErrorSchema }
      }
    }, async (request, reply) => { ... });
    ```
  - [ ] Instantiate DeleteUserUseCase with dependencies
  - [ ] Call `deleteUserUseCase.execute(request.params.id)`
  - [ ] If user deleted successfully: return 204 No Content
  - [ ] If user not found: return 404
  - [ ] Handle errors: 500 for unexpected errors

- [ ] **Task 11: Unit test GetUserUseCase** (AC: 11, 12)
  - [ ] Create file `src/modules/user/application/use-cases/GetUserUseCase.test.ts`
  - [ ] Mock IUserRepository
  - [ ] Test: "should return user when found"
  - [ ] Test: "should return null when user not found"
  - [ ] Test: "should throw error if repository fails"
  - [ ] Achieve 100% coverage

- [ ] **Task 12: Unit test UpdateUserUseCase** (AC: 16)
  - [ ] Create file `src/modules/user/application/use-cases/UpdateUserUseCase.test.ts`
  - [ ] Mock IUserRepository, IEventRepository, TimezoneService, EventHandlerRegistry
  - [ ] Test: "should update user firstName and lastName only"
  - [ ] Test: "should reschedule PENDING events when dateOfBirth updated"
  - [ ] Test: "should reschedule PENDING events when timezone updated"
  - [ ] Test: "should reschedule events for both dateOfBirth and timezone change"
  - [ ] Test: "should NOT modify PROCESSING, COMPLETED, or FAILED events"
  - [ ] Test: "should handle Feb 29 birthday in non-leap year"
  - [ ] Test: "should handle birthday that already passed this year"
  - [ ] Test: "should throw UserNotFoundError when user doesn't exist"
  - [ ] Achieve 100% coverage for rescheduling logic

- [ ] **Task 13: Unit test DeleteUserUseCase** (AC: 11, 12)
  - [ ] Create file `src/modules/user/application/use-cases/DeleteUserUseCase.test.ts`
  - [ ] Mock IUserRepository, IEventRepository
  - [ ] Test: "should delete user and all associated events"
  - [ ] Test: "should delete user with no events"
  - [ ] Test: "should throw UserNotFoundError when user doesn't exist"
  - [ ] Test: "should rollback transaction if event deletion fails"
  - [ ] Achieve 100% coverage

- [ ] **Task 14: Integration test GET /user/:id endpoint** (AC: 11)
  - [ ] Create file `src/adapters/primary/http/routes/user.routes.integration.test.ts`
  - [ ] Use Testcontainers for real PostgreSQL
  - [ ] Setup: Seed test user in database
  - [ ] Test: "GET /user/:id returns 200 with user data when user exists"
  - [ ] Test: "GET /user/:id returns 404 when user not found"
  - [ ] Test: "GET /user/:id returns 400 for invalid UUID format"
  - [ ] Cleanup: Delete test data after each test

- [ ] **Task 15: Integration test PUT /user/:id endpoint** (AC: 11, 17)
  - [ ] Setup: Seed test user with PENDING birthday event
  - [ ] Test: "PUT /user/:id updates firstName and lastName successfully"
  - [ ] Test: "PUT /user/:id updates dateOfBirth and reschedules PENDING events"
  - [ ] Test: "PUT /user/:id updates timezone and recalculates event UTC times"
  - [ ] Test: "PUT /user/:id updates both dateOfBirth and timezone atomically"
  - [ ] Test: "PUT /user/:id does NOT modify COMPLETED events"
  - [ ] Test: "PUT /user/:id returns 404 when user not found"
  - [ ] Test: "PUT /user/:id returns 400 for invalid input (future birthday)"
  - [ ] Test: "PUT /user/:id rollback on event update failure"
  - [ ] Verify database transactions: user update and event reschedule succeed together or fail together

- [ ] **Task 16: Integration test DELETE /user/:id endpoint** (AC: 11, 17)
  - [ ] Setup: Seed test user with multiple events (PENDING, COMPLETED, FAILED)
  - [ ] Test: "DELETE /user/:id returns 204 and deletes user + all events"
  - [ ] Test: "DELETE /user/:id returns 404 when user not found"
  - [ ] Test: "DELETE /user/:id is idempotent (204 even if already deleted)"
  - [ ] Verify cascade delete: events table has 0 events for deleted user
  - [ ] Verify transaction rollback: if event deletion fails, user NOT deleted

- [ ] **Task 17: Verify type safety with schema changes** (AC: 12)
  - [ ] Modify UserResponseSchema to add a new required field
  - [ ] Run `npx tsc --noEmit`
  - [ ] Verify TypeScript compilation errors in routes/use cases
  - [ ] Revert schema change
  - [ ] Document in test that type safety is enforced across layers

- [ ] **Task 18: Run full test suite and verify compliance** (AC: 11)
  - [ ] Run `npm test` to execute all unit + integration tests
  - [ ] Run `npx eslint src/` to verify coding standards
  - [ ] Run `npx tsc --noEmit` to verify strict mode passes
  - [ ] Achieve minimum 90% overall coverage
  - [ ] Achieve 100% coverage for critical rescheduling logic

---

## Dev Notes

This story implements the complete User CRUD REST API with Fastify, extending the existing CreateUser functionality (Story 1.10) with Read, Update, and Delete operations. The UpdateUserUseCase includes complex event rescheduling logic to ensure birthday events stay synchronized when users change their birthday or timezone.

### Architecture Context

**[Source: docs/architecture/bounded-contexts.md, docs/architecture/source-tree.md]**

This story spans two bounded contexts:

- **User Context (`src/modules/user/`):** Owns User entities and user CRUD operations
- **Event Scheduling Context (`src/modules/event-scheduling/`):** Owns Event entities and scheduling logic

**Cross-Context Communication:**

- UpdateUserUseCase (User Context) directly calls IEventRepository (Event Scheduling Context) for event rescheduling
- This is acceptable because rescheduling is synchronous business logic triggered by user updates
- DeleteUserUseCase uses cascade delete pattern to remove all events when user deleted

**File Locations:**

Use Cases (User Context):
- `src/modules/user/application/use-cases/GetUserUseCase.ts` (NEW)
- `src/modules/user/application/use-cases/UpdateUserUseCase.ts` (NEW)
- `src/modules/user/application/use-cases/DeleteUserUseCase.ts` (NEW)
- `src/modules/user/application/use-cases/CreateUserUseCase.ts` (✅ DONE - Story 1.10)

Schemas (Shared):
- `src/shared/validation/schemas.ts` (EXTEND - add UpdateUserSchema, GetUserParamsSchema, UserResponseSchema)

Fastify Server (Primary Adapter):
- `src/adapters/primary/http/server.ts` (NEW)
- `src/adapters/primary/http/routes/user.routes.ts` (NEW)

Tests:
- `src/modules/user/application/use-cases/GetUserUseCase.test.ts` (NEW)
- `src/modules/user/application/use-cases/UpdateUserUseCase.test.ts` (NEW)
- `src/modules/user/application/use-cases/DeleteUserUseCase.test.ts` (NEW)
- `src/adapters/primary/http/routes/user.routes.integration.test.ts` (NEW)

### Zod Schema-First Approach

**[Source: docs/architecture/coding-standards.md#zod-schemas-as-single-source-of-truth]**

**Critical Pattern:** Define Zod schemas as the **single source of truth** for all data structures. Use `z.infer<>` to derive TypeScript types.

**Why this matters:**
- Schema changes automatically propagate throughout the codebase
- TypeScript compiler detects breaking changes across all layers
- Eliminates drift between validation rules and type definitions
- Provides both runtime validation AND compile-time type checking
- Fastify integration provides automatic request/response validation

**Example Pattern for UpdateUserSchema:**

```typescript
// src/shared/validation/schemas.ts
import { z } from 'zod';

export const UpdateUserSchema = z.object({
  firstName: z.string().min(1).max(100).optional(),
  lastName: z.string().min(1).max(100).optional(),
  dateOfBirth: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  timezone: z.string().optional()
});

// Derive type from schema - NEVER manually define this type!
export type UpdateUserDTO = z.infer<typeof UpdateUserSchema>;
```

**Benefits:**
- Single location to update when requirements change
- Fastify routes will use this schema for automatic validation
- Type safety from API endpoint → use case → domain layer

### Fastify Integration with Zod

**[Source: docs/architecture/tech-stack.md#fastify-over-express]**

**Fastify 4.26.0** chosen for native TypeScript support and Zod integration via `fastify-type-provider-zod@2.0.0`.

**Setup Pattern:**

```typescript
// src/adapters/primary/http/server.ts
import fastify from 'fastify';
import { serializerCompiler, validatorCompiler, ZodTypeProvider } from 'fastify-type-provider-zod';

const server = fastify().withTypeProvider<ZodTypeProvider>();

// Register Zod validation
await server.register(fastifyTypeProviderZod);
server.setValidatorCompiler(validatorCompiler);
server.setSerializerCompiler(serializerCompiler);
```

**Route Definition Pattern:**

```typescript
// src/adapters/primary/http/routes/user.routes.ts
server.get('/user/:id', {
  schema: {
    params: GetUserParamsSchema,     // Validates request params
    response: {
      200: UserResponseSchema,        // Validates response body
      404: ErrorSchema
    }
  }
}, async (request, reply) => {
  // request.params is fully typed from GetUserParamsSchema!
  const userId: string = request.params.id;

  const user = await getUserUseCase.execute(userId);

  if (!user) {
    return reply.status(404).send({ error: 'User not found' });
  }

  // Response automatically validated against UserResponseSchema
  return reply.status(200).send({
    id: user.id,
    firstName: user.firstName,
    lastName: user.lastName,
    dateOfBirth: user.dateOfBirth.toString(),
    timezone: user.timezone.toString(),
    createdAt: user.createdAt.toISO(),
    updatedAt: user.updatedAt.toISO()
  });
});
```

**Automatic Error Handling:**

Fastify + Zod automatically returns HTTP 400 for validation errors with detailed error messages:

```json
{
  "statusCode": 400,
  "error": "Bad Request",
  "message": "params/id must match format \"uuid\""
}
```

### Data Models

**[Source: docs/architecture/data-models.md#user]**

**User Entity:**

- `id: string` - UUID generated on creation
- `firstName: string` - 1-100 characters (validated by Zod schema)
- `lastName: string` - 1-100 characters (validated by Zod schema)
- `dateOfBirth: DateOfBirth` - Value object (YYYY-MM-DD format, must be in past)
- `timezone: Timezone` - Value object (IANA timezone, validated)
- `createdAt: DateTime` - Timestamp when user created (UTC)
- `updatedAt: DateTime` - Timestamp when user last modified (UTC)

**Business Invariants:**
- First name and last name cannot be empty strings
- Date of birth must be a valid date in the past
- Timezone must be a valid IANA timezone identifier

**Domain Behaviors:**
- `updateTimezone(newTimezone: Timezone): void` - Updates timezone and triggers recalculation of pending events
- `updateName(firstName: string, lastName: string): void` - Updates user's name
- `updateDateOfBirth(newDateOfBirth: DateOfBirth): void` - Updates birthday and triggers event rescheduling

**[Source: docs/architecture/data-models.md#event]**

**Event Entity:**

- `id: string` - UUID
- `userId: string` - Foreign key to User
- `eventType: string` - Hardcoded to "BIRTHDAY" for Phase 1
- `status: EventStatus` - Enum: PENDING, PROCESSING, COMPLETED, FAILED
- `targetTimestampUTC: DateTime` - When event should execute (UTC, indexed for scheduler queries)
- `targetTimestampLocal: DateTime` - When event should execute in user's local time (9:00 AM)
- `targetTimezone: string` - Timezone used for calculation (user's timezone at event creation)
- `version: number` - Optimistic locking version (start at 1)

**Business Invariants:**
- Status transitions must follow state machine: PENDING → PROCESSING → (COMPLETED | FAILED)
- Cannot transition from COMPLETED or FAILED back to PENDING
- Target timestamp cannot be modified after event enters PROCESSING state

### Event Rescheduling Logic

**[Source: docs/prd/epic-1-foundation-user-management.md#story-1.11]**

When a user updates their birthday or timezone, PENDING events must be rescheduled to maintain correct timing.

**Birthday Change Logic:**

```typescript
private async rescheduleEventsForBirthdayChange(
  user: User,
  oldBirthday: DateOfBirth,
  newBirthday: DateOfBirth
): Promise<void> {
  // Query PENDING birthday events only
  const events = await this.eventRepository.findByUserId(user.id);
  const pendingBirthdayEvents = events.filter(
    e => e.eventType === 'BIRTHDAY' && e.status === EventStatus.PENDING
  );

  for (const event of pendingBirthdayEvents) {
    // Calculate new next birthday at 9:00 AM local time
    const handler = this.eventHandlerRegistry.getHandler('BIRTHDAY');
    const nextBirthdayLocal = handler.calculateNextOccurrence(user);

    // Convert to UTC
    const nextBirthdayUTC = this.timezoneService.convertToUTC(
      nextBirthdayLocal,
      user.timezone
    );

    // Update event
    event.updateTargetTimestamp(nextBirthdayUTC, nextBirthdayLocal, user.timezone.toString());
    await this.eventRepository.update(event);
  }
}
```

**Timezone Change Logic:**

```typescript
private async rescheduleEventsForTimezoneChange(
  user: User,
  oldTimezone: Timezone,
  newTimezone: Timezone
): Promise<void> {
  // Query PENDING events (all types, not just birthday)
  const events = await this.eventRepository.findByUserId(user.id);
  const pendingEvents = events.filter(e => e.status === EventStatus.PENDING);

  for (const event of pendingEvents) {
    // Keep same local time (9:00 AM), recalculate UTC
    const targetTimestampUTC = this.timezoneService.convertToUTC(
      event.targetTimestampLocal,
      newTimezone
    );

    // Update event with new UTC time and timezone
    event.updateTargetTimestamp(targetTimestampUTC, event.targetTimestampLocal, newTimezone.toString());
    await this.eventRepository.update(event);
  }
}
```

**Edge Cases:**

1. **Feb 29 Birthday in Non-Leap Year:**
   - BirthdayEventHandler should handle this by using Feb 28 or Mar 1
   - Defined in BirthdayEventHandler.calculateNextOccurrence() (Story 1.5)

2. **Birthday Already Passed This Year:**
   - If new birthday is Jan 1 and today is Dec 15, schedule for next year (Jan 1 next year)
   - BirthdayEventHandler.calculateNextOccurrence() handles this logic

3. **DST Transitions:**
   - TimezoneService uses Luxon which handles DST automatically
   - 9:00 AM local time remains 9:00 AM even during DST changes

**Transaction Requirements:**

UpdateUserUseCase MUST wrap user update + event rescheduling in a single database transaction:

```typescript
public async execute(userId: string, dto: UpdateUserDTO): Promise<User> {
  return await this.prisma.$transaction(async (tx) => {
    // 1. Update user
    const updatedUser = await tx.users.update(...);

    // 2. Reschedule events if needed
    if (dateOfBirthChanged) {
      await this.rescheduleEventsForBirthdayChange(user, oldBirthday, newBirthday);
    }
    if (timezoneChanged) {
      await this.rescheduleEventsForTimezoneChange(user, oldTimezone, newTimezone);
    }

    return updatedUser;
  });
}
```

This ensures both user update and event rescheduling succeed together or fail together (ACID transaction).

### Error Handling

**[Source: docs/architecture/error-handling.md]**

**Error Types:**

1. **UserNotFoundError** (ApplicationError) - User does not exist (HTTP 404)
2. **ValidationError** (DomainError) - Invalid input data (HTTP 400)
   - `InvalidTimezoneError` - Thrown by Timezone value object
   - `InvalidDateOfBirthError` - Thrown by DateOfBirth if date in future
3. **InfrastructureError** - Database connection failures, network timeouts (HTTP 500)

**Error Response Format:**

```json
{
  "error": {
    "code": "USER_NOT_FOUND",
    "message": "User not found: 550e8400-e29b-41d4-a716-446655440000"
  }
}
```

**Error Codes:**

| Code | HTTP Status | Description |
|------|-------------|-------------|
| VALIDATION_FAILED | 400 | Input validation failed |
| INVALID_TIMEZONE | 400 | Invalid IANA timezone |
| INVALID_DATE_OF_BIRTH | 400 | Date of birth must be in past |
| USER_NOT_FOUND | 404 | User does not exist |
| INTERNAL_ERROR | 500 | Unexpected system error |

**Fastify Error Handler Middleware:**

```typescript
// src/adapters/primary/http/server.ts
server.setErrorHandler((error, request, reply) => {
  if (error instanceof ZodError) {
    return reply.status(400).send({
      error: {
        code: 'VALIDATION_FAILED',
        message: error.message,
        details: error.errors
      }
    });
  }

  if (error instanceof UserNotFoundError) {
    return reply.status(404).send({
      error: {
        code: 'USER_NOT_FOUND',
        message: error.message
      }
    });
  }

  // Default to 500 for unexpected errors
  request.log.error(error);
  return reply.status(500).send({
    error: {
      code: 'INTERNAL_ERROR',
      message: 'An unexpected error occurred'
    }
  });
});
```

### Coding Standards

**[Source: docs/architecture/coding-standards.md]**

**Critical Rules:**

1. **No `any` Types**
   - TypeScript strict mode enabled
   - Use `unknown` if type truly unknown
   - Explicit typing required for all function signatures

2. **Explicit Accessibility Modifiers**
   - All class members MUST have `public`, `private`, or `protected`
   - Enforced as ESLint error

3. **Async/Await Only**
   - No callbacks or raw promises
   - Proper error handling with try/catch

4. **No Console.log**
   - Use Pino logger exclusively
   - Forbidden in `src/` (enforced by ESLint)

5. **Repository Pattern Required**
   - All database access through repository interfaces
   - Never direct Prisma calls from use cases

### Testing

**[Source: docs/architecture/test-strategy.md]**

**Test-Driven Development (TDD) Recommended:**

This story is **ideal for TDD** because:
- ✅ Use case interfaces are well-defined
- ✅ Clear acceptance criteria
- ✅ Following established patterns (dependency injection, port interfaces)
- ✅ Repository interfaces already exist from Story 1.6

**TDD Workflow (Red-Green-Refactor):**

1. **RED**: Write failing test defining desired behavior
2. **GREEN**: Write minimal code to pass the test
3. **REFACTOR**: Clean up while keeping tests green
4. **REPEAT**: Continue until all acceptance criteria are met

**Unit Test Requirements:**

**Framework:** Jest 29.7.0

**Coverage Requirements:**
- Minimum 90% coverage overall
- 100% coverage for critical rescheduling logic in UpdateUserUseCase

**GetUserUseCase Tests:**

```typescript
describe('GetUserUseCase', () => {
  let useCase: GetUserUseCase;
  let mockUserRepo: jest.Mocked<IUserRepository>;

  beforeEach(() => {
    mockUserRepo = {
      findById: jest.fn()
    } as any;
    useCase = new GetUserUseCase(mockUserRepo);
  });

  it('should return user when found', async () => {
    const user = new UserBuilder().build();
    mockUserRepo.findById.mockResolvedValue(user);

    const result = await useCase.execute(user.id);

    expect(result).toEqual(user);
    expect(mockUserRepo.findById).toHaveBeenCalledWith(user.id);
  });

  it('should return null when user not found', async () => {
    mockUserRepo.findById.mockResolvedValue(null);

    const result = await useCase.execute('non-existent-id');

    expect(result).toBeNull();
  });
});
```

**UpdateUserUseCase Tests (Critical Rescheduling Logic):**

```typescript
describe('UpdateUserUseCase', () => {
  it('should reschedule PENDING events when birthday updated', async () => {
    // Arrange: User with birthday Jan 1, PENDING event
    const user = new UserBuilder()
      .withDateOfBirth('1990-01-01')
      .build();
    const event = new EventBuilder()
      .forUser(user.id)
      .withStatus(EventStatus.PENDING)
      .withEventType('BIRTHDAY')
      .build();

    mockUserRepo.findById.mockResolvedValue(user);
    mockEventRepo.findByUserId.mockResolvedValue([event]);

    // Act: Update birthday to Feb 14
    await useCase.execute(user.id, { dateOfBirth: '1990-02-14' });

    // Assert: Event rescheduled to Feb 14 at 9:00 AM
    expect(mockEventRepo.update).toHaveBeenCalledTimes(1);
    expect(mockEventRepo.update).toHaveBeenCalledWith(
      expect.objectContaining({
        targetTimestampLocal: expect.stringContaining('02-14')
      })
    );
  });

  it('should NOT modify COMPLETED events when birthday updated', async () => {
    const user = new UserBuilder().build();
    const completedEvent = new EventBuilder()
      .forUser(user.id)
      .withStatus(EventStatus.COMPLETED)
      .build();

    mockUserRepo.findById.mockResolvedValue(user);
    mockEventRepo.findByUserId.mockResolvedValue([completedEvent]);

    await useCase.execute(user.id, { dateOfBirth: '1990-02-14' });

    // Assert: Event repository update NOT called for COMPLETED events
    expect(mockEventRepo.update).not.toHaveBeenCalled();
  });
});
```

**Integration Test Requirements:**

**Framework:** Jest 29.7.0 with Testcontainers 10.5.0

**Database:** Real PostgreSQL 16 (not in-memory)

**Setup:**
- Testcontainers PostgreSQL container
- Prisma migrations applied
- Test data seeded before each test
- Database cleaned after each test

**Integration Test Pattern:**

```typescript
describe('PUT /user/:id (Integration)', () => {
  let server: FastifyInstance;
  let prisma: PrismaClient;
  let container: PostgreSqlContainer;

  beforeAll(async () => {
    container = await new PostgreSqlContainer('postgres:16').start();
    prisma = new PrismaClient({ datasources: { db: { url: container.getConnectionString() } } });
    await prisma.$executeRawUnsafe('...'); // Run migrations
    server = createServer(prisma);
  });

  afterEach(async () => {
    await prisma.events.deleteMany();
    await prisma.users.deleteMany();
  });

  afterAll(async () => {
    await prisma.$disconnect();
    await container.stop();
  });

  it('should update user and reschedule PENDING events atomically', async () => {
    // Seed user with PENDING event
    const user = await prisma.users.create({ data: { ... } });
    const event = await prisma.events.create({ data: { userId: user.id, status: 'PENDING', ... } });

    // Update user timezone
    const response = await server.inject({
      method: 'PUT',
      url: `/user/${user.id}`,
      payload: { timezone: 'America/Los_Angeles' }
    });

    expect(response.statusCode).toBe(200);

    // Verify event rescheduled
    const updatedEvent = await prisma.events.findUnique({ where: { id: event.id } });
    expect(updatedEvent.targetTimezone).toBe('America/Los_Angeles');
  });
});
```

### Previous Story Insights

**[Source: docs/stories/1.10.create-user-use-case.md]**

**Key Learnings from Story 1.10:**

1. **Bounded Context Separation:**
   - User Context ONLY depends on User domain entities and IUserRepository
   - Event creation happens via domain events (UserCreatedEvent) published to IDomainEventBus
   - CreateUserUseCase constructor has ONLY 2 dependencies: IUserRepository, IDomainEventBus

2. **Type Safety Patterns:**
   - Zod schemas define single source of truth
   - `z.infer<typeof Schema>` derives TypeScript types
   - Schema changes automatically propagate via type inference

3. **Testing Patterns:**
   - Mock IUserRepository and IDomainEventBus in unit tests
   - Testcontainers for integration tests with real PostgreSQL
   - AAA pattern (Arrange, Act, Assert)
   - 100% coverage for critical execute() method

**Note:** Story 1.11 extends the pattern from Story 1.10 by adding Read, Update, and Delete operations. UpdateUserUseCase requires cross-context dependency on IEventRepository for synchronous event rescheduling (different from async UserCreatedEvent pattern).

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story draft created from Epic 1.11 with comprehensive technical context | Bob (Scrum Master) |
| 2025-10-23 | 1.1 | PO validation complete - APPROVED for implementation. Implementation Readiness Score: 10/10. All 17 ACs verified, zero hallucinations detected, comprehensive testing strategy validated. | Bob (Scrum Master - PO Review) |

---

## Dev Agent Record

### Status

Not Started

### Agent Model Used

TBD

### Debug Log References

TBD

### Completion Notes

TBD

### File List

TBD

---

## QA Results

TBD
