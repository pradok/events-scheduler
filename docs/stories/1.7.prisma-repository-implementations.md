# Story 1.7: Prisma Repository Implementations

---

## Status

**Draft**

---

## Story

**As a** developer,
**I want** Prisma-based implementations of repository interfaces,
**so that** domain entities can be persisted to PostgreSQL database.

---

## Acceptance Criteria

1. PrismaUserRepository created in `src/adapters/secondary/persistence/PrismaUserRepository.ts`
2. PrismaEventRepository created in `src/adapters/secondary/persistence/PrismaEventRepository.ts`
3. Repositories implement port interfaces (IUserRepository, IEventRepository)
4. Repositories map between Prisma models and domain entities correctly
5. EventRepository.claimReadyEvents() uses `FOR UPDATE SKIP LOCKED` for atomic claiming
6. EventRepository includes optimistic locking using version field
7. Integration tests use Testcontainers 10.5.0 for real PostgreSQL testing
8. Integration tests achieve 100% coverage for repository methods

---

## Tasks / Subtasks

**Development Approach:** This story is ideal for **Test-Driven Development (TDD)** since we have clear repository interfaces defined in Story 1.6. Follow the Red-Green-Refactor cycle for integration tests.

**TDD Workflow Reminder:**

1. **RED**: Write failing integration test with Testcontainers
2. **GREEN**: Implement repository method to pass the test
3. **REFACTOR**: Clean up while keeping tests green

---

- [ ] **Task 1: Set up Testcontainers for integration testing** (AC: 7)
  - [ ] Install Testcontainers: `npm install --save-dev @testcontainers/postgresql@10.5.0`
  - [ ] Create test helper: `tests/integration/helpers/testDatabase.ts`
  - [ ] Implement PostgreSQL container setup with Prisma migrations
  - [ ] Implement container lifecycle (start before all tests, stop after all tests)
  - [ ] Implement database cleanup between tests
  - [ ] Verify container starts and Prisma connects successfully

- [ ] **Task 2 (TDD): Implement PrismaUserRepository** (AC: 1, 3, 4, 8)
  - [ ] **RED: Write failing integration tests first**
    - [ ] Create `tests/integration/adapters/secondary/persistence/PrismaUserRepository.test.ts`
    - [ ] Write test: "create() should persist user and return with generated ID"
    - [ ] Write test: "findById() should return user when exists"
    - [ ] Write test: "findById() should return null when not exists"
    - [ ] Write test: "findByEmail() should return user when email matches"
    - [ ] Write test: "findByEmail() should return null when email doesn't match"
    - [ ] Write test: "findUsersWithUpcomingBirthdays() should return users with birthdays in next N days"
    - [ ] Write test: "update() should update user fields"
    - [ ] Write test: "delete() should remove user and cascade delete events"
    - [ ] Run tests → expect failures (repository doesn't exist yet)
  - [ ] **GREEN: Implement PrismaUserRepository to pass tests**
    - [ ] Create `src/adapters/secondary/persistence/PrismaUserRepository.ts` file
    - [ ] Import IUserRepository interface from application layer
    - [ ] Import User domain entity
    - [ ] Import PrismaClient
    - [ ] Implement constructor with PrismaClient dependency injection
    - [ ] Implement `create()` method: Map User → Prisma model, save, map back to User
    - [ ] Implement `findById()` method: Query Prisma, map to User domain entity (or null)
    - [ ] Implement `findByEmail()` method: Query by email, map to User
    - [ ] Implement `findUsersWithUpcomingBirthdays()` method: Calculate date range, query Prisma, map results
    - [ ] Implement `update()` method: Map User → Prisma model, update, map back
    - [ ] Implement `delete()` method: Delete user (Prisma cascade deletes events)
    - [ ] Create mapper functions: `toDomain(prismaUser)` and `toPrisma(domainUser)`
    - [ ] Run tests → expect all tests pass
  - [ ] **REFACTOR: Clean up and verify**
    - [ ] Extract mapper functions to separate module if reused
    - [ ] Verify error handling (e.g., unique constraint violations)
    - [ ] Verify all Prisma queries use proper error handling
    - [ ] Run tests again → expect all tests still pass

- [ ] **Task 3 (TDD): Implement PrismaEventRepository** (AC: 2, 3, 4, 5, 6, 8)
  - [ ] **RED: Write failing integration tests first**
    - [ ] Create `tests/integration/adapters/secondary/persistence/PrismaEventRepository.test.ts`
    - [ ] Write test: "create() should persist event and return with generated ID"
    - [ ] Write test: "findById() should return event when exists"
    - [ ] Write test: "findById() should return null when not exists"
    - [ ] Write test: "findByUserId() should return all events for user"
    - [ ] Write test: "findByUserId() should return empty array when no events"
    - [ ] Write test: "update() should update event fields and increment version"
    - [ ] Write test: "update() should fail with stale version (optimistic locking)"
    - [ ] Write test: "claimReadyEvents() should atomically claim PENDING events with targetTimestampUTC <= now"
    - [ ] Write test: "claimReadyEvents() should use FOR UPDATE SKIP LOCKED to prevent race conditions"
    - [ ] Write test: "claimReadyEvents() should respect limit parameter"
    - [ ] Write test: "claimReadyEvents() should not return events already claimed by another transaction"
    - [ ] Run tests → expect failures (repository doesn't exist yet)
  - [ ] **GREEN: Implement PrismaEventRepository to pass tests**
    - [ ] Create `src/adapters/secondary/persistence/PrismaEventRepository.ts` file
    - [ ] Import IEventRepository interface from application layer
    - [ ] Import Event domain entity
    - [ ] Import PrismaClient
    - [ ] Implement constructor with PrismaClient dependency injection
    - [ ] Implement `create()` method: Map Event → Prisma model, save, map back
    - [ ] Implement `findById()` method: Query Prisma, map to Event domain entity (or null)
    - [ ] Implement `findByUserId()` method: Query by userId, map results
    - [ ] Implement `update()` method with optimistic locking: Check version, update + increment version, handle conflicts
    - [ ] Implement `claimReadyEvents()` method: Use `FOR UPDATE SKIP LOCKED`, filter by timestamp and PENDING status, transition to PROCESSING, limit results
    - [ ] Create mapper functions: `toDomain(prismaEvent)` and `toPrisma(domainEvent)`
    - [ ] Run tests → expect all tests pass
  - [ ] **REFACTOR: Clean up and verify**
    - [ ] Extract mapper functions to separate module if reused
    - [ ] Verify optimistic locking throws appropriate error on version mismatch
    - [ ] Verify FOR UPDATE SKIP LOCKED query is correct
    - [ ] Run tests again → expect all tests still pass

- [ ] **Task 4: Final validation** (AC: 8)
  - [ ] Run complete integration test suite: `npm test tests/integration/`
  - [ ] Verify all integration tests pass (100% repository method coverage)
  - [ ] Run full test suite: `npm test` (should still be 100% passing)
  - [ ] Run `npm run build` to verify TypeScript compilation
  - [ ] Verify no console.log statements (use Pino logger if needed)
  - [ ] Verify all Prisma queries use async/await (no raw promises)

---

## Dev Notes

### Previous Story Insights

**[Source: Story 1.6 - Dev Agent Record]**

Key learnings from Story 1.6 (Repository Port Interfaces):

1. **Port Interfaces Defined**: Story 1.6 created IUserRepository (6 methods) and IEventRepository (5 methods) with comprehensive JSDoc. This story implements those interfaces with Prisma.

2. **claimReadyEvents Semantic Understanding**: Story 1.6 documented the dual-purpose nature of claimReadyEvents (normal polling + recovery mode). This implementation MUST use `FOR UPDATE SKIP LOCKED` to achieve the atomic claiming behavior described.

3. **Zero Infrastructure Dependencies in Ports**: Port interfaces have NO Prisma imports. This story creates the adapter layer that bridges domain entities and Prisma models.

4. **Relative Imports**: Project uses relative imports (no path aliases configured in tsconfig.json). Continue this pattern.

---

### Architecture Context

**[Source: architecture/port-interfaces.md]**

#### Hexagonal Architecture - Adapter Layer

This story implements **Secondary Adapters** (Outbound/Driven Adapters) in the Hexagonal Architecture:

- **Port Interfaces** (Story 1.6): `IUserRepository`, `IEventRepository` in `src/application/ports/`
- **Adapter Implementations** (THIS STORY): `PrismaUserRepository`, `PrismaEventRepository` in `src/adapters/secondary/persistence/`

**Dependency Direction:**
```
Domain Layer (entities)
    ↑
Application Layer (ports) ← depends on domain
    ↑
Adapter Layer (Prisma implementations) ← depends on application ports + domain
```

**Technology Abstraction:**
- Adapters depend on ports (interfaces)
- Adapters know about Prisma
- Ports/Domain know NOTHING about Prisma
- Future adapters (e.g., DynamoDB, MongoDB) can replace Prisma without changing domain/application

---

### Data Models and Mapping

**[Source: architecture/data-models.md]**

#### User Entity → Prisma User Model Mapping

**Domain Entity (User):**
```typescript
class User {
  id: string;              // UUID
  firstName: string;       // 1-100 chars
  lastName: string;        // 1-100 chars
  dateOfBirth: DateOfBirth; // Value object
  timezone: Timezone;      // Value object (IANA string)
  createdAt: Date;
  updatedAt: Date;
}
```

**Prisma Model (from Story 1.3):**
```prisma
model User {
  id          String   @id @default(uuid())
  firstName   String   @db.VarChar(100)
  lastName    String   @db.VarChar(100)
  dateOfBirth String   @db.VarChar(10)  // Stored as "YYYY-MM-DD"
  timezone    String   @db.VarChar(50)  // IANA timezone
  createdAt   DateTime @default(now()) @db.Timestamptz
  updatedAt   DateTime @updatedAt @db.Timestamptz
  events      Event[]
}
```

**Mapping Rules:**
- `dateOfBirth`: Domain uses `DateOfBirth` value object, Prisma uses string. Convert using `DateOfBirth.fromString(prisma.dateOfBirth)` and `domainUser.dateOfBirth.toString()`
- `timezone`: Domain uses `Timezone` value object, Prisma uses string. Convert using `new Timezone(prisma.timezone)` and `domainUser.timezone.toString()`
- All other fields map directly

#### Event Entity → Prisma Event Model Mapping

**Domain Entity (Event):**
```typescript
class Event {
  id: string;
  userId: string;
  eventType: string;
  status: EventStatus;     // Value object enum
  targetTimestampUTC: Date;
  targetTimestampLocal: Date;
  targetTimezone: string;
  executedAt: Date | null;
  failureReason: string | null;
  retryCount: number;
  version: number;         // For optimistic locking
  idempotencyKey: string;
  deliveryPayload: object; // JSON
  createdAt: Date;
  updatedAt: Date;
}
```

**Prisma Model (from Story 1.3):**
```prisma
model Event {
  id                   String       @id @default(uuid())
  userId               String
  eventType            String       @db.VarChar(50)
  status               EventStatus  @default(PENDING)
  targetTimestampUTC   DateTime     @db.Timestamptz
  targetTimestampLocal DateTime     @db.Timestamptz
  targetTimezone       String       @db.VarChar(50)
  executedAt           DateTime?    @db.Timestamptz
  failureReason        String?
  retryCount           Int          @default(0)
  version              Int          @default(1)
  idempotencyKey       String       @unique @db.VarChar(100)
  deliveryPayload      Json
  createdAt            DateTime     @default(now()) @db.Timestamptz
  updatedAt            DateTime     @updatedAt @db.Timestamptz
  user                 User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status, targetTimestampUTC])
}
```

**Mapping Rules:**
- `status`: Domain uses `EventStatus` value object, Prisma uses enum. Convert using `EventStatus.fromString(prisma.status)` and `domainEvent.status.toString()`
- `deliveryPayload`: Prisma stores as Json, domain uses plain object. Map directly with JSON.parse/stringify
- All timestamp fields map directly (JavaScript Date ↔ Prisma DateTime)

---

### Prisma Client and Dependency Injection

**[Source: architecture/tech-stack.md]**

#### Prisma Client Usage

- **Version:** Prisma 6.17.1 (from Story 1.3)
- **Location:** Adapters import `@prisma/client`
- **Singleton:** PrismaClient should be instantiated once and injected into repositories
- **Connection:** Already configured in Story 1.3 (PostgreSQL via Docker)

**Repository Constructor Pattern:**
```typescript
export class PrismaUserRepository implements IUserRepository {
  constructor(private readonly prisma: PrismaClient) {}

  async create(user: User): Promise<User> {
    // Use this.prisma.user.create(...)
  }
}
```

#### Optimistic Locking Pattern

**Event Updates:**
```typescript
async update(event: Event): Promise<Event> {
  const updated = await this.prisma.event.update({
    where: {
      id: event.id,
      version: event.version  // Only update if version matches
    },
    data: {
      ...eventData,
      version: { increment: 1 }  // Increment version
    }
  });

  if (!updated) {
    throw new OptimisticLockError(`Event ${event.id} was modified by another transaction`);
  }

  return toDomain(updated);
}
```

#### Atomic Event Claiming with FOR UPDATE SKIP LOCKED

**Critical Implementation:**
```typescript
async claimReadyEvents(limit: number): Promise<Event[]> {
  const now = new Date();

  // Raw SQL required for FOR UPDATE SKIP LOCKED
  const events = await this.prisma.$queryRaw`
    SELECT * FROM "Event"
    WHERE "status" = 'PENDING'
      AND "targetTimestampUTC" <= ${now}
    ORDER BY "targetTimestampUTC" ASC
    LIMIT ${limit}
    FOR UPDATE SKIP LOCKED
  `;

  // Transition claimed events to PROCESSING
  const eventIds = events.map(e => e.id);
  await this.prisma.event.updateMany({
    where: { id: { in: eventIds } },
    data: { status: 'PROCESSING', version: { increment: 1 } }
  });

  // Return as domain entities
  return events.map(toDomain);
}
```

**Why FOR UPDATE SKIP LOCKED:**
- Multiple scheduler instances may query simultaneously
- `FOR UPDATE` locks rows for update
- `SKIP LOCKED` skips already-locked rows (prevents blocking)
- Result: Each scheduler instance claims DIFFERENT events (no duplicates)

---

### Project Structure

**[Source: architecture/source-tree.md]**

File locations for this story:

```
src/adapters/
└── secondary/
    └── persistence/
        ├── PrismaUserRepository.ts       # IUserRepository implementation
        ├── PrismaEventRepository.ts      # IEventRepository implementation
        ├── mappers/
        │   ├── userMapper.ts             # Domain ↔ Prisma User mapping
        │   └── eventMapper.ts            # Domain ↔ Prisma Event mapping

tests/integration/
├── helpers/
│   └── testDatabase.ts                   # Testcontainers setup
└── adapters/
    └── secondary/
        └── persistence/
            ├── PrismaUserRepository.test.ts
            └── PrismaEventRepository.test.ts
```

**Import Rules:**
- Adapters CAN import: Domain entities, application ports, Prisma client
- Adapters CANNOT be imported by: Domain or application layers

---

### Testing Strategy

**[Source: architecture/test-strategy.md]**

#### Integration Tests with Testcontainers

**Why Testcontainers:**
- Tests run against REAL PostgreSQL (not mocks)
- Verifies Prisma queries work correctly
- Tests database constraints (unique, foreign keys, cascades)
- Tests `FOR UPDATE SKIP LOCKED` behavior with real database

**Test Setup Pattern:**
```typescript
import { PostgreSqlContainer } from '@testcontainers/postgresql';
import { PrismaClient } from '@prisma/client';
import { execSync } from 'child_process';

let container: StartedPostgreSqlContainer;
let prisma: PrismaClient;

beforeAll(async () => {
  // Start PostgreSQL container
  container = await new PostgreSqlContainer('postgres:16-alpine')
    .withDatabase('testdb')
    .start();

  // Set DATABASE_URL for Prisma
  process.env.DATABASE_URL = container.getConnectionUri();

  // Run Prisma migrations
  execSync('npx prisma migrate deploy', { stdio: 'inherit' });

  // Create Prisma client
  prisma = new PrismaClient();
}, 60000); // 60s timeout for container startup

afterAll(async () => {
  await prisma.$disconnect();
  await container.stop();
});

beforeEach(async () => {
  // Clean database between tests
  await prisma.event.deleteMany();
  await prisma.user.deleteMany();
});
```

**Test Coverage Goals:**
- 100% coverage for all repository methods
- Test happy paths and error cases
- Test database constraints (unique email, foreign keys)
- Test optimistic locking conflicts
- Test `FOR UPDATE SKIP LOCKED` race conditions

**TDD Approach:**
- Write integration test first (RED)
- Implement repository method (GREEN)
- Refactor while keeping tests green (REFACTOR)

---

### Coding Standards

**[Source: architecture/coding-standards.md]**

#### Repository Implementation Standards

1. **Naming Conventions:**
   - Class names: PascalCase (e.g., `PrismaUserRepository`)
   - File names: PascalCase (e.g., `PrismaUserRepository.ts`)
   - Method names: camelCase (match interface methods exactly)

2. **Error Handling:**
   - Catch Prisma errors and throw domain-specific errors
   - Example: `PrismaClientKnownRequestError` with code `P2002` → `UniqueConstraintViolationError`
   - Always log errors using Pino before throwing

3. **Async/Await:**
   - Use async/await for all Prisma operations
   - NO raw promises or callbacks
   - Proper error handling with try/catch

4. **No Console.log:**
   - Use Pino logger for debugging
   - No `console.log` in production code

5. **TypeScript Strict Mode:**
   - No `any` types
   - Explicit return types on all public methods
   - Null safety (use `| null` for optional returns)

---

### Critical Implementation Notes

#### 1. Mapper Functions

**Purpose:** Convert between domain entities and Prisma models

**Location:** `src/adapters/secondary/persistence/mappers/`

**Example - User Mapper:**
```typescript
import { User } from '@/domain/entities/User';
import { DateOfBirth } from '@/domain/value-objects/DateOfBirth';
import { Timezone } from '@/domain/value-objects/Timezone';
import { User as PrismaUser } from '@prisma/client';

export function userToDomain(prismaUser: PrismaUser): User {
  return new User({
    id: prismaUser.id,
    firstName: prismaUser.firstName,
    lastName: prismaUser.lastName,
    dateOfBirth: DateOfBirth.fromString(prismaUser.dateOfBirth),
    timezone: new Timezone(prismaUser.timezone),
    createdAt: prismaUser.createdAt,
    updatedAt: prismaUser.updatedAt,
  });
}

export function userToPrisma(domainUser: User) {
  return {
    id: domainUser.id,
    firstName: domainUser.firstName,
    lastName: domainUser.lastName,
    dateOfBirth: domainUser.dateOfBirth.toString(), // "YYYY-MM-DD"
    timezone: domainUser.timezone.toString(),       // IANA string
    createdAt: domainUser.createdAt,
    updatedAt: domainUser.updatedAt,
  };
}
```

#### 2. Optimistic Locking Error Handling

**Create Custom Error:**
```typescript
// src/domain/errors/OptimisticLockError.ts
export class OptimisticLockError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'OptimisticLockError';
  }
}
```

**Use in Repository:**
```typescript
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';

async update(event: Event): Promise<Event> {
  try {
    const updated = await this.prisma.event.update({
      where: { id: event.id, version: event.version },
      data: { ...eventData, version: { increment: 1 } }
    });
    return toDomain(updated);
  } catch (error) {
    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2025') {
      throw new OptimisticLockError(`Event ${event.id} was modified by another transaction`);
    }
    throw error;
  }
}
```

#### 3. Birthday Calculation for findUsersWithUpcomingBirthdays

**Query Strategy:**
```typescript
async findUsersWithUpcomingBirthdays(daysAhead: number): Promise<User[]> {
  const today = new Date();
  const endDate = new Date(today);
  endDate.setDate(today.getDate() + daysAhead);

  // Extract month-day strings for comparison
  const todayMD = `${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
  const endMD = `${String(endDate.getMonth() + 1).padStart(2, '0')}-${String(endDate.getDate()).padStart(2, '0')}`;

  // Query users where MM-DD of dateOfBirth is in range
  // Handle year wrap-around (e.g., Dec 30 to Jan 5)
  const users = await this.prisma.user.findMany({
    where: {
      OR: [
        // Normal range (no year wrap)
        todayMD <= endMD ? {
          dateOfBirth: {
            gte: `${today.getFullYear()}-${todayMD}`,
            lte: `${today.getFullYear()}-${endMD}`
          }
        } : undefined,
        // Year wrap range (Dec → Jan)
        todayMD > endMD ? {
          OR: [
            { dateOfBirth: { gte: `${today.getFullYear()}-${todayMD}` } },
            { dateOfBirth: { lte: `${endDate.getFullYear()}-${endMD}` } }
          ]
        } : undefined
      ].filter(Boolean) // Remove undefined
    }
  });

  return users.map(userToDomain);
}
```

---

### Why This Story Matters

**[Source: architecture/port-interfaces.md#benefits]**

1. **Testability:** Repositories can now be tested against real PostgreSQL using Testcontainers
2. **Persistence:** Domain entities can finally be saved and retrieved from database
3. **Dependency Inversion:** Application layer depends on abstractions (IUserRepository), this story provides concrete implementation
4. **Technology Flexibility:** Future stories can swap Prisma for TypeORM/DynamoDB without changing application/domain code
5. **Atomic Operations:** FOR UPDATE SKIP LOCKED enables distributed scheduler without race conditions

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-22 | 1.0 | Initial story draft created from Epic 1.7 with comprehensive technical context | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
