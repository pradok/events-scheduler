# Story 3.2: Recovery Execution (Simplified)

---

## Status

Ready for Review

---

## Story

**As a** developer,
**I want** missed events automatically queued for execution,
**so that** recovery happens without manual intervention.

---

## Acceptance Criteria

1. RecoveryService sends missed events to SQS queue
2. Each event sent with existing SQS message format (eventId, eventType, idempotencyKey, metadata)
3. Recovery service logs completion: "Recovery complete: X events queued"
4. Unit tests verify missed events are sent to SQS
5. Integration tests verify end-to-end recovery flow (detection → SQS → execution)

---

## Tasks / Subtasks

- [x] **Task 1: Add ISQSClient Dependency to RecoveryService** (AC: 1)
  - [x] Open `src/modules/event-scheduling/domain/services/RecoveryService.ts` (created in Story 3.1)
  - [x] Add `ISQSClient` to constructor parameters (alongside IEventRepository, ILogger)
  - [x] Import ISQSClient from `src/modules/event-scheduling/application/ports/ISQSClient.ts`
  - [x] Reference: [Source: docs/stories/3.1.recovery-service-missed-event-detection.story.md]

- [x] **Task 2: Update execute() to Send Events to SQS** (AC: 1, 2, 3)
  - [x] Modify `execute()` method in RecoveryService
  - [x] After `findMissedEvents()` returns events, loop through each event
  - [x] For each event, create SQSMessagePayload:
    ```typescript
    const payload: SQSMessagePayload = {
      eventId: event.id,
      eventType: event.eventType,
      idempotencyKey: event.idempotencyKey.toString(),
      metadata: {}
    };
    ```
  - [x] Call `await this.sqsClient.sendMessage(payload)` for each event
  - [x] Log completion: `logger.info('Recovery complete', { eventsQueued: events.length })`
  - [x] Update RecoveryResult to include `eventsQueued: number`
  - [x] Reference: [Source: docs/stories/2.2.sqs-queue-integration.story.md#SQSMessagePayload]

- [x] **Task 3: Handle SQS Send Errors** (AC: 1)
  - [x] Wrap `sqsClient.sendMessage()` in try-catch
  - [x] On error, log: `logger.error('Failed to queue event for recovery', { eventId, error })`
  - [x] Continue processing remaining events (don't fail entire recovery)
  - [x] Track failed count separately from successful count
  - [x] Log both: `logger.info('Recovery complete', { eventsQueued, eventsFailed })`

- [x] **Task 4: Write Unit Tests for SQS Integration** (AC: 4)
  - [x] Open `src/modules/event-scheduling/domain/services/RecoveryService.test.ts` (created in Story 3.1)
  - [x] Add mock for ISQSClient: `const mockSQSClient = { sendMessage: jest.fn() }`
  - [x] Test: `should send missed events to SQS`
    - Arrange: Mock findMissedEvents() to return 3 events
    - Act: Call recoveryService.execute()
    - Assert: sqsClient.sendMessage called 3 times
    - Assert: Each call contains correct payload structure
  - [x] Test: `should log recovery completion with count`
    - Assert: logger.info called with "Recovery complete" and eventsQueued
  - [x] Test: `should continue recovery if one event fails to send`
    - Arrange: Mock sendMessage() to throw on 2nd event
    - Act: Call execute()
    - Assert: 1st and 3rd events still sent
    - Assert: Error logged for 2nd event
  - [x] Reference: [Source: docs/architecture/test-strategy.md#Unit-Tests]

- [x] **Task 5: Write Integration Tests for E2E Recovery** (AC: 5)
  - [x] Create `src/__tests__/integration/recovery-e2e.integration.test.ts`
  - [x] Use real LocalStack SQS (not mocked)
  - [x] Use real PostgreSQL database (Testcontainers)
  - [x] Test: End-to-end recovery flow
    - Arrange: Create 5 missed events in database (targetTimestampUTC in past, status=PENDING)
    - Act: Call recoveryService.execute()
    - Assert: Verify 5 messages in SQS queue using ReceiveMessage
    - Assert: Each message contains correct event data
    - Assert: Logs show "Recovery complete: 5 events queued"
  - [x] Clean up: Delete test events and purge SQS queue in afterEach
  - [x] Reference: [Source: docs/architecture/test-strategy.md#Integration-Tests]

- [x] **Task 6: Update RecoveryResult Type** (AC: 3)
  - [x] Open RecoveryService.ts
  - [x] Update RecoveryResult interface:
    ```typescript
    interface RecoveryResult {
      missedEventsCount: number;
      eventsQueued: number;
      eventsFailed: number;
      oldestEventTimestamp: DateTime | null;
      newestEventTimestamp: DateTime | null;
    }
    ```
  - [x] Return updated result from execute() method

---

## Dev Notes

### Important Context from Previous Stories

**Story 3.1 - Recovery Service Detection:**
- RecoveryService created with `findMissedEvents()` method
- Returns events where `status = 'PENDING' AND targetTimestampUTC < NOW()`
- Events ordered by targetTimestampUTC ASC (oldest first)
- Batch limit of 1000 events per recovery run
- **THIS STORY ADDS:** SQS sending to queue missed events for execution

**Story 2.2 - SQS Queue Integration:**
- SQSMessagePayload schema: `{ eventId, eventType, idempotencyKey, metadata }`
- ISQSClient interface: `sendMessage(payload: SQSMessagePayload): Promise<string>`
- SQSAdapter implementation in `src/adapters/secondary/messaging/SQSAdapter.ts`
- LocalStack queue name: `events-queue`
- **THIS STORY USES:** Existing SQS infrastructure for recovery

### Simplified Approach (MVP)

**What we're NOT doing (deferred to Epic 4):**
- ❌ Late execution flag (`lateExecution: true`)
- ❌ Lateness calculation (hours late)
- ❌ Separate metrics for recovery vs on-time execution
- ❌ Performance optimization (batch sends)

**What we ARE doing (MVP):**
- ✅ Detect missed events (Story 3.1)
- ✅ Send them to SQS (this story)
- ✅ Let existing worker Lambda process them normally
- ✅ Log recovery completion

**Why this is sufficient:**
- Existing SQS worker handles event execution (Story 2.6)
- Existing idempotency keys prevent duplicates (Story 2.7)
- Existing retry logic handles transient failures (Story 2.4)
- Simple, works, ships fast

### RecoveryService Flow (Simplified)

```typescript
public async execute(): Promise<RecoveryResult> {
  // 1. Find missed events (Story 3.1)
  const missedEvents = await this.eventRepository.findMissedEvents(1000);

  if (missedEvents.length === 0) {
    this.logger.info('No missed events found');
    return {
      missedEventsCount: 0,
      eventsQueued: 0,
      eventsFailed: 0,
      oldestEventTimestamp: null,
      newestEventTimestamp: null
    };
  }

  // 2. Send to SQS (this story - NEW)
  let queuedCount = 0;
  let failedCount = 0;

  for (const event of missedEvents) {
    try {
      const payload: SQSMessagePayload = {
        eventId: event.id,
        eventType: event.eventType,
        idempotencyKey: event.idempotencyKey.toString(),
        metadata: {}
      };

      await this.sqsClient.sendMessage(payload);
      queuedCount++;
    } catch (error) {
      this.logger.error('Failed to queue event for recovery', {
        eventId: event.id,
        error: error.message
      });
      failedCount++;
    }
  }

  // 3. Log completion
  this.logger.info('Recovery complete', {
    eventsQueued: queuedCount,
    eventsFailed: failedCount
  });

  return {
    missedEventsCount: missedEvents.length,
    eventsQueued: queuedCount,
    eventsFailed: failedCount,
    oldestEventTimestamp: missedEvents[0].targetTimestampUTC,
    newestEventTimestamp: missedEvents[missedEvents.length - 1].targetTimestampUTC
  };
}
```

### Error Handling Strategy

**Continue on SQS failure:**
- Better to recover 99/100 events than fail entire batch
- Failed events logged for manual inspection
- Operator can manually retry failed events if needed

### File Locations

**Files to Modify:**

- `src/modules/event-scheduling/domain/services/RecoveryService.ts` (add SQS sending)

**Test Files to Create/Update:**

- `src/modules/event-scheduling/domain/services/RecoveryService.test.ts` (add SQS tests)
- `src/modules/event-scheduling/domain/services/RecoveryService.integration.test.ts` (NEW - E2E test)

### Technology Stack

[Source: docs/architecture/tech-stack.md]

**Dependencies:**
- **AWS SDK (SQS)** - Message queue integration (already configured)
- **Pino 10.1.0** - Structured logging (already configured)
- **Zod 4.1.12** - SQS message schema validation

### Testing Standards

[Source: docs/architecture/test-strategy.md]

**Unit Test Requirements:**
- Mock ISQSClient, IEventRepository, ILogger
- Use AAA pattern (Arrange, Act, Assert)
- Coverage requirement: ≥80%

**Integration Test Requirements:**
- Use real LocalStack SQS
- Use real PostgreSQL (Testcontainers)
- Clean up in afterEach hooks
- Timeout: 60000ms

---

## Testing

### Test File Locations

**Unit Tests:**

- `src/modules/event-scheduling/domain/services/RecoveryService.test.ts` (extend existing)

**Integration Tests:**

- `src/modules/event-scheduling/domain/services/RecoveryService.integration.test.ts` (NEW)

### Example Unit Test

```typescript
describe('RecoveryService - SQS Integration', () => {
  let recoveryService: RecoveryService;
  let mockEventRepo: jest.Mocked<IEventRepository>;
  let mockSQSClient: jest.Mocked<ISQSClient>;
  let mockLogger: jest.Mocked<ILogger>;

  beforeEach(() => {
    mockEventRepo = { findMissedEvents: jest.fn() } as any;
    mockSQSClient = { sendMessage: jest.fn() } as any;
    mockLogger = { info: jest.fn(), error: jest.fn() } as any;

    recoveryService = new RecoveryService(
      mockEventRepo,
      mockSQSClient,
      mockLogger
    );
  });

  it('should send missed events to SQS', async () => {
    // Arrange
    const missedEvents = [
      new EventBuilder().thatIsOverdue(24).build(),
      new EventBuilder().thatIsOverdue(48).build()
    ];
    mockEventRepo.findMissedEvents.mockResolvedValue(missedEvents);
    mockSQSClient.sendMessage.mockResolvedValue('message-id');

    // Act
    const result = await recoveryService.execute();

    // Assert
    expect(mockSQSClient.sendMessage).toHaveBeenCalledTimes(2);
    expect(result.eventsQueued).toBe(2);
    expect(mockLogger.info).toHaveBeenCalledWith(
      'Recovery complete',
      expect.objectContaining({ eventsQueued: 2 })
    );
  });
});
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-26 | 1.0 | Simplified version created for MVP | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

None - All tests passing

### Completion Notes

Successfully implemented Story 3.2: Recovery Execution (Simplified)

**Implementation Summary:**

- Added ISQSClient dependency to RecoveryService constructor
- Updated execute() method to send missed events to SQS queue
- Implemented error handling: continues processing on SQS failures
- Updated RecoveryResult interface with eventsQueued and eventsFailed fields
- All unit tests passing (10/10)
- All integration tests passing (4/4)

**Key Implementation Details:**

- Each missed event is sent to SQS with proper payload structure
- SQS send errors are logged but don't halt recovery of remaining events
- Recovery completion is logged with eventsQueued and eventsFailed counts
- Follows simplified MVP approach - no lateExecution flag (deferred to Epic 4)

### File List

**Modified Files:**

- [src/modules/event-scheduling/domain/services/RecoveryService.ts](../../src/modules/event-scheduling/domain/services/RecoveryService.ts)
- [src/modules/event-scheduling/domain/services/RecoveryService.test.ts](../../src/modules/event-scheduling/domain/services/RecoveryService.test.ts)

**Created Files:**

- [src/**tests**/integration/recovery-e2e.integration.test.ts](../../src/__tests__/integration/recovery-e2e.integration.test.ts)

---

## QA Results

*This section will be populated by QA agent after implementation*
