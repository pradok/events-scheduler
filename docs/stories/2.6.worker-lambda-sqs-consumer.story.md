# Story 2.6: Worker Lambda - SQS Consumer

---

## Status

Approved

---

## Story

**As a** developer,
**I want** a worker Lambda that consumes events from SQS queue,
**so that** events are executed asynchronously from scheduling.

---

## Acceptance Criteria

1. Lambda handler created in `src/adapters/primary/lambda/workerHandler.ts`
2. Handler configured to be triggered by SQS messages (batch size: 10)
3. Handler validates incoming SQS messages against SQSMessageSchema from Story 2.2
4. Handler uses derived types from schema for type-safe message processing
5. Handler wraps ExecuteEventUseCase with dependency injection
6. Handler processes each message in batch independently
7. Handler rejects invalid messages with schema validation errors (sent to DLQ)
8. Handler deletes message from queue only after successful execution
9. Handler logs processing results for each message with validation status
10. LocalStack SQS trigger configured and tested
11. Integration tests verify end-to-end flow from queue to execution with schema validation

---

## Tasks / Subtasks

- [ ] **Task 1: Create Worker Lambda Handler** (AC: 1, 2, 5, 6)
  - [ ] Create `src/adapters/primary/lambda/workerHandler.ts`
  - [ ] Define `SQSEvent` interface matching AWS Lambda SQS event structure
  - [ ] Define `SQSRecord` interface for individual messages in the batch
  - [ ] Implement `handler(event: SQSEvent): Promise<void>` function
  - [ ] Create singleton PrismaClient using same pattern as schedulerHandler
  - [ ] Create singleton SQSClient for LocalStack integration
  - [ ] Implement dependency injection:
    - Create PrismaEventRepository with singleton Prisma client
    - Create WebhookAdapter with configured webhook URL from environment
    - Create ExecuteEventUseCase with injected dependencies
  - [ ] Process each SQS record in `event.Records` independently
  - [ ] Extract `eventId` from message body
  - [ ] Call `executeEventUseCase.execute(eventId)` for each message
  - [ ] Reference: [Source: architecture/source-tree.md#Lambda-Handlers, docs/stories/2.3.eventbridge-scheduler-trigger.story.md]

- [ ] **Task 2: Implement SQS Message Validation** (AC: 3, 4, 7)
  - [ ] Import `SQSMessagePayload` and `SQSMessagePayloadSchema` from Story 2.2
  - [ ] Parse message body as JSON: `JSON.parse(record.body)`
  - [ ] Validate parsed body against `SQSMessagePayloadSchema.safeParse()`
  - [ ] If validation fails:
    - Log error with structured context (messageId, validation errors)
    - Throw error to send message to DLQ (do NOT delete from queue)
    - Include validation error details in log for debugging
  - [ ] If validation succeeds:
    - Extract `eventId` from validated payload
    - Type-safe access to payload fields using derived `SQSMessagePayload` type
  - [ ] Reference: [Source: architecture/coding-standards.md#Zod-Schemas-as-Single-Source-of-Truth, docs/stories/2.2.sqs-queue-integration.story.md]

- [ ] **Task 3: Implement Error Handling and Message Deletion** (AC: 7, 8, 9)
  - [ ] Wrap each record processing in try-catch block
  - [ ] On successful execution:
    - Log success with INFO level (eventId, messageId, duration)
    - Return normally (Lambda automatically deletes message from queue)
  - [ ] On PermanentDeliveryError (4xx webhook error):
    - Log error with ERROR level (eventId, messageId, error details)
    - Return normally (message deleted, event marked FAILED in DB)
  - [ ] On InfrastructureError (5xx webhook error, timeout, network):
    - Log error with ERROR level (eventId, messageId, error details)
    - Throw error to trigger SQS retry (message NOT deleted, reappears in queue)
  - [ ] On ValidationError (invalid SQS message):
    - Log error with ERROR level (messageId, validation errors)
    - Throw error to send message to DLQ (cannot be retried)
  - [ ] On Event not found:
    - Log warning with WARN level (eventId, messageId)
    - Return normally (idempotent behavior - message deleted)
  - [ ] Add structured logging with Pino:
    - correlationId: messageId
    - eventId: from message payload
    - idempotencyKey: from message payload
    - duration: execution time in ms
  - [ ] Reference: [Source: architecture/error-handling.md#External-API-Errors, docs/stories/2.5.event-executor-use-case.story.md]

- [ ] **Task 4: Configure LocalStack SQS Trigger** (AC: 10)
  - [ ] Verify SQS queue exists: `events-queue` (created in Story 2.2)
  - [ ] Verify Dead Letter Queue exists: `events-dlq` (create if missing in init-aws.sh)
  - [ ] Create Lambda function in LocalStack using AWS SDK
  - [ ] Package Lambda handler code using esbuild (bundle dependencies)
  - [ ] Deploy Lambda to LocalStack via script: `scripts/deploy-worker-lambda.js`
  - [ ] Configure SQS event source mapping:
    - Queue: `events-queue`
    - Batch size: 10 messages
    - Visibility timeout: 60 seconds (allows worker 60s to process before message reappears)
    - Dead Letter Queue: `events-dlq` (for messages that fail repeatedly)
    - Max receive count: 3 (send to DLQ after 3 failed attempts)
  - [ ] Verify trigger works: Send test message to queue, verify Lambda invoked
  - [ ] Reference: [Source: architecture/tech-stack.md#LocalStack, docker/localstack/init-aws.sh]

- [ ] **Task 5: Write Unit Tests** (AC: 6, 7, 9)
  - [ ] Create `src/adapters/primary/lambda/workerHandler.test.ts`
  - [ ] Mock dependencies: PrismaClient, ExecuteEventUseCase, logger
  - [ ] Test: should process each SQS record independently
    - Arrange: SQSEvent with 3 valid records
    - Act: call handler(event)
    - Assert: executeEventUseCase.execute() called 3 times with correct eventIds
  - [ ] Test: should validate message against SQSMessagePayloadSchema
    - Arrange: SQSEvent with 1 invalid record (missing eventId)
    - Act: call handler(event)
    - Assert: throws ValidationError, logger.error called with validation details
  - [ ] Test: should delete message on successful execution
    - Arrange: SQSEvent with 1 valid record
    - Arrange: Mock executeEventUseCase.execute() to resolve successfully
    - Act: call handler(event)
    - Assert: handler completes without throwing (Lambda deletes message)
  - [ ] Test: should NOT delete message on InfrastructureError (retry)
    - Arrange: SQSEvent with 1 valid record
    - Arrange: Mock executeEventUseCase.execute() to throw InfrastructureError
    - Act: call handler(event)
    - Assert: handler throws error (Lambda does NOT delete message)
  - [ ] Test: should delete message on PermanentDeliveryError (no retry)
    - Arrange: SQSEvent with 1 valid record
    - Arrange: Mock executeEventUseCase.execute() to throw PermanentDeliveryError
    - Act: call handler(event)
    - Assert: handler completes without throwing (Lambda deletes message)
  - [ ] Test: should log processing results for each message
    - Assert: logger.info called on success
    - Assert: logger.error called on failure
    - Assert: logs include eventId, messageId, duration
  - [ ] Test: should handle event not found gracefully (idempotent)
    - Arrange: Mock executeEventUseCase.execute() to return (event not found scenario)
    - Act: call handler(event)
    - Assert: logger.warn called, handler completes without throwing
  - [ ] Follow AAA pattern (Arrange, Act, Assert)
  - [ ] Achieve â‰¥80% code coverage
  - [ ] Reference: [Source: architecture/test-strategy.md#Unit-Tests]

- [ ] **Task 6: Write Integration Tests** (AC: 11)
  - [ ] Create `src/adapters/primary/lambda/workerHandler.integration.test.ts`
  - [ ] Use LocalStack SQS (not mocked)
  - [ ] Use Testcontainers PostgreSQL for real database
  - [ ] Setup: Create test queue, deploy Lambda to LocalStack, run database migrations
  - [ ] Teardown: Delete queue, stop containers
  - [ ] Test: should consume message from queue and execute event
    - Arrange: Create event in database (status PROCESSING)
    - Arrange: Send SQS message with eventId to queue
    - Act: Trigger Lambda handler manually
    - Assert: Event status updated to COMPLETED in database
    - Assert: Message deleted from queue
  - [ ] Test: should send invalid message to DLQ
    - Arrange: Send SQS message with invalid payload (missing eventId)
    - Act: Trigger Lambda handler manually
    - Assert: Message sent to DLQ
    - Assert: Original queue is empty
  - [ ] Test: should retry message on InfrastructureError
    - Arrange: Create event in database (status PROCESSING)
    - Arrange: Configure webhook to return 503 (transient failure)
    - Arrange: Send SQS message to queue
    - Act: Trigger Lambda handler manually
    - Assert: Message NOT deleted (reappears in queue after visibility timeout)
    - Assert: Event status remains PROCESSING in database
  - [ ] Test: should validate schema and use derived types
    - Arrange: Send SQS message with valid SQSMessagePayload
    - Act: Trigger Lambda handler manually
    - Assert: Message processed successfully
    - Assert: All payload fields accessible with correct types
  - [ ] Reference: [Source: architecture/test-strategy.md#Integration-Tests]

---

## Dev Notes

### Previous Story Insights

From **Story 2.2 (SQS Queue Integration)**:

- SQS queue `events-queue` created in LocalStack via `docker/localstack/init-aws.sh`
- `SQSMessagePayloadSchema` defined in `src/shared/validation/schemas.ts` with fields:
  - `eventId: z.string().uuid()` - Event to execute
  - `eventType: z.string()` - Event type (e.g., "BIRTHDAY", "ANNIVERSARY", "REMINDER")
  - `idempotencyKey: z.string()` - Idempotency key for webhook delivery
  - `metadata: z.object()` - Additional context (userId, timestamp, deliveryPayload)
- `SQSMessagePayload` type derived using `z.infer<typeof SQSMessagePayloadSchema>`
- LocalStack SQS endpoint: `http://localhost:4566`
- Queue URL: `http://localhost:4566/000000000000/events-queue`

From **Story 2.5 (Event Executor Use Case)**:
- `ExecuteEventUseCase` already implemented in `src/modules/event-scheduling/application/use-cases/ExecuteEventUseCase.ts`
- Use case signature: `execute(eventId: string): Promise<void>`
- Use case dependencies: `IEventRepository`, `IWebhookClient`
- Error handling:
  - `PermanentDeliveryError` (4xx) â†’ mark event FAILED, do NOT retry
  - `InfrastructureError` (5xx, timeout) â†’ leave event PROCESSING, DO retry via SQS
  - Event not found â†’ log warning, return (idempotent)
  - Invalid event status â†’ log error, return
- Comprehensive logging with Pino (eventId, idempotencyKey, duration, error details)

From **Story 2.4 (Webhook Delivery Adapter)**:

- `WebhookAdapter` implements `IWebhookClient` port interface
- Adapter location: `src/adapters/secondary/delivery/WebhookAdapter.ts`
- Constructor signature:

  ```typescript
  constructor(config: {
    webhookUrl: string;
    timeout?: number;    // Default: 10000ms
    retries?: number;    // Default: 3
  })
  ```

- Webhook URL from environment: `WEBHOOK_TEST_URL`
- Retry logic: 3 attempts with exponential backoff (1s, 2s, 4s) - already built into adapter
- Error classification: 4xx = PermanentDeliveryError, 5xx = InfrastructureError

**Key Lessons:**
- Worker Lambda should use `ExecuteEventUseCase` (not WebhookAdapter directly)
- Trust ExecuteEventUseCase error handling - it knows when to throw for retry vs. when to complete
- SQS message validation MUST use `SQSMessagePayloadSchema` for consistency
- Lambda handler pattern: singleton clients for warm start performance (same as schedulerHandler)
- Message deletion is automatic if handler returns normally (success or permanent failure)
- Message retry is automatic if handler throws error (transient failure)

### Architecture Context

#### File Location

**Worker Lambda Handler:**
```
src/adapters/primary/lambda/workerHandler.ts
src/adapters/primary/lambda/workerHandler.test.ts
src/adapters/primary/lambda/workerHandler.integration.test.ts
```

[Source: architecture/source-tree.md]

#### Lambda Handler Pattern

**Purpose:** Primary/inbound adapter that receives SQS events and orchestrates use case execution

**Structure (based on schedulerHandler.ts):**
```typescript
import { PrismaClient } from '@prisma/client';
import { SQSEvent, SQSRecord } from 'aws-lambda';
import { PrismaEventRepository } from '...';
import { WebhookAdapter } from '...';
import { ExecuteEventUseCase } from '...';
import { SQSMessagePayload, SQSMessagePayloadSchema } from '...';
import { logger } from '../../../shared/logger';

// Singleton clients for warm start optimization
let prismaClient: PrismaClient | null = null;
let sqsClient: SQSClient | null = null;

function getPrismaClient(): PrismaClient {
  if (!prismaClient) {
    prismaClient = new PrismaClient();
  }
  return prismaClient;
}

export async function handler(event: SQSEvent): Promise<void> {
  // 1. Setup dependencies (singleton pattern)
  const prisma = getPrismaClient();
  const eventRepository = new PrismaEventRepository(prisma);
  const webhookClient = new WebhookAdapter(/* ... */);
  const executeEventUseCase = new ExecuteEventUseCase(eventRepository, webhookClient);

  // 2. Process each record independently
  for (const record of event.Records) {
    // 3. Validate message schema
    // 4. Execute use case
    // 5. Handle errors appropriately
  }
}
```

**Key Principles:**
- Singleton PrismaClient reused across Lambda warm starts (connection pool)
- Dependency injection wires up repositories and adapters
- Each SQS record processed independently (batch processing)
- Errors thrown = message retried; errors caught = message deleted
- Comprehensive logging with correlation IDs (messageId)

[Source: architecture/design-patterns.md#Hexagonal-Architecture, src/adapters/primary/lambda/schedulerHandler.ts]

#### AWS Lambda SQS Event Structure

**SQSEvent Interface:**
```typescript
interface SQSEvent {
  Records: SQSRecord[];
}

interface SQSRecord {
  messageId: string;               // SQS message ID (use as correlationId)
  receiptHandle: string;           // For manual deletion (not needed - automatic)
  body: string;                    // JSON string containing SQSMessagePayload
  attributes: {
    ApproximateReceiveCount: string;
    SentTimestamp: string;
    SenderId: string;
    ApproximateFirstReceiveTimestamp: string;
  };
  messageAttributes: {              // Message attributes from SQSAdapter
    eventType: { stringValue: string };
    idempotencyKey: { stringValue: string };
  };
  md5OfBody: string;
  eventSource: string;              // "aws:sqs"
  eventSourceARN: string;           // Queue ARN
  awsRegion: string;                // "us-east-1"
}
```

**Parsing Message Body:**
```typescript
const parsed = JSON.parse(record.body);
const validationResult = SQSMessagePayloadSchema.safeParse(parsed);

if (!validationResult.success) {
  // Invalid message - send to DLQ
  throw new ValidationError('Invalid SQS message payload', validationResult.error);
}

const payload: SQSMessagePayload = validationResult.data;
const eventId = payload.eventId;  // Type-safe access
```

[Source: AWS Lambda Developer Guide, architecture/tech-stack.md#AWS-Lambda]

#### SQS Batch Processing

**Batch Size:** 10 messages per Lambda invocation (configured in event source mapping)

**Processing Strategy:**
- Process each record in `event.Records` array independently
- Continue processing remaining records even if one fails
- Track successes and failures separately
- Return partial batch failures to SQS (Lambda handles this automatically)

**Error Handling Per Record:**
```typescript
for (const record of event.Records) {
  try {
    // Process record
    await executeEventUseCase.execute(eventId);
    logger.info({ messageId: record.messageId, eventId }, 'Message processed successfully');
    // Lambda deletes message automatically on success
  } catch (error) {
    if (error instanceof InfrastructureError) {
      // Transient failure - retry
      logger.error({ messageId: record.messageId, eventId, error }, 'Transient failure - will retry');
      throw error; // Rethrow to trigger SQS retry
    } else if (error instanceof PermanentDeliveryError) {
      // Permanent failure - do not retry
      logger.error({ messageId: record.messageId, eventId, error }, 'Permanent failure - message will be deleted');
      // Do NOT throw - message deleted
    } else {
      // Unexpected error - log and decide retry strategy
      logger.error({ messageId: record.messageId, eventId, error }, 'Unexpected error');
      throw error; // Rethrow to be safe
    }
  }
}
```

[Source: architecture/error-handling.md#External-API-Errors, AWS Lambda SQS Integration]

#### Message Deletion Behavior

**Automatic Deletion (Lambda Default):**
- If handler returns normally (no throw) â†’ message deleted from queue
- If handler throws error â†’ message NOT deleted, reappears in queue after visibility timeout

**Visibility Timeout:**
- Duration: 60 seconds (configured in event source mapping)
- Purpose: Prevents other workers from processing message while current worker is processing
- If processing exceeds 60s and handler hasn't completed â†’ message reappears in queue

**Dead Letter Queue (DLQ):**
- Messages that fail repeatedly (exceed max receive count) â†’ sent to DLQ
- Max receive count: 3 (configured in queue settings)
- DLQ name: `events-dlq`
- Manual intervention required to process DLQ messages

[Source: architecture/error-handling.md#Error-Recovery, AWS SQS Documentation]

#### Dependency Injection in Lambda

**Pattern:**
```typescript
export async function handler(event: SQSEvent): Promise<void> {
  // Get singleton Prisma client
  const prisma = getPrismaClient();

  // Create repositories (implements port interfaces)
  const eventRepository = new PrismaEventRepository(prisma);

  // Create adapters (implements port interfaces)
  const webhookClient = new WebhookAdapter({
    webhookUrl: process.env.WEBHOOK_TEST_URL!,
    timeout: 10000,
    retries: 3,
  });

  // Create use case (depends on ports, not concrete implementations)
  const executeEventUseCase = new ExecuteEventUseCase(
    eventRepository,
    webhookClient
  );

  // Process messages using use case
  for (const record of event.Records) {
    // ... process record using executeEventUseCase
  }
}
```

**Why This Pattern:**
- Hexagonal Architecture: Use cases depend on port interfaces (IEventRepository, IWebhookClient)
- Lambda handler is thin orchestration layer (primary adapter)
- Easy to test: mock port interfaces, not concrete implementations
- Environment-specific configuration (webhook URL, timeouts) injected via environment variables

[Source: architecture/design-patterns.md#Dependency-Injection, src/adapters/primary/lambda/schedulerHandler.ts:80-104]

#### ExecuteEventUseCase Integration

**Use Case Contract:**
```typescript
// From Story 2.5
export class ExecuteEventUseCase {
  public constructor(
    private readonly eventRepository: IEventRepository,
    private readonly webhookClient: IWebhookClient
  ) {}

  public async execute(eventId: string): Promise<void> {
    // 1. Retrieve event from repository
    // 2. Validate event status is PROCESSING
    // 3. Deliver webhook via webhookClient
    // 4. Update event status based on result
  }
}
```

**Error Behavior:**
- Throws `InfrastructureError` â†’ transient failure, retry via SQS
- Throws `PermanentDeliveryError` â†’ permanent failure, DO NOT retry (but ExecuteEventUseCase catches this internally and marks event FAILED)
- Event not found â†’ logs warning, returns normally
- Invalid event status â†’ logs error, returns normally

**Worker Lambda Usage:**
```typescript
try {
  await executeEventUseCase.execute(eventId);
  // Success - message will be deleted
  logger.info({ eventId, messageId }, 'Event executed successfully');
} catch (error) {
  if (error instanceof InfrastructureError) {
    // Transient failure - rethrow to retry
    logger.error({ eventId, messageId, error }, 'Transient failure - retrying');
    throw error;
  } else {
    // Unexpected error - rethrow to be safe
    logger.error({ eventId, messageId, error }, 'Unexpected error');
    throw error;
  }
}
```

**IMPORTANT:** ExecuteEventUseCase handles PermanentDeliveryError internally by marking event FAILED. It does NOT rethrow this error. Worker Lambda only sees InfrastructureError for transient failures.

[Source: docs/stories/2.5.event-executor-use-case.story.md, architecture/error-handling.md#Error-Handling-Patterns]

#### Logging Standards

**Logger:** Pino 8.17.2 (singleton instance from `src/shared/logger.ts`)

**Required Log Fields:**
- `msg` - Human-readable message
- `messageId` - SQS message ID (correlationId for request tracing)
- `eventId` - Event ID being processed
- `idempotencyKey` - For request correlation with webhook logs
- `duration` - Processing duration in ms
- `error` - Error message (for failures)
- `stack` - Stack trace (for failures)

**Log Levels:**
- ERROR: Transient failures (will retry), permanent failures, unexpected errors
- WARN: Event not found, invalid event status, schema validation warnings
- INFO: Successful execution, message processed
- DEBUG: Detailed flow (not used in Lambda - performance overhead)

**Example:**
```typescript
import { logger } from '../../../shared/logger';

// Start processing
const startTime = Date.now();
logger.info({
  msg: 'Processing SQS message',
  messageId: record.messageId,
  eventId: payload.eventId,
  idempotencyKey: payload.idempotencyKey,
});

// Success
logger.info({
  msg: 'Message processed successfully',
  messageId: record.messageId,
  eventId,
  duration: Date.now() - startTime,
});

// Error
logger.error({
  msg: 'Message processing failed',
  messageId: record.messageId,
  eventId,
  error: error.message,
  stack: error.stack,
  duration: Date.now() - startTime,
});
```

[Source: architecture/error-handling.md#Logging-Standards, architecture/coding-standards.md#Critical-Rules]

#### TypeScript Standards

**Required:**
- Explicit accessibility modifiers (`public`, `private`, `protected`)
- Explicit return types for all functions
- No `any` types (use `unknown` if type unknown)
- Async/await (no callbacks or raw promises)
- Proper error handling with try/catch

**Lambda Handler Signature:**
```typescript
export async function handler(event: SQSEvent): Promise<void> {
  // Implementation
}
```

**SQS Event Types:**
```typescript
import type { SQSEvent, SQSRecord } from 'aws-lambda';

// Or define manually if not using @types/aws-lambda
interface SQSEvent {
  Records: SQSRecord[];
}

interface SQSRecord {
  messageId: string;
  body: string;
  // ... other fields
}
```

[Source: architecture/coding-standards.md#Core-Standards]

#### Environment Variables

**Required:**
- `DATABASE_URL` - PostgreSQL connection string (from Prisma)
- `WEBHOOK_TEST_URL` - Webhook endpoint URL for delivery
- `AWS_ENDPOINT_URL` - LocalStack endpoint (default: http://localhost:4566)
- `SQS_QUEUE_URL` - SQS queue URL (not needed by worker - only scheduler)
- `NODE_ENV` - Environment (development, test, production)

**Configuration:**
```typescript
// Validation (optional but recommended)
const requiredEnvVars = ['DATABASE_URL', 'WEBHOOK_TEST_URL'];
for (const varName of requiredEnvVars) {
  if (!process.env[varName]) {
    throw new Error(`Missing required environment variable: ${varName}`);
  }
}

// Usage
const webhookUrl = process.env.WEBHOOK_TEST_URL!;
```

[Source: .env.example, architecture/tech-stack.md#Environment-Config]

### Testing

#### Test Location

**Unit Tests:** `src/adapters/primary/lambda/workerHandler.test.ts`
**Integration Tests:** `src/adapters/primary/lambda/workerHandler.integration.test.ts`

[Source: architecture/test-strategy.md#Unit-Tests]

#### Testing Framework

- **Framework:** Jest 29.7.0
- **Mocking:** Jest built-in mocks (no additional library)
- **Pattern:** AAA (Arrange, Act, Assert)
- **Testcontainers:** PostgreSQL 16 (integration tests only)
- **LocalStack:** SQS integration (integration tests only)

[Source: architecture/test-strategy.md#Unit-Tests]

#### Coverage Requirements

- **Worker Lambda Handler:** â‰¥80% coverage required
- **Critical error paths:** 100% coverage (transient vs permanent error handling)
- **Overall:** â‰¥80% coverage for adapter layer

[Source: architecture/test-strategy.md#Coverage-Goals]

#### Test Scenarios Required

**Success Scenarios:**
1. Message with valid payload â†’ event executed successfully â†’ message deleted
2. Batch of 10 messages â†’ all processed independently
3. Message attributes (eventType, idempotencyKey) â†’ logged correctly

**Failure Scenarios:**
4. Invalid message payload (schema validation fails) â†’ ValidationError thrown â†’ message sent to DLQ
5. Event not found â†’ warning logged â†’ message deleted (idempotent)
6. InfrastructureError (5xx webhook) â†’ error logged â†’ message NOT deleted â†’ will retry
7. PermanentDeliveryError (4xx webhook) â†’ error logged â†’ message deleted â†’ event marked FAILED

**Edge Cases:**
8. Event status not PROCESSING â†’ warning logged â†’ message deleted (idempotent)
9. Unexpected error â†’ error logged â†’ message NOT deleted â†’ will retry (safe default)
10. Empty batch â†’ handler returns normally
11. Batch with mix of valid and invalid messages â†’ each processed independently

[Source: architecture/test-strategy.md#AI-Agent-Requirements, architecture/coding-standards.md#Test-Requirements]

#### Mocking Strategy

**Mock PrismaClient:**
```typescript
const mockPrismaClient = {
  event: {
    findUnique: jest.fn(),
    update: jest.fn(),
  },
} as unknown as PrismaClient;
```

**Mock ExecuteEventUseCase:**
```typescript
const mockExecuteEventUseCase: jest.Mocked<ExecuteEventUseCase> = {
  execute: jest.fn(),
} as any;
```

**Mock SQS Event:**
```typescript
const createSQSEvent = (records: Partial<SQSRecord>[]): SQSEvent => ({
  Records: records.map(r => ({
    messageId: r.messageId || 'test-message-id',
    receiptHandle: r.receiptHandle || 'test-receipt-handle',
    body: r.body || JSON.stringify({
      eventId: '123e4567-e89b-12d3-a456-426614174000',
      eventType: 'BIRTHDAY',
      idempotencyKey: 'test-key',
      metadata: {
        userId: '660e8400-e29b-41d4-a716-446655440001',
        timestamp: '2025-10-24T09:00:00.000Z',
        deliveryPayload: { message: 'Test message' },
      },
    }),
    attributes: {
      ApproximateReceiveCount: '1',
      SentTimestamp: '1234567890000',
      SenderId: 'test-sender',
      ApproximateFirstReceiveTimestamp: '1234567890000',
    },
    messageAttributes: {},
    md5OfBody: 'test-md5',
    eventSource: 'aws:sqs',
    eventSourceARN: 'arn:aws:sqs:us-east-1:000000000000:events-queue',
    awsRegion: 'us-east-1',
  })),
});
```

[Source: architecture/test-strategy.md#Use-Case-Test-Example]

#### Test Naming Convention

Use descriptive names explaining behavior:
- `should process all messages in batch independently`
- `should validate message against SQSMessagePayloadSchema`
- `should delete message on successful execution`
- `should NOT delete message on InfrastructureError (retry)`
- `should delete message on PermanentDeliveryError (no retry)`
- `should send invalid message to DLQ with ValidationError`
- `should log warning and delete message when event not found`

[Source: architecture/test-strategy.md#Test-Naming-Conventions]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Created story for Worker Lambda - SQS Consumer | Bob (Scrum Master) |
| 2025-10-24 | 1.1 | PO validation fixes: (1) Added DLQ verification subtask, (2) Added WebhookAdapter constructor example, (3) Renamed all queue references from `bday-events-*` to `events-*` for event-type agnostic naming. Updated status to Approved. | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes

_To be populated by dev agent_

### Files Created/Modified

_To be populated by dev agent_

---

## QA Results

_To be populated by QA agent_
